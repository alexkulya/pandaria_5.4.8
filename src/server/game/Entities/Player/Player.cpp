/*
* This file is part of the Pandaria 5.4.8 Project. See THANKS file for Copyright information
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the
* Free Software Foundation; either version 2 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include "Player.h"
#include "AccountMgr.h"
#include "AchievementMgr.h"
#include "Battlefield.h"
#include "BattlefieldMgr.h"
#include "BattlefieldWG.h"
#include "Battleground.h"
#include "BattlegroundMgr.h"
#include "BattlePetMgr.h"
#include "CellImpl.h"
#include "Channel.h"
#include "ChannelMgr.h"
#include "CharacterDatabaseCleaner.h"
#include "Chat.h"
#include "Common.h"
#include "ConditionMgr.h"
#include "CreatureAI.h"
#include "DatabaseEnv.h"
#include "DBCStructure.h"
#include "DB2Stores.h"
#include "DisableMgr.h"
#include "Formulas.h"
#include "GameEventMgr.h"
#include "GameObjectAI.h"
#include "GossipDef.h"
#include "GridNotifiers.h"
#include "GridNotifiersImpl.h"
#include "Group.h"
#include "GroupMgr.h"
#include "Guild.h"
#include "GuildMgr.h"
#include "InstanceSaveMgr.h"
#include "InstanceScript.h"
#include "LFGMgr.h"
#include "Language.h"
#include "Log.h"
#include "MapInstanced.h"
#include "MapManager.h"
#include "ObjectAccessor.h"
#include "ObjectMgr.h"
#include "Opcodes.h"
#include "OutdoorPvP.h"
#include "OutdoorPvPMgr.h"
#include "Pet.h"
#include "QuestDef.h"
#include "ReputationMgr.h"
#include "SkillDiscovery.h"
#include "SocialMgr.h"
#include "Spell.h"
#include "SpellAuraEffects.h"
#include "SpellAuras.h"
#include "SpellMgr.h"
#include "Transport.h"
#include "UpdateData.h"
#include "UpdateFieldFlags.h"
#include "UpdateMask.h"
#include "Util.h"
#include "Vehicle.h"
#include "Weather.h"
#include "WeatherMgr.h"
#include "World.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "WorldStateBuilder.h"
#include "MovementStructures.h"
#include "Config.h"
#include "ServiceMgr.h"
#include "AnticheatMgr.h"
#include "SpellHistory.h"
#include "RatedPvp.h"
#include "CustomLogs.h"
#include "PoolMgr.h"
#include "Vignette.h"
#include "LootLockoutMap.h"
#include <ace/Stack_Trace.h>

#define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)

enum CharacterFlags
{
    CHARACTER_FLAG_NONE                 = 0x00000000,
    CHARACTER_FLAG_UNK1                 = 0x00000001,
    CHARACTER_FLAG_UNK2                 = 0x00000002,
    CHARACTER_LOCKED_FOR_TRANSFER       = 0x00000004,
    CHARACTER_FLAG_UNK4                 = 0x00000008,
    CHARACTER_FLAG_UNK5                 = 0x00000010,
    CHARACTER_FLAG_UNK6                 = 0x00000020,
    CHARACTER_FLAG_UNK7                 = 0x00000040,
    CHARACTER_FLAG_UNK8                 = 0x00000080,
    CHARACTER_FLAG_UNK9                 = 0x00000100,
    CHARACTER_FLAG_UNK10                = 0x00000200,
    CHARACTER_FLAG_HIDE_HELM            = 0x00000400,
    CHARACTER_FLAG_HIDE_CLOAK           = 0x00000800,
    CHARACTER_FLAG_UNK13                = 0x00001000,
    CHARACTER_FLAG_GHOST                = 0x00002000,
    CHARACTER_FLAG_RENAME               = 0x00004000,
    CHARACTER_FLAG_UNK16                = 0x00008000,
    CHARACTER_FLAG_UNK17                = 0x00010000,
    CHARACTER_FLAG_UNK18                = 0x00020000,
    CHARACTER_FLAG_UNK19                = 0x00040000,
    CHARACTER_FLAG_UNK20                = 0x00080000,
    CHARACTER_FLAG_UNK21                = 0x00100000,
    CHARACTER_FLAG_UNK22                = 0x00200000,
    CHARACTER_FLAG_UNK23                = 0x00400000,
    CHARACTER_FLAG_UNK24                = 0x00800000,
    CHARACTER_FLAG_LOCKED_BY_BILLING    = 0x01000000,
    CHARACTER_FLAG_DECLINED             = 0x02000000,
    CHARACTER_FLAG_UNK27                = 0x04000000,
    CHARACTER_FLAG_UNK28                = 0x08000000,
    CHARACTER_FLAG_UNK29                = 0x10000000,
    CHARACTER_FLAG_UNK30                = 0x20000000,
    CHARACTER_FLAG_UNK31                = 0x40000000,
    CHARACTER_FLAG_UNK32                = 0x80000000
};

enum CharacterCustomizeFlags
{
    CHAR_CUSTOMIZE_FLAG_NONE            = 0x00000000,
    CHAR_CUSTOMIZE_FLAG_CUSTOMIZE       = 0x00000001,       // name, gender, etc...
    CHAR_CUSTOMIZE_FLAG_FACTION         = 0x00010000,       // name, gender, faction, etc...
    CHAR_CUSTOMIZE_FLAG_RACE            = 0x00100000        // name, gender, race, etc...
};

// corpse reclaim times
#define DEATH_EXPIRE_STEP (5*MINUTE)
#define MAX_DEATH_COUNT 3

static uint32 copseReclaimDelay[MAX_DEATH_COUNT] = { 30, 60, 120 };

uint32 const MasterySpells[MAX_CLASSES] =
{
        0,
    87500,  // Warrior
    87494,  // Paladin
    87493,  // Hunter
    87496,  // Rogue
    87495,  // Priest
    87492,  // Death Knight
    87497,  // Shaman
    86467,  // Mage
    87498,  // Warlock
        0,
    87491,  // Druid
};

static uint8 GetOtherRune(uint8 index)
{
    if (index == 0)
        return 1;
    return index % 2 ? index - 1 : index + 1;
}

// == PlayerTaxi ================================================

PlayerTaxi::PlayerTaxi()
{
    memset(m_taximask, 0, sizeof(m_taximask));
}

void PlayerTaxi::InitTaxiNodesForLevel(uint32 race, uint32 chrClass, uint8 level)
{
    // class specific initial known nodes
    switch (chrClass)
    {
        case CLASS_DEATH_KNIGHT:
        {
            for (uint8 i = 0; i < TaxiMaskSize; ++i)
                m_taximask[i] |= sOldContinentsNodesMask[i];
            break;
        }
    }

    // https://wow.gamepedia.com/Flight_path: Patch 4.0.3a (2010-11-23): All characters now know the flight paths to their faction's capital cities, starting zone hubs, and Dalaran.
    switch (Player::TeamForRace(race))
    {
        case ALLIANCE:
            SetTaximaskNode(2);                  // Stormwind, Elwynn
            SetTaximaskNode(582);                // Goldshire, Elwynn
            SetTaximaskNode(589);                // Eastvale Logging Camp, Elwynn
            SetTaximaskNode(6);                  // Ironforge, Dun Morogh
            SetTaximaskNode(619);                // Kharanos, Dun Morogh
            SetTaximaskNode(620);                // Gol'Bolar Quarry, Dun Morogh
            SetTaximaskNode(26);                 // Lor'danel, Darkshore
            SetTaximaskNode(456);                // Dolanaar, Teldrassil
            SetTaximaskNode(457);                // Darnassus, Teldrassil
            SetTaximaskNode(94);                 // The Exodar
            SetTaximaskNode(624);                // Azure Watch, Azuremyst Isle
            SetTaximaskNode(49);                 // Moonglade
            SetTaximaskNode(100);                // Honor Hold, Hellfire Peninsula
            break;
        case HORDE:
            SetTaximaskNode(23);                 // Orgrimmar, Durotar
            SetTaximaskNode(536);                // Sen'jin Village, Durotar
            SetTaximaskNode(537);                // Razor Hill, Durotar
            SetTaximaskNode(11);                 // Undercity, Tirisfal
            SetTaximaskNode(384);                // The Bulwark, Tirisfal
            SetTaximaskNode(460);                // Brill, Tirisfal Glades
            SetTaximaskNode(22);                 // Thunder Bluff, Mulgore
            SetTaximaskNode(402);                // Bloodhoof Village, Mulgore
            SetTaximaskNode(82);                 // Silvermoon City
            SetTaximaskNode(625);                // Fairbreeze Village, Eversong Woods
            SetTaximaskNode(631);                // Falconwing Square, Eversong Woods
            SetTaximaskNode(99);                 // Thrallmar, Hellfire Peninsula
            break;
    }
    SetTaximaskNode(128);                        // Shattrath, Terokkar Forest
    SetTaximaskNode(310);                        // Dalaran

    // level dependent taxi hubs
    if (level >= 68)
        SetTaximaskNode(213);                    // Shattered Sun Staging Area
}

void PlayerTaxi::LoadTaxiMask(std::string const &data)
{
    Tokenizer tokens(data, ' ');

    uint8 index = 0;
    for (Tokenizer::const_iterator iter = tokens.begin(); index < TaxiMaskSize && iter != tokens.end(); ++iter, ++index)
    {
        // load and set bits only for existing taxi nodes
        m_taximask[index] = sTaxiNodesMask[index] & uint32(atol(*iter));
    }
}

void PlayerTaxi::AppendTaximaskTo(ByteBuffer& data, bool all)
{
    if (all)
    {
        for (uint8 i = 0; i < TaxiMaskSize; ++i)
            data << uint8(sTaxiNodesMask[i]);              // all existed nodes
    }
    else
    {
        for (uint8 i = 0; i < TaxiMaskSize; ++i)
            data << uint8(m_taximask[i]);                  // known nodes
    }
}

bool PlayerTaxi::LoadTaxiDestinationsFromString(const std::string& values, uint32 team)
{
    ClearTaxiDestinations();

    Tokenizer Tokenizer(values, ' ');

    for (Tokenizer::const_iterator iter = Tokenizer.begin(); iter != Tokenizer.end(); ++iter)
    {
        uint32 node = uint32(atol(*iter));
        AddTaxiDestination(node);
    }

    if (m_taxiDestinations.empty())
        return true;

    // Check integrity
    if (m_taxiDestinations.size() < 2)
        return false;

    for (size_t i = 1; i < m_taxiDestinations.size(); ++i)
    {
        uint32 cost;
        uint32 path;
        sObjectMgr->GetTaxiPath(m_taxiDestinations[i-1], m_taxiDestinations[i], path, cost);
        if (!path)
            return false;
    }

    // can't load taxi path without mount set (quest taxi path?)
    if (!sObjectMgr->GetTaxiMountDisplayId(GetTaxiSource(), team, true))
        return false;

    return true;
}

std::string PlayerTaxi::SaveTaxiDestinationsToString()
{
    if (m_taxiDestinations.empty())
        return "";

    std::ostringstream ss;

    for (size_t i=0; i < m_taxiDestinations.size(); ++i)
        ss << m_taxiDestinations[i] << ' ';

    return ss.str();
}

uint32 PlayerTaxi::GetCurrentTaxiPath() const
{
    if (m_taxiDestinations.size() < 2)
        return 0;

    uint32 path;
    uint32 cost;

    sObjectMgr->GetTaxiPath(m_taxiDestinations[0], m_taxiDestinations[1], path, cost);

    return path;
}

std::ostringstream& operator<< (std::ostringstream& ss, PlayerTaxi const& taxi)
{
    for (uint8 i = 0; i < TaxiMaskSize; ++i)
        ss << uint32(taxi.m_taximask[i]) << ' ';
    return ss;
}

//== TradeData =================================================

TradeData* TradeData::GetTraderData() const
{
    return m_trader->GetTradeData();
}

Item* TradeData::GetItem(TradeSlots slot) const
{
    return m_items[slot] ? m_player->GetItemByGuid(m_items[slot]) : NULL;
}

bool TradeData::HasItem(uint64 itemGuid) const
{
    for (uint8 i = 0; i < TRADE_SLOT_COUNT; ++i)
        if (m_items[i] == itemGuid)
            return true;

    return false;
}

TradeSlots TradeData::GetTradeSlotForItem(uint64 itemGuid) const
{
    for (uint8 i = 0; i < TRADE_SLOT_COUNT; ++i)
        if (m_items[i] == itemGuid)
            return TradeSlots(i);

    return TRADE_SLOT_INVALID;
}

Item* TradeData::GetSpellCastItem() const
{
    return m_spellCastItem ? m_player->GetItemByGuid(m_spellCastItem) : NULL;
}

void TradeData::SetItem(TradeSlots slot, Item* item)
{
    uint64 itemGuid = item ? item->GetGUID() : 0;

    if (m_items[slot] == itemGuid)
        return;

    m_items[slot] = itemGuid;

    SetAccepted(false);
    GetTraderData()->SetAccepted(false);

    Update();

    // need remove possible trader spell applied to changed item
    if (slot == TRADE_SLOT_NONTRADED)
        GetTraderData()->SetSpell(0);

    // need remove possible player spell applied (possible move reagent)
    SetSpell(0);
}

void TradeData::SetSpell(uint32 spell_id, Item* castItem /*= NULL*/)
{
    uint64 itemGuid = castItem ? castItem->GetGUID() : 0;

    if (m_spell == spell_id && m_spellCastItem == itemGuid)
        return;

    m_spell = spell_id;
    m_spellCastItem = itemGuid;

    SetAccepted(false);
    GetTraderData()->SetAccepted(false);

    Update(true);                                           // send spell info to item owner
    Update(false);                                          // send spell info to caster self
}

void TradeData::SetMoney(uint64 money)
{
    if (m_money == money)
        return;

    m_money = money;

    SetAccepted(false);
    GetTraderData()->SetAccepted(false);

    Update(true);
}

void TradeData::Update(bool forTarget /*= true*/)
{
    if (forTarget)
        m_trader->GetSession()->SendUpdateTrade(true);      // player state for trader
    else
        m_player->GetSession()->SendUpdateTrade(false);     // player state for player
}

void TradeData::SetAccepted(bool state, bool crosssend /*= false*/)
{
    m_accepted = state;

    if (!state)
    {
        if (crosssend)
            m_trader->GetSession()->SendTradeStatus(TRADE_STATUS_UNACCEPTED);
        else
            m_player->GetSession()->SendTradeStatus(TRADE_STATUS_UNACCEPTED);
    }
}

// == KillRewarder ====================================================
// KillRewarder incapsulates logic of rewarding player upon kill with:
// * XP;
// * honor;
// * reputation;
// * kill credit (for quest objectives).
// Rewarding is initiated in two cases: when player kills unit in Unit::Kill()
// and on battlegrounds in Battleground::RewardXPAtKill().
//
// Rewarding algorithm is:
// 1. Initialize internal variables to default values.
// 2. In case when player is in group, initialize variables necessary for group calculations:
// 2.1. _count - number of alive group members within reward distance;
// 2.2. _sumLevel - sum of levels of alive group members within reward distance;
// 2.3. _maxLevel - maximum level of alive group member within reward distance;
// 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
//      for whom victim is not gray;
// 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
//      so 100% XP will be rewarded (50% otherwise).
// 3. Reward killer (and group, if necessary).
// 3.1. If killer is in group, reward group.
// 3.1.1. Initialize initial XP amount based on maximum level of group member,
//        for whom victim is not gray.
// 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
// 3.1.3. Reward each group member (even dead) within reward distance (see 4. for more details).
// 3.2. Reward single killer (not group case).
// 3.2.1. Initialize initial XP amount based on killer's level.
// 3.2.2. Reward killer (see 4. for more details).
// 4. Reward player.
// 4.1. Give honor (player must be alive and not on BG).
// 4.2. Give XP.
// 4.2.1. If player is in group, adjust XP:
//        * set to 0 if player's level is more than maximum level of not gray member;
//        * cut XP in half if _isFullXP is false.
// 4.2.2. Apply auras modifying rewarded XP.
// 4.2.3. Give XP to player.
// 4.2.4. If player has pet, reward pet with XP (100% for single player, 50% for group case).
// 4.3. Give reputation (player must not be on BG).
// 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
// 5. Credit instance encounter.
// 6. Update guild achievements.
KillRewarder::KillRewarder(Player* killer, Unit* victim, bool isBattleGround) :
    // 1. Initialize internal variables to default values.
    _killer(killer), _victim(victim), _group(killer->GetGroup()),
    _groupRate(1.0f), _maxNotGrayMember(NULL), _count(0), _sumLevel(0), _xp(0),
    _isFullXP(false), _maxLevel(0), _isBattleGround(isBattleGround), _isPvP(false)
{
    // mark the credit as pvp if victim is player
    if (victim->GetTypeId() == TYPEID_PLAYER)
        _isPvP = true;
    // or if its owned by player and its not a vehicle
    else if (IS_PLAYER_GUID(victim->GetCharmerOrOwnerGUID()))
        _isPvP = !victim->IsVehicle();

    InitGroupData();
}

void KillRewarder::InitGroupData()
{
    if (_group)
    {
        // 2. In case when player is in group, initialize variables necessary for group calculations:
        for (GroupReference* itr = _group->GetFirstMember(); itr != NULL; itr = itr->next())
            if (Player* member = itr->GetSource())
                if (member->IsAlive() && member->IsAtGroupRewardDistance(_victim))
                {
                    const uint8 lvl = member->getLevel();
                    // 2.1. _count - number of alive group members within reward distance;
                    ++_count;
                    // 2.2. _sumLevel - sum of levels of alive group members within reward distance;
                    _sumLevel += lvl;
                    // 2.3. _maxLevel - maximum level of alive group member within reward distance;
                    if (_maxLevel < lvl)
                        _maxLevel = lvl;
                    // 2.4. _maxNotGrayMember - maximum level of alive group member within reward distance,
                    //      for whom victim is not gray;
                    uint32 grayLevel = Trinity::XP::GetGrayLevel(lvl);
                    if (_victim->getLevel() > grayLevel && (!_maxNotGrayMember || _maxNotGrayMember->getLevel() < lvl))
                        _maxNotGrayMember = member;
                }
        // 2.5. _isFullXP - flag identifying that for all group members victim is not gray,
        //      so 100% XP will be rewarded (50% otherwise).
        _isFullXP = _maxNotGrayMember && (_maxLevel == _maxNotGrayMember->getLevel());
    }
    else
        _count = 1;
}

void KillRewarder::InitXP(Player* player)
{
    // Get initial value of XP for kill.
    // XP is given:
    // * on battlegrounds;
    // * otherwise, not in PvP;
    // * not if killer is on vehicle.
    if (_isBattleGround || (!_isPvP && !_killer->GetVehicle()))
        _xp = Trinity::XP::Gain(player, _victim);
}

void KillRewarder::RewardHonor(Player* player)
{
    // Rewarded player must be alive.
    if (player->IsAlive())
        player->RewardHonor(_victim, _count, -1, true);
}

void KillRewarder::RewardXP(Player* player, float rate)
{
    uint32 xp(_xp);
    if (_group)
    {
        // 4.2.1. If player is in group, adjust XP:
        //        * set to 0 if player's level is more than maximum level of not gray member;
        //        * cut XP in half if _isFullXP is false.
        if (_maxNotGrayMember && player->IsAlive() &&
            _maxNotGrayMember->getLevel() >= player->getLevel())
            xp = _isFullXP ?
                uint32(xp * rate) :             // Reward FULL XP if all group members are not gray.
                uint32(xp * rate / 2) + 1;      // Reward only HALF of XP if some of group members are gray.
        else
            xp = 0;

        int32 diff = _victim->getLevel() - player->getLevel();
        if (diff > int32(sWorld->getIntConfig(CONFIG_XP_KILL_LEVEL_DIFFERENCE)))
            xp = 0;
    }
    if (xp)
    {
        // 4.2.2. Apply auras modifying rewarded XP (SPELL_AURA_MOD_XP_PCT).
        Unit::AuraEffectList const& auras = player->GetAuraEffectsByType(SPELL_AURA_MOD_XP_PCT);
        for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
            AddPct(xp, (*i)->GetAmount());

        int32 diff = _victim->getLevel() - player->getLevel();
        xp *= diff > int32(sWorld->getIntConfig(CONFIG_XP_KILL_LEVEL_DIFFERENCE)) ? 0 : sWorld->getRate(RATE_XP_KILL, player);

        // 4.2.3. Calculate expansion penalty
        if (_victim->GetTypeId() == TYPEID_UNIT && player->getLevel() >= GetMaxLevelForExpansion(_victim->ToCreature()->GetCreatureTemplate()->expansion))
            xp = CalculatePct(xp, 10); // Players get only 10% xp for killing creatures of lower expansion levels than himself

        // 4.2.4. Give XP to player.
        player->GiveXP(xp, _victim, _groupRate);
    }
}

void KillRewarder::RewardReputation(Player* player, float rate)
{
    // 4.3. Give reputation (player must not be on BG).
    // Even dead players and corpses are rewarded.
    player->RewardReputation(_victim, rate);

    player->RewardReputationOnChampioning(_victim);
}

void KillRewarder::RewardKillCredit(Player* player)
{
    // 4.4. Give kill credit (player must not be in group, or he must be alive or without corpse).
    if (!_group || player->IsAlive() || !player->GetCorpse())
        if (Creature* target = _victim->ToCreature())
        {
            player->KilledMonster(target->GetCreatureTemplate(), target->GetGUID());
            player->CreditprojectDailyQuest(target->GetEntry());
            player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE, target->GetCreatureType(), 1, 0, target);

            if (Guild* guild = sGuildMgr->GetGuildById(player->GetGuildId()))
            {
                if (_rewardedGuilds.find(guild->GetGUID()) == _rewardedGuilds.end())
                {
                    _rewardedGuilds.insert(guild->GetGUID());
                    guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE_TYPE_GUILD, 1, 0, 0, target, player);
                    guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, target->GetEntry(), 1, 0, target, player);
                }
            }

            if (sWorld->AreprojectDailyQuestsEnabled())
            {
                if (uint32 type = target->GetCreatureType())
                    player->CreditprojectDailyQuest(180300 + type); // project Daily Quest Credit - *
                if (uint32 family = target->GetCreatureTemplate()->family)
                    player->CreditprojectDailyQuest(180400 + family); // project Daily Quest Credit - *
            }
        }
}

void KillRewarder::RewardPlayer(Player* player, bool isDungeon)
{
    // 4. Reward player.
    if (!_isBattleGround)
    {
        // 4.1. Give honor (player must be alive and not on BG).
        RewardHonor(player);
        // 4.1.1 Send player killcredit for quests with PlayerSlain
        if (_victim->GetTypeId() == TYPEID_PLAYER)
            player->KilledPlayerCredit();
    }
    // Give XP only in PvE or in battlegrounds.
    // Give reputation and kill credit only in PvE.
    if (!_isPvP || _isBattleGround)
    {
        const float rate = _group ?
            _groupRate * float(player->getLevel()) / _sumLevel : // Group rate depends on summary level.
            1.0f;                                                // Personal rate is 100%.
        if (_xp)
            // 4.2. Give XP.
            RewardXP(player, rate);
        if (!_isBattleGround)
        {
            // If killer is in dungeon then all members receive full reputation at kill.
            RewardReputation(player, isDungeon ? 1.0f : rate);
            RewardKillCredit(player);
        }
    }
}

void KillRewarder::RewardGroup()
{
    if (_maxLevel)
    {
        if (_maxNotGrayMember)
            // 3.1.1. Initialize initial XP amount based on maximum level of group member,
            //        for whom victim is not gray.
            InitXP(_maxNotGrayMember);
        // To avoid unnecessary calculations and calls,
        // proceed only if XP is not ZERO or player is not on battleground
        // (battleground rewards only XP, that's why).
        if (!_isBattleGround || _xp)
        {
            const bool isDungeon = !_isPvP && sMapStore.LookupEntry(_killer->GetMapId())->IsDungeon();
            if (!_isBattleGround)
            {
                // 3.1.2. Alter group rate if group is in raid (not for battlegrounds).
                const bool isRaid = !_isPvP && sMapStore.LookupEntry(_killer->GetMapId())->IsRaid() && _group->isRaidGroup();
                _groupRate = Trinity::XP::xp_in_group_rate(_count, isRaid);
            }

            // 3.1.3. Reward each group member (even dead or corpse) within reward distance.
            for (GroupReference* itr = _group->GetFirstMember(); itr != NULL; itr = itr->next())
            {
                if (Player* member = itr->GetSource())
                {
                    if (member->IsAtGroupRewardDistance(_victim))
                    {
                        RewardPlayer(member, isDungeon);
                        member->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, 0, _victim);
                    }
                }
            }
        }
    }
}

void KillRewarder::Reward()
{
    Creature* target = _victim->ToCreature();
    if (target && !target->HasNormalLootMode())
    {
        // Currently used only for Timeless Isle so don't give a shit about experience.
        for (auto&& guid : target->GetLootRecipients())
            if (Player*  player = ObjectAccessor::GetPlayer(*target, guid))
                if (player->IsAtGroupRewardDistance(target))
                    RewardPlayer(player, false);
    }
    // 3. Reward killer (and group, if necessary).
    else if (_group)
        // 3.1. If killer is in group, reward group.
        RewardGroup();
    else
    {
        // 3.2. Reward single killer (not group case).
        // 3.2.1. Initialize initial XP amount based on killer's level.
        InitXP(_killer);
        // To avoid unnecessary calculations and calls,
        // proceed only if XP is not ZERO or player is not on battleground
        // (battleground rewards only XP, that's why).
        if (!_isBattleGround || _xp)
            // 3.2.2. Reward killer.
            RewardPlayer(_killer, false);
    }

    // 5. Credit instance encounter.
    // 6. Update guild achievements.
    if (Creature* victim = _victim->ToCreature())
    {
        if (victim->IsDungeonBoss())
            if (InstanceScript* instance = _victim->GetInstanceScript())
                instance->UpdateEncounterState(ENCOUNTER_CREDIT_KILL_CREATURE, _victim->GetEntry(), _victim);
    }
}

// == Player ====================================================

// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
Player::Player(WorldSession* session) : Unit(true), phaseMgr(this), hasForcedMovement_(), m_sceneMgr(this), m_VignetteMgr(this)
{
#ifdef _MSC_VER
#pragma warning(default:4355)
#endif

    m_speakTime = 0;
    m_speakCount = 0;

    m_objectType |= TYPEMASK_PLAYER;
    m_objectTypeId = TYPEID_PLAYER;

    m_valuesCount = PLAYER_END;

    m_session = session;

    m_divider = 0;

    m_ExtraFlags = 0;

    m_spellModTakingSpell = NULL;
    //m_pad = 0;

    // players always accept
    if (GetSession()->GetSecurity() == SEC_PLAYER)
        SetAcceptWhispers(true);

    m_lootGuid = 0;

    m_comboTarget = 0;
    m_comboPoints = 0;

    m_regenTimer = 0;
    m_regenTimerCount = 0;
    m_weaponChangeTimer = 0;
    _readyCheckTimer = 0;

    m_zoneUpdateId = 0;
    m_zoneUpdateTimer = 0;

    m_areaUpdateId = 0;

    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    _resurrectionData = NULL;

    memset(m_items, 0, sizeof(Item*)*PLAYER_SLOTS_COUNT);

    m_social = NULL;

    // group is initialized in the reference constructor
    SetGroupInvite(NULL);
    m_groupUpdateMask = 0;
    m_auraRaidUpdateMask = 0;
    m_bPassOnGroupLoot = false;

    duel = NULL;

    m_GuildIdInvited = 0;
    m_ArenaTeamIdInvited = 0;

    m_atLoginFlags = AT_LOGIN_NONE;

    mSemaphoreTeleport_Near = false;
    mSemaphoreTeleport_Far = false;

    m_DelayedOperations = 0;
    m_bCanDelayTeleport = false;
    m_bHasDelayedTeleport = false;
    m_teleport_options = 0;

    m_forcedTeleportFar = false;

    m_trade = NULL;

    m_cinematic = 0;

    PlayerTalkClass = new PlayerMenu(GetSession());
    m_currentBuybackSlot = BUYBACK_SLOT_START;

    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    for (uint8 i=0; i < MAX_TIMERS; i++)
        m_MirrorTimer[i] = DISABLED_MIRROR_TIMER;

    m_MirrorTimerFlags = UNDERWATER_NONE;
    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
    m_isInWater = false;
    m_drunkTimer = 0;
    m_restTime = 0;
    m_deathTimer = 0;
    m_deathExpireTime = 0;

    m_swingErrorMsg = 0;

    for (uint8 j = 0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; ++j)
    {
        m_bgBattlegroundQueueID[j].bgQueueTypeId = BATTLEGROUND_QUEUE_NONE;
        m_bgBattlegroundQueueID[j].invitedToInstance = 0;
    }

    // PlayedTimeReward
    ptr_Interval = sWorld->getIntConfig(CONFIG_PLAYED_TIME_REWARD) * 1000;

    m_logintime = time(NULL);
    m_Last_tick = m_logintime;
    m_WeaponProficiency = 0;
    m_ArmorProficiency = 0;
    m_canParry = false;
    m_canBlock = false;
    m_canDualWield = false;
    m_canTitanGrip = false;

    m_temporaryUnsummonedPetNumber = 0;

    m_lastpetnumber = 0;

    ////////////////////Rest System/////////////////////
    time_inn_enter=0;
    inn_pos_mapid=0;
    inn_pos_x=0;
    inn_pos_y=0;
    inn_pos_z=0;
    m_rest_bonus=0;
    rest_type=REST_TYPE_NO;
    ////////////////////Rest System/////////////////////

    m_mailsLoaded = false;
    m_mailsUpdated = false;
    unReadMails = 0;
    m_nextMailDelivereTime = 0;

    m_itemUpdateQueueBlocked = false;

    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
        m_forced_speed_changes[i] = 0;

    m_stableSlots = 0;

    /////////////////// Instance System /////////////////////

    m_HomebindTimer = 0;
    m_InstanceValid = true;
    m_dungeonDifficulty = DUNGEON_DIFFICULTY_NORMAL;
    m_raidDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;
    m_raidMapDifficulty = RAID_DIFFICULTY_10MAN_NORMAL;

    m_lastPotionId = 0;
    _talentMgr = new PlayerTalentInfo();

    for (uint8 i = 0; i < CR_MAX_COMBAT_RATING; i++)
        m_baseRatingValue[i] = 0;

    m_baseSpellPower = 0;
    m_baseManaRegen = 0;
    m_baseHealthRegen = 0;
    m_spellPenetrationItemMod = 0;

    // Honor System
    m_lastHonorUpdateTime = time(NULL);

    m_IsBGRandomWinner = false;
    m_IsBGWeekendWinner = false;

    // Player summoning
    m_summon_expire = 0;
    m_summon_mapid = 0;
    m_summon_x = 0.0f;
    m_summon_y = 0.0f;
    m_summon_z = 0.0f;

    m_mover = this;
    m_movedPlayer = this;
    m_seer = this;

    m_contestedPvPTimer = 0;

    m_declinedname = NULL;

    m_isActive = true;

    m_runes = NULL;

    m_lastFallTime = 0;
    m_lastFallZ = 0;

    m_grantableLevels = 0;

    m_ControlledByPlayer = true;

    sWorld->IncreasePlayerCount();

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        m_powerFraction[i] = 0;

    isDebugAreaTriggers = false;

    _completedQuestBits.resize(QUESTS_COMPLETED_BITS_SIZE * 8);

    m_WeeklyQuestChanged = false;

    m_MonthlyQuestChanged = false;

    m_SeasonalQuestChanged = false;

    SetPendingBind(0, 0);

    _activeCheats = CHEAT_NONE;
    _maxPersonalArenaRate = 0;

    memset(_voidStorageItems, 0, VOID_STORAGE_MAX_SLOT * sizeof(VoidStorageItem*));
    memset(_CUFProfiles, 0, MAX_CUF_PROFILES * sizeof(CUFProfile*));

    for (uint8 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        for (uint8 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
            _researchDigsites[i][j] = NULL;

    m_lootLockouts.reset(new LootLockoutMap(this));
    m_achievementMgr.reset(new PlayerAchievementMgr(this));
    m_reputationMgr = new ReputationMgr(this);
    m_battlePetMgr = new BattlePetMgr(this);

    transcendence_spirit = NULL;

    m_dynamicValuesCount = PLAYER_DYNAMIC_END;
}

Player::~Player()
{
    // it must be unloaded already in PlayerLogout and accessed only for loggined player
    //m_social = NULL;

    // Note: buy back item already deleted from DB when player was saved
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        delete m_items[i];

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
        delete itr->second;

    delete _talentMgr;

    //all mailed items should be deleted, also all mail should be deallocated
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        delete *itr;

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated

    delete PlayerTalkClass;

    for (size_t x = 0; x < ItemSetEff.size(); x++)
        delete ItemSetEff[x];

    delete m_declinedname;
    delete m_runes;
    delete m_reputationMgr;
    delete m_battlePetMgr;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        delete _voidStorageItems[i];

    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
        delete _CUFProfiles[i];

    for (uint8 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        for (uint8 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
            delete _researchDigsites[i][j];

    ClearResurrectRequestData();

    sWorld->DecreasePlayerCount();
}

void Player::CleanupsBeforeDelete(bool finalCleanup)
{
    TradeCancel(false);
    DuelComplete(DUEL_INTERRUPTED);

    Unit::CleanupsBeforeDelete(finalCleanup);

    // clean up player-instance binds, may unload some instance saves
    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
            itr->second.save->RemovePlayer(this);
}

bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
{
    //FIXME: outfitId not used in player creating
    /// @todo need more checks against packet modifications
    // should check that skin, face, hair* are valid via DBC per race/class
    // also do it in Player::BuildEnumData, Player::LoadFromDB

    Object::_Create(guidlow, 0, HIGHGUID_PLAYER);

    m_session->SetPlayer(this);

    m_name = createInfo->Name;

    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
    if (!info)
    {
        TC_LOG_ERROR("entities.player", "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
        return false;
    }

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        m_items[i] = NULL;

    Relocate(info->positionX, info->positionY, info->positionZ, info->orientation);

    ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
    if (!cEntry)
    {
        TC_LOG_ERROR("entities.player", "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DBC-files?)",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
        return false;
    }

    SetMap(sMapMgr->CreateMap(info->mapId, this));

    uint8 powerType = cEntry->powerType;

    SetObjectScale(1.0f);

    setFactionForRace(createInfo->Race);

    if (!IsValidGender(createInfo->Gender))
    {
        TC_LOG_ERROR("entities.player", "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%u) - refusing to do so",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Gender);
        return false;
    }

    SetRace(createInfo->Race);
    SetClass(createInfo->Class);
    SetGender(createInfo->Gender);
    SetFieldPowerType(powerType);

    InitDisplayIds();

    if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_PVP);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    }

    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);            // default for players in 3.0.3

    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, uint32(-1));  // -1 is default value

    SetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID, (createInfo->Skin | (createInfo->Face << 8) | (createInfo->HairStyle << 16) | (createInfo->HairColor << 24)));
    SetUInt32Value(PLAYER_FIELD_REST_STATE, (createInfo->FacialHair |
                                   (0x00 << 8) |
                                   (0x00 << 16) |
                                   (((GetSession()->IsARecruiter() || GetSession()->GetRecruiterId() != 0) ? REST_STATE_RAF_LINKED : REST_STATE_NOT_RAF_LINKED) << 24)));
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 0, createInfo->Gender);
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 3, 0);                     // BattlefieldArenaFaction (0 or 1)

    SetUInt64Value(OBJECT_FIELD_DATA, 0);
    SetUInt32Value(PLAYER_FIELD_GUILD_RANK_ID, 0);
    SetGuildLevel(0);
    SetUInt32Value(PLAYER_FIELD_GUILD_DELETE_DATE, 0);
    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, realmID);

    for (int i = 0; i < KNOWN_TITLES_SIZE; ++i)
        SetUInt64Value(PLAYER_FIELD_KNOWN_TITLES + i, 0);  // 0=disabled
    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);

    SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);

    // set starting level
    uint32 start_level = getClass() != CLASS_DEATH_KNIGHT
        ? sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL)
        : sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL);

    if (GetSession()->GetSecurity() > SEC_MODERATOR)
    {
        uint32 gm_level = sWorld->getIntConfig(CONFIG_START_GM_LEVEL);
        if (gm_level > start_level)
            start_level = gm_level;
    }

    SetUInt32Value(UNIT_FIELD_LEVEL, start_level);

    InitRunes();

    SetUInt32Value(PLAYER_FIELD_COINAGE, sWorld->getIntConfig(CONFIG_START_PLAYER_MONEY));
    SetCurrency(CURRENCY_TYPE_HONOR_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_HONOR_POINTS));
    SetCurrency(CURRENCY_TYPE_JUSTICE_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_JUSTICE_POINTS));
    SetCurrency(CURRENCY_TYPE_CONQUEST_POINTS, sWorld->getIntConfig(CONFIG_CURRENCY_START_CONQUEST_POINTS));

    // start with every map explored
    if (sWorld->getBoolConfig(CONFIG_START_ALL_EXPLORED))
    {
        for (uint8 i=0; i<PLAYER_EXPLORED_ZONES_SIZE; i++)
            SetFlag(PLAYER_FIELD_EXPLORED_ZONES+i, 0xFFFFFFFF);
    }

    //Reputations if "StartAllReputation" is enabled, -- @todo Fix this in a better way
    if (sWorld->getBoolConfig(CONFIG_START_ALL_REP))
    {
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(942), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(935), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(936), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1011), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(970), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(967), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(989), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(932), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(934), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1038), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1077), 42999);

        // Factions depending on team, like cities and some more stuff
        switch (GetTeam())
        {
        case ALLIANCE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(72), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(47), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(69), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(930), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(730), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(978), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(54), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(946), 42999);
            break;
        case HORDE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(76), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(68), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(81), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(911), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(729), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(941), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(530), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(947), 42999);
            break;
        default:
            break;
        }
    }

    // Played time
    m_Last_tick = time(NULL);
    m_Played_time[PLAYED_TIME_TOTAL] = 0;
    m_Played_time[PLAYED_TIME_LEVEL] = 0;

    // base stats and related field values
    InitStatsForLevel();
    InitTaxiNodesForLevel();
    InitGlyphsForLevel();
    InitTalentForLevel();
    InitPrimaryProfessions();                               // to max set before any spell added

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)
    SetFullHealth();
    if (GetPowerType() == POWER_MANA)
    {
        UpdateMaxPower(POWER_MANA);                         // Update max Mana (for add bonus from intellect)
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    }

    if (GetPowerType() == POWER_RUNIC_POWER)
    {
        SetPower(POWER_RUNES, 8);
        SetMaxPower(POWER_RUNES, 8);
        SetPower(POWER_RUNIC_POWER, 0);
        SetMaxPower(POWER_RUNIC_POWER, 1000);
    }

    // original spells
    LearnDefaultSkills();

    if (getClass() == CLASS_MONK)
        CastSpell(this, 103985, true); // Stance of the Fierce Tiger

    //if (!HasSpell(28698)) // premium menu
    //    LearnSpell(28698, false);

    // original action bar
    for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
        addActionButton(action_itr->button, action_itr->action, action_itr->type);

    // original items
    if (CharStartOutfitEntry const* oEntry = GetCharStartOutfitEntry(createInfo->Race, createInfo->Class, createInfo->Gender))
    {
        for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
        {
            if (oEntry->ItemId[j] <= 0)
                continue;

            uint32 itemId = oEntry->ItemId[j];

            // just skip, reported in ObjectMgr::LoadItemTemplates
            ItemTemplate const* iProto = sObjectMgr->GetItemTemplate(itemId);
            if (!iProto)
                continue;

            // BuyCount by default
            uint32 count = iProto->BuyCount;

            // special amount for food/drink
            if (iProto->Class == ITEM_CLASS_CONSUMABLE && iProto->SubClass == ITEM_SUBCLASS_FOOD_DRINK)
            {
                switch (iProto->Spells[0].SpellCategory)
                {
                    case SPELL_CATEGORY_FOOD:                                // food
                        count = getClass() == CLASS_DEATH_KNIGHT ? 10 : 4;
                        break;
                    case SPELL_CATEGORY_DRINK:                                // drink
                        count = 2;
                        break;
                }
                if (iProto->GetMaxStackSize() < count)
                    count = iProto->GetMaxStackSize();
            }
            StoreNewItemInBestSlots(itemId, count);
        }
    }

    for (PlayerCreateInfoItems::const_iterator item_id_itr = info->item.begin(); item_id_itr != info->item.end(); ++item_id_itr)
        StoreNewItemInBestSlots(item_id_itr->item_id, item_id_itr->item_amount);

    // bags and main-hand weapon must equipped at this moment
    // now second pass for not equipped (offhand weapon/shield if it attempt equipped before main-hand weapon)
    // or ammo not equipped in special bag
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            uint16 eDest;
            // equip offhand weapon/shield if it attempt equipped before main-hand weapon
            InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false);
            if (msg == EQUIP_ERR_OK)
            {
                RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                EquipItem(eDest, pItem, true);
            }
            // move other items to more appropriate slots
            else
            {
                ItemPosCountVec sDest;
                msg = CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                    pItem = StoreItem(sDest, pItem, true);
                }
            }
        }
    }
    // all item positions resolved

    return true;
}

bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount)
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: Creating initial item, itemId = %u, count = %u", titem_id, titem_amount);

    // attempt equip by one
    while (titem_amount > 0)
    {
        uint16 eDest;
        InventoryResult msg = CanEquipNewItem(NULL_SLOT, eDest, titem_id, false);
        if (msg != EQUIP_ERR_OK)
            break;

        EquipNewItem(eDest, titem_id, true);
        AutoUnequipOffhandIfNeed();
        --titem_amount;
    }

    if (titem_amount == 0)
        return true;                                        // equipped

    // attempt store
    ItemPosCountVec sDest;
    // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
    InventoryResult msg = CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, titem_id, titem_amount);
    if (msg == EQUIP_ERR_OK)
    {
        StoreNewItem(sDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id));
        return true;                                        // stored
    }

    // item can't be added
    TC_LOG_ERROR("entities.player.items", "STORAGE: Can't equip or store initial item %u for race %u class %u, error msg = %u", titem_id, getRace(), getClass(), msg);
    return false;
}

void Player::SendMirrorTimer(MirrorTimerType Type, uint32 MaxValue, uint32 CurrentValue, int32 Regen)
{
    if (int(MaxValue) == DISABLED_MIRROR_TIMER)
    {
        if (int(CurrentValue) != DISABLED_MIRROR_TIMER)
            StopMirrorTimer(Type);
        return;
    }
    WorldPacket data(SMSG_START_MIRROR_TIMER, 21);
    data << MaxValue;
    data << (uint32)0; // spell id
    data << (uint32)Type;
    data << Regen;
    data << CurrentValue;
    data.WriteBit(0); // Paused
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::StopMirrorTimer(MirrorTimerType Type)
{
    m_MirrorTimer[Type] = DISABLED_MIRROR_TIMER;
    WorldPacket data(SMSG_STOP_MIRROR_TIMER, 4);
    data << (uint32)Type;
    GetSession()->SendPacket(&data);
}

bool Player::IsImmuneToEnvironmentalDamage()
{
    // check for GM and death state included in isAttackableByAOE
    return (!isTargetableForAttack(false));
}

uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
{
    if (IsImmuneToEnvironmentalDamage())
        return 0;

    // Absorb, resist some environmental damage type
    uint32 absorb = 0;
    uint32 resist = 0;
    if (type == DAMAGE_LAVA)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_FIRE, DIRECT_DAMAGE, damage, &absorb, &resist);
    else if (type == DAMAGE_SLIME)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE, damage, &absorb, &resist);

    damage -= absorb + resist;

    DealDamageMods(this, damage, &absorb);

    ObjectGuid Guid = GetGUID();

    WorldPacket data(SMSG_ENVIRONMENTALDAMAGELOG, 9 + 1 + 4 + 1 + 4 + 4);
    data.WriteBit(Guid[5]);
    data.WriteBit(Guid[7]);
    data.WriteBit(Guid[1]);
    data.WriteBit(Guid[4]);
    data.WriteBit(Guid[2]);
    data.WriteBit(Guid[0]);
    data.WriteBit(0); // Power Data
    data.WriteBit(Guid[6]);
    data.WriteBit(Guid[3]);

    data << uint32(absorb);
    data.WriteByteSeq(Guid[0]);
    data.WriteByteSeq(Guid[7]);
    data << uint8(type != DAMAGE_FALL_TO_VOID ? type : DAMAGE_FALL);
    data.WriteByteSeq(Guid[6]);
    data.WriteByteSeq(Guid[3]);
    data.WriteByteSeq(Guid[5]);
    data << uint32(resist);
    data.WriteByteSeq(Guid[1]);
    data.WriteByteSeq(Guid[2]);
    data.WriteByteSeq(Guid[4]);
    data << uint32(damage);
    SendMessageToSet(&data, true);

    uint32 final_damage = DealDamage(this, damage, NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);

    if (!IsAlive())
    {
        if (type == DAMAGE_FALL)                               // DealDamage not apply item durability loss at self damage
        {
            TC_LOG_DEBUG("entities.player", "We are fall to death, loosing 10 percents durability");
            DurabilityLossAll(0.10f, false);
            // durability lost message
            SendDurabilityLoss(this, 10);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATHS_FROM, 1, type);
    }

    return final_damage;
}

int32 Player::getMaxTimer(MirrorTimerType timer)
{
    switch (timer)
    {
        case FATIGUE_TIMER:
            return MINUTE * IN_MILLISECONDS;
        case BREATH_TIMER:
        {
            if (!IsAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
                return DISABLED_MIRROR_TIMER;
            int32 UnderWaterTime = 3 * MINUTE * IN_MILLISECONDS;
            AuraEffectList const& mModWaterBreathing = GetAuraEffectsByType(SPELL_AURA_MOD_WATER_BREATHING);
            for (AuraEffectList::const_iterator i = mModWaterBreathing.begin(); i != mModWaterBreathing.end(); ++i)
                AddPct(UnderWaterTime, (*i)->GetAmount());
            return UnderWaterTime;
        }
        case FIRE_TIMER:
        {
            if (!IsAlive())
                return DISABLED_MIRROR_TIMER;
            return 1 * IN_MILLISECONDS;
        }
        default:
            return 0;
    }
}

void Player::UpdateMirrorTimers()
{
    // Desync flags for update on next HandleDrowning
    if (m_MirrorTimerFlags)
        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
}

void Player::StopMirrorTimers()
{
    StopMirrorTimer(FATIGUE_TIMER);
    StopMirrorTimer(BREATH_TIMER);
    StopMirrorTimer(FIRE_TIMER);
}

bool Player::IsMirrorTimerActive(MirrorTimerType type)
{
    return m_MirrorTimer[type] == getMaxTimer(type);
}

void Player::HandleDrowning(uint32 time_diff)
{
    if (!m_MirrorTimerFlags)
        return;

    // In water
    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
    {
        // Vash'jir zones
        if (m_zoneUpdateId == 4815) return;
        if (m_zoneUpdateId == 4816) return;
        if (m_zoneUpdateId == 5144) return;
        if (m_zoneUpdateId == 5145) return;
        if (m_zoneUpdateId == 5146) return;

        // Breath timer not activated - activate it
        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1);
        }
        else                                                              // If activated - do tick
        {
            m_MirrorTimer[BREATH_TIMER]-=time_diff;
            // Timer limit - need deal damage
            if (m_MirrorTimer[BREATH_TIMER] < 0)
            {
                m_MirrorTimer[BREATH_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                /// @todo Check this formula
                uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
                EnvironmentalDamage(DAMAGE_DROWNING, damage);
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))      // Update time in client if need
                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)        // Regen timer
    {
        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);
        // Need breath regen
        m_MirrorTimer[BREATH_TIMER]+=10*time_diff;
        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !IsAlive())
            StopMirrorTimer(BREATH_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10);
    }

    // In dark water
    if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
    {
        // Vash'jir zones
        if (m_zoneUpdateId == 4815) return;
        if (m_zoneUpdateId == 4816) return;
        if (m_zoneUpdateId == 5144) return;
        if (m_zoneUpdateId == 5145) return;
        if (m_zoneUpdateId == 5146) return;

        // Fatigue timer not activated - activate it
        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1);
        }
        else
        {
            m_MirrorTimer[FATIGUE_TIMER]-=time_diff;
            // Timer limit - need deal damage or teleport ghost to graveyard
            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
            {
                m_MirrorTimer[FATIGUE_TIMER]+= 1*IN_MILLISECONDS;
                if (IsAlive())                                            // Calculate and deal damage
                {
                    uint32 damage = GetMaxHealth() / 5 + urand(0, getLevel()-1);
                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
                }
                else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))       // Teleport ghost to graveyard
                    RepopAtGraveyard();
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER))
                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)       // Regen timer
    {
        int32 DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
        m_MirrorTimer[FATIGUE_TIMER]+=10*time_diff;
        if (m_MirrorTimer[FATIGUE_TIMER] >= DarkWaterTime || !IsAlive())
            StopMirrorTimer(FATIGUE_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
            SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
    }

    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
    {
        // Breath timer not activated - activate it
        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
        else
        {
            m_MirrorTimer[FIRE_TIMER] -= time_diff;
            if (m_MirrorTimer[FIRE_TIMER] < 0)
            {
                m_MirrorTimer[FIRE_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                /// @todo Check this formula
                uint32 damage = urand(600, 700);
                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
                    EnvironmentalDamage(DAMAGE_LAVA, damage);
                // need to skip Slime damage in Undercity,
                // maybe someone can find better way to handle environmental damage
                //else if (m_zoneUpdateId != 1497)
                //    EnvironmentalDamage(DAMAGE_SLIME, damage);
            }
        }
    }
    else
        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;

    // Recheck timers flag
    m_MirrorTimerFlags&=~UNDERWATER_EXIST_TIMERS;
    for (uint8 i = 0; i< MAX_TIMERS; ++i)
        if (m_MirrorTimer[i] != DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimerFlags|=UNDERWATER_EXIST_TIMERS;
            break;
        }
    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
}

///The player sobers by 1% every 9 seconds
void Player::HandleSobering()
{
    m_drunkTimer = 0;

    uint8 currentDrunkValue = GetDrunkValue();
    uint8 drunk = currentDrunkValue ? --currentDrunkValue : 0;
    SetDrunkValue(drunk);
}

DrunkenState Player::GetDrunkenstateByValue(uint8 value)
{
    if (value >= 90)
        return DRUNKEN_SMASHED;
    if (value >= 50)
        return DRUNKEN_DRUNK;
    if (value)
        return DRUNKEN_TIPSY;
    return DRUNKEN_SOBER;
}

void Player::SetDrunkValue(uint8 newDrunkValue, uint32 itemId /*= 0*/)
{
    bool isSobering = newDrunkValue < GetDrunkValue();
    uint32 oldDrunkenState = Player::GetDrunkenstateByValue(GetDrunkValue());
    if (newDrunkValue > 100)
        newDrunkValue = 100;

    // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
    int32 drunkPercent = std::max<int32>(newDrunkValue, GetTotalAuraModifier(SPELL_AURA_MOD_FAKE_INEBRIATE));
    if (drunkPercent)
    {
        m_invisibilityDetect.AddFlag(INVISIBILITY_DRUNK);
        m_invisibilityDetect.SetValue(INVISIBILITY_DRUNK, drunkPercent);
    }
    else if (!HasAuraType(SPELL_AURA_MOD_FAKE_INEBRIATE) && !newDrunkValue)
        m_invisibilityDetect.DelFlag(INVISIBILITY_DRUNK);

    uint32 newDrunkenState = Player::GetDrunkenstateByValue(newDrunkValue);
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 1, newDrunkValue);
    UpdateObjectVisibility();

    if (!isSobering)
        m_drunkTimer = 0;   // reset sobering timer

    if (newDrunkenState == oldDrunkenState)
        return;

    ObjectGuid guid = GetGUID();
    WorldPacket data(SMSG_CROSSED_INEBRIATION_THRESHOLD, (8+4+4));
    data.WriteGuidMask(guid, 0, 4, 2, 6, 5, 1, 3, 7);
    data.WriteGuidBytes(guid, 3);
    data << uint32(itemId);
    data << uint32(newDrunkenState);
    data.WriteGuidBytes(guid, 4, 6, 7, 0, 2, 5, 1);
    SendMessageToSet(&data, true);
}

void Player::Update(uint32 p_time)
{
    if (!IsInWorld())
        return;

    uint64 victimGuid = GetVictim() ? GetVictim()->GetGUID() : 0;
    m_assistTimer += p_time;
    for (auto it = m_lastTargets.begin(); it != m_lastTargets.end();)
    {
        it->second.Timer += p_time;
        if (it->second.Timer >= 3500)
            m_lastTargets.erase(it++);
        else if (m_assistTimer >= 2000)
        {
            uint32 i = it->first != victimGuid ? 2 : 1;
            if (it->second.Priority <= i)
                m_lastTargets.erase(it++);
            else
            {
                it->second.Priority -= i;
                ++it;
            }
        }
        else
            ++it;
    }
    if (m_assistTimer >= 2000)
        m_assistTimer -= 2000;

    GetSpellHistory()->UpdateCharges();

    // undelivered mail
    if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
    {
        SendNewMail();
        ++unReadMails;

        // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
        m_nextMailDelivereTime = 0;
    }

    // If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
    // Having this would prevent more aura charges to be dropped, so let's crash
    //ASSERT (!m_spellModTakingSpell);
    if (m_spellModTakingSpell)
    {
        //TC_LOG_FATAL("entities.player", "Player has m_pad %u during update!", m_pad);
        //if (m_spellModTakingSpell)
        TC_LOG_FATAL("spells", "Player has m_spellModTakingSpell %u during update!", m_spellModTakingSpell->m_spellInfo->Id);
        m_spellModTakingSpell = NULL;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED | UNIT_FLAG_PACIFIED | UNIT_FLAG_STUNNED | UNIT_FLAG_CONFUSED | UNIT_FLAG_FLEEING) || IsCharmed() || isPossessed() || HasAuraType(SPELL_AURA_MOD_ROOT))
        if (Battleground* bg = GetBattleground())
            bg->UpdatePlayerScore(this, SCORE_TIME_CONTROLLED, p_time);

    //used to implement delayed far teleports
    SetCanDelayTeleport(true);
    Unit::Update(p_time);
    SetCanDelayTeleport(false);

    time_t now = time(NULL);

    UpdatePvPFlag(now);

    UpdateContestedPvP(p_time);

    UpdateDuelFlag(now);

    CheckDuelDistance(now);

    UpdateAfkReport(now);

    if (IsAIEnabled && GetAI())
        GetAI()->UpdateAI(p_time);
    else if (NeedChangeAI)
    {
        UpdateCharmAI();
        NeedChangeAI = false;
        IsAIEnabled = (GetAI() != nullptr);
    }

    // Update items that have just a limited lifetime
    if (now > m_Last_tick)
        UpdateItemDuration(uint32(now - m_Last_tick));

    // Update soulbound items that can be traded with other players for 2 hours after acquisition
    if (now > m_lastSoulboundTradeItemsUpdateTime + MINUTE)
    {
        m_lastSoulboundTradeItemsUpdateTime = now;
        UpdateSoulboundTradeItems();
    }

    if (!m_timedquests.empty())
    {
        QuestSet::iterator iter = m_timedquests.begin();
        while (iter != m_timedquests.end())
        {
            QuestStatusData& q_status = m_QuestStatus[*iter];
            if (q_status.Timer <= p_time)
            {
                uint32 quest_id  = *iter;
                ++iter;                                     // current iter will be removed in FailQuest
                FailQuest(quest_id);
            }
            else
            {
                q_status.Timer -= p_time;
                m_QuestStatusSave[*iter] = true;
                ++iter;
            }
        }
    }

    m_achievementMgr->UpdateTimedCriteria(p_time);

    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
    {
        if (Unit* victim = GetVictim())
        {
            // default combat reach 10
            /// @todo add weapon, skill check

            if (isAttackReady(BASE_ATTACK))
            {
                if (!(m_autoattackOverrideRange ? IsWithinRangedMeleeRange(victim, m_autoattackOverrideRange) : IsWithinMeleeRange(victim)))
                {
                    setAttackTimer(BASE_ATTACK, 100);
                    if (m_swingErrorMsg != 1)               // send single time (client auto repeat)
                    {
                        SendAttackSwingResult(ATTACKSWING_NOT_IN_RANGE);
                        m_swingErrorMsg = 1;
                    }
                }
                // 120 degrees of radiant range
                else if (!HasInArc(2*M_PI/3, victim))
                {
                    setAttackTimer(BASE_ATTACK, 100);
                    if (m_swingErrorMsg != 2)               // send single time (client auto repeat)
                    {
                        SendAttackSwingResult(ATTACKSWING_BAD_FACING);
                        m_swingErrorMsg = 2;
                    }
                }
                else
                {
                    m_swingErrorMsg = 0;                    // reset swing error state

                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (HasOffhandWeapon())
                        if (getAttackTimer(OFF_ATTACK) < ATTACK_DISPLAY_DELAY)
                            setAttackTimer(OFF_ATTACK, ATTACK_DISPLAY_DELAY);

                    // do attack
                    AttackerStateUpdate(victim, BASE_ATTACK);
                    resetAttackTimer(BASE_ATTACK);
                }
            }

            if (HasOffhandWeapon() && isAttackReady(OFF_ATTACK))
            {
                if (!(m_autoattackOverrideRange ? IsWithinRangedMeleeRange(victim, m_autoattackOverrideRange) : IsWithinMeleeRange(victim)))
                    setAttackTimer(OFF_ATTACK, 100);
                else if (!HasInArc(2*M_PI/3, victim))
                    setAttackTimer(OFF_ATTACK, 100);
                else
                {
                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (getAttackTimer(BASE_ATTACK) < ATTACK_DISPLAY_DELAY)
                        setAttackTimer(BASE_ATTACK, ATTACK_DISPLAY_DELAY);

                    // do attack
                    AttackerStateUpdate(victim, OFF_ATTACK);
                    resetAttackTimer(OFF_ATTACK);
                }
            }
        }
    }

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
    {
        if (roll_chance_i(3) && GetTimeInnEnter() > 0)      // freeze update
        {
            time_t time_inn = time(NULL)-GetTimeInnEnter();
            if (time_inn >= 10)                             // freeze update
            {
                float bubble = 0.125f*sWorld->getRate(RATE_REST_INGAME);
                                                            // speed collect rest bonus (section/in hour)
                SetRestBonus(GetRestBonus()+ time_inn*((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)/72000)*bubble);
                UpdateInnerTime(time(NULL));
            }
        }
    }

    // teleport out if darmoon faire event is not active
    if (GetMapId() == 974 && !sGameEventMgr->IsActiveEvent(75) && GetSession()->GetSecurity() < SEC_GAMEMASTER)
        TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());

    // teleport out if player is not eligible for isle of thunder
    if (GetZoneId() == 6507 && GetQuestStatus(32680) == QUEST_STATUS_NONE && GetQuestStatus(32681) == QUEST_STATUS_NONE && GetSession()->GetSecurity() < SEC_GAMEMASTER)
    {
        if (GetTeam() == HORDE)
            TeleportTo(870, 1678.752f, 931.605f, 471.426f, 3.295924f);
        else
            TeleportTo(870, 821.5245f, 253.303f, 503.919f, 0.631852f);
    }

    // teleport out if player is not eligible for ordos
    Position pos = GetPosition();
    bool isInSanctuarySquare = pos.GetPositionZ() > 120.0f && pos.GetPositionZ() < 165.0f && pos.GetPositionX() < -140.0f && pos.GetPositionX() > -326.0f && pos.GetPositionY() < -5264.0f && pos.GetPositionY() > -5461.0f;
    bool isInOrdosSquare     = pos.GetPositionZ() > 120.0f && pos.GetPositionZ() < 165.0f && pos.GetPositionX() < -25.0f  && pos.GetPositionX() > -99.0f  && pos.GetPositionY() < -5351.0f && pos.GetPositionY() > -5449.0f;
    bool isInCheckLocation   = GetAreaId() == 6823 && (isInSanctuarySquare || isInOrdosSquare);
    bool hasLegendaryCloack  = HasItemCount(102245) || HasItemCount(102246) || HasItemCount(102247) || HasItemCount(102248) || HasItemCount(102249) || HasItemCount(102250);
    if (isInCheckLocation && !HasAchieved(7536) && !hasLegendaryCloack && GetSession()->GetSecurity() < SEC_GAMEMASTER)
    {
        TeleportTo(870, -649.822f, -4891.033f, 2.05669f, 4.721636f);
        m_Events.KillEventsByGroup(1); // stupid solution =/
        m_Events.Schedule(1000, 1, [this]()
        {
            SendPersonalMessage(LANG_ORDOS_SANCTUARY_RESTRICTED, CHAT_MSG_RAID_BOSS_WHISPER, LANG_UNIVERSAL);
        });
    }

    if (m_weaponChangeTimer > 0)
    {
        if (p_time >= m_weaponChangeTimer)
            m_weaponChangeTimer = 0;
        else
            m_weaponChangeTimer -= p_time;
    }

    if (m_zoneUpdateTimer > 0)
    {
        if (p_time >= m_zoneUpdateTimer)
        {
            uint32 newzone, newarea;
            GetZoneAndAreaId(newzone, newarea);

            if (m_zoneUpdateId != newzone)
                UpdateZone(newzone, newarea);                // also update area
            else
            {
                // use area updates as well
                // needed for free far all arenas for example
                if (m_areaUpdateId != newarea)
                    UpdateArea(newarea);

                m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
            }
        }
        else
            m_zoneUpdateTimer -= p_time;
    }
	
	    if (m_timeSyncTimer > 0)
    {
        if (p_time >= m_timeSyncTimer)
            SendTimeSync();
        else
            m_timeSyncTimer -= p_time;
    }


    if (IsAlive() || m_runes)
    {
        m_regenTimer += p_time;
        RegenerateAll();
    }

    if (m_deathState == JUST_DIED)
        KillPlayer();

    // Update online mute timer
    if (m_session->GetMute().Timer)
    {
        if (p_time >= m_session->GetMute().Timer)
        {
            m_session->GetMute().Timer = 0;
            LoginDatabase.PExecute("DELETE FROM mute_active WHERE realmid = '%u' AND account = '%u'", realmID, m_session->GetAccountId());
        }
        else
            m_session->GetMute().Timer -= p_time;
    }

    if (m_nextSave > 0)
    {
        if (p_time >= m_nextSave)
        {
            // m_nextSave reset in SaveToDB call
            sScriptMgr->OnPlayerSave(this);
            SaveToDB();
            //TC_LOG_DEBUG("entities.player", "Player '%s' (GUID: %u) saved", GetName().c_str(), GetGUIDLow());
        }
        else
            m_nextSave -= p_time;
    }

    //Handle Water/drowning
    HandleDrowning(p_time);

    // Played time
    if (now > m_Last_tick)
    {
        uint32 elapsed = uint32(now - m_Last_tick);
        m_Played_time[PLAYED_TIME_TOTAL] += elapsed;        // Total played time
        m_Played_time[PLAYED_TIME_LEVEL] += elapsed;        // Level played time
        m_Last_tick = now;
    }

    if (GetDrunkValue())
    {
        m_drunkTimer += p_time;
        if (m_drunkTimer > 9 * IN_MILLISECONDS)
            HandleSobering();
    }

    if (HasPendingBind())
    {
        if (_pendingBindTimer <= p_time)
        {
            // Player left the instance
            if (_pendingBindId == GetInstanceId())
                BindToInstance();
            SetPendingBind(0, 0);
        }
        else
            _pendingBindTimer -= p_time;
    }

    // not auto-free ghost from body in instances
    if (m_deathTimer > 0 && !GetBaseMap()->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
    {
        if (p_time >= m_deathTimer)
        {
            m_deathTimer = 0;
            BuildPlayerRepop();
            RepopAtGraveyard();
        }
        else
            m_deathTimer -= p_time;
    }

    UpdateEnchantTime(p_time);
    UpdateHomebindTime(p_time);

    if (!_instanceResetTimes.empty())
    {
        for (InstanceTimeMap::iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end();)
        {
            if (itr->second < now)
                _instanceResetTimes.erase(itr++);
            else
                ++itr;
        }
    }

    // group update
    SendUpdateToOutOfRangeGroupMembers();

    if (_readyCheckTimer > 0)
    {
        if (p_time >= _readyCheckTimer)
            ReadyCheckComplete();
        else
            _readyCheckTimer -= p_time;
    }

    Pet* pet = GetPet();
    if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange()) && !pet->isPossessed())
    //if (pet && !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityDistance()) && (GetCharmGUID() && (pet->GetGUID() != GetCharmGUID())))
        RemovePet(PET_REMOVE_DISMISS, PET_REMOVE_FLAG_RETURN_REAGENT | PET_REMOVE_FLAG_RESET_CURRENT);

    //we should execute delayed teleports only for alive(!) players
    //because we don't want player's ghost teleported from graveyard
    if (IsHasDelayedTeleport() && IsAlive())
        TeleportTo(m_teleport_dest, m_teleport_options);

    if (GetDeserterMod())
    {
        int32 diff = time(nullptr) - GetLastDeserterTime();
        if (diff >= 1200)
            ApplyDeserter(true);
    }

    m_VignetteMgr.Update();
    sScriptMgr->OnUpdate(this, p_time);
}

void Player::setDeathState(DeathState s)
{
    uint32 ressSpellId = 0;

    bool cur = IsAlive();

    if (s == JUST_DIED)
    {
        if (!cur)
        {
            TC_LOG_ERROR("entities.player", "setDeathState: attempt to kill a dead player %s(%d)", GetName().c_str(), GetGUIDLow());
            return;
        }

        // drunken state is cleared on death
        SetDrunkValue(0);
        // lost combo points at any target (targeted combo points clear in Unit::setDeathState)
        ClearComboPoints();

        ClearResurrectRequestData();

        // save value before aura remove in Unit::setDeathState
        ressSpellId = GetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL);

        // passive spell
        if (!ressSpellId)
            ressSpellId = GetResurrectionSpellId();
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_AT_MAP, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_DEATH_IN_DUNGEON, 1);
        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
        ResetAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GET_KILLING_BLOWS, ACHIEVEMENT_CRITERIA_CONDITION_NO_DEATH);
    }

    Unit::setDeathState(s);

    // restore resurrection spell id for player after aura remove
    if (s == JUST_DIED && cur && ressSpellId)
        SetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL, ressSpellId);

    if (IsAlive() && !cur)
        //clear aura case after resurrection by another way (spells will be applied before next death)
        SetUInt32Value(PLAYER_FIELD_SELF_RES_SPELL, 0);

    if (s == JUST_DIED)
    {
        // Fuck...
        if (GetTalentSpecialization() == SPEC_WARLOCK_DESTRUCTION)
        {
            SetPower(POWER_BURNING_EMBERS, 0);
            m_alternateRegenTimerCount = 0;
        }
        else if (GetTalentSpecialization() == SPEC_WARLOCK_DEMONOLOGY)
        {
            SetPower(POWER_DEMONIC_FURY, 0);
            m_alternateRegenTimerCount = 0;
        }
    }
}

void Player::InnEnter(time_t time, uint32 mapid, float x, float y, float z)
{
    inn_pos_mapid = mapid;
    inn_pos_x = x;
    inn_pos_y = y;
    inn_pos_z = z;
    time_inn_enter = time;
}

bool Player::BuildEnumData(PreparedQueryResult result, ByteBuffer* dataBuffer, ByteBuffer* bitBuffer, bool boosted)
{
    //             0               1                2                3                 4                  5                       6                        7
    //    "SELECT characters.guid, characters.name, characters.race, characters.class, characters.gender, characters.playerBytes, characters.playerBytes2, characters.level, "
    //     8                9               10                     11                     12                     13                    14
    //    "characters.zone, characters.map, characters.position_x, characters.position_y, characters.position_z, guild_member.guildid, characters.playerFlags, "
    //    15                    16                   17                     18                   19               20                     21               22
    //    "characters.at_login, character_pet.entry, character_pet.modelid, character_pet.level, characters.data, character_banned.guid, characters.slot, character_declinedname.genitive"

    Field* fields = result->Fetch();

    ObjectGuid guid = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
    std::string name = fields[1].GetString();
    uint8 playerRace = fields[2].GetUInt8();
    uint8 playerClass = fields[3].GetUInt8();
    uint8 gender = fields[4].GetUInt8();
    uint8 skin = uint8(fields[5].GetUInt32() & 0xFF);
    uint8 face = uint8((fields[5].GetUInt32() >> 8) & 0xFF);
    uint8 hairStyle = uint8((fields[5].GetUInt32() >> 16) & 0xFF);
    uint8 hairColor = uint8((fields[5].GetUInt32() >> 24) & 0xFF);
    uint8 facialHair = uint8(fields[6].GetUInt32() & 0xFF);
    uint8 level = fields[7].GetUInt8();
    uint32 zone = fields[8].GetUInt16();
    uint32 mapId = uint32(fields[9].GetUInt16());
    float x = fields[10].GetFloat();
    float y = fields[11].GetFloat();
    float z = fields[12].GetFloat();
    uint32 guildId = fields[13].GetUInt32();
    ObjectGuid guildGuid = MAKE_NEW_GUID(guildId, 0, guildId ? uint32(HIGHGUID_GUILD) : 0);
    uint32 playerFlags = fields[14].GetUInt32();
    uint32 atLoginFlags = fields[15].GetUInt16();
    Tokenizer equipment(fields[19].GetString(), ' ');
    uint8 slot = fields[21].GetUInt8();

    uint32 charFlags = 0;
    if (playerFlags & PLAYER_FLAGS_HIDE_HELM)
        charFlags |= CHARACTER_FLAG_HIDE_HELM;

    if (playerFlags & PLAYER_FLAGS_HIDE_CLOAK)
        charFlags |= CHARACTER_FLAG_HIDE_CLOAK;

    if (playerFlags & PLAYER_FLAGS_GHOST)
        charFlags |= CHARACTER_FLAG_GHOST;

    if (atLoginFlags & AT_LOGIN_RENAME)
        charFlags |= CHARACTER_FLAG_RENAME;

    if (fields[20].GetUInt32())
        charFlags |= CHARACTER_FLAG_LOCKED_BY_BILLING;

    if (sWorld->getBoolConfig(CONFIG_DECLINED_NAMES_USED))
    {
        if (!fields[22].GetString().empty())
            charFlags |= CHARACTER_FLAG_DECLINED;
    }
    else
        charFlags |= CHARACTER_FLAG_DECLINED;

    uint32 customizationFlag = 0;
    if (atLoginFlags & AT_LOGIN_CUSTOMIZE)
        customizationFlag = CHAR_CUSTOMIZE_FLAG_CUSTOMIZE;
    else if (atLoginFlags & AT_LOGIN_CHANGE_FACTION)
        customizationFlag = CHAR_CUSTOMIZE_FLAG_FACTION;
    else if (atLoginFlags & AT_LOGIN_CHANGE_RACE)
        customizationFlag = CHAR_CUSTOMIZE_FLAG_RACE;

    uint32 petDisplayId = 0;
    uint32 petLevel   = 0;
    uint32 petFamily  = 0;
    // show pet at selection character in character list only for non-ghost character
    if (result && !(playerFlags & PLAYER_FLAGS_GHOST) && (playerClass == CLASS_WARLOCK || playerClass == CLASS_HUNTER || playerClass == CLASS_DEATH_KNIGHT))
    {
        uint32 entry = fields[16].GetUInt32();
        CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(entry);
        if (creatureInfo)
        {
            petDisplayId = fields[17].GetUInt32();
            petLevel     = fields[18].GetUInt16();
            petFamily    = creatureInfo->family;
        }
    }

    // Packet content flags
    bitBuffer->WriteBit(guildGuid[4]);
    bitBuffer->WriteBit(guid[0]);
    bitBuffer->WriteBit(guildGuid[3]);
    bitBuffer->WriteBit(guid[3]);
    bitBuffer->WriteBit(guid[7]);
    bitBuffer->WriteBit(boosted);
    bitBuffer->WriteBit(atLoginFlags & AT_LOGIN_FIRST);
    bitBuffer->WriteBit(guid[6]);
    bitBuffer->WriteBit(guildGuid[6]);
    bitBuffer->WriteBits(uint32(name.length()), 6);
    bitBuffer->WriteBit(guid[1]);
    bitBuffer->WriteBit(guildGuid[1]);
    bitBuffer->WriteBit(guildGuid[0]);
    bitBuffer->WriteBit(guid[4]);
    bitBuffer->WriteBit(guildGuid[7]);
    bitBuffer->WriteBit(guid[2]);
    bitBuffer->WriteBit(guid[5]);
    bitBuffer->WriteBit(guildGuid[2]);
    bitBuffer->WriteBit(guildGuid[5]);

    // Character data
    *dataBuffer << uint32(0);                                   // UNK02 - might be swaped with UNK03

    dataBuffer->WriteByteSeq(guid[1]);

    *dataBuffer << uint8(slot);                                 // List order
    *dataBuffer << uint8(hairStyle);                            // Hair style

    dataBuffer->WriteByteSeq(guildGuid[2]);
    dataBuffer->WriteByteSeq(guildGuid[0]);
    dataBuffer->WriteByteSeq(guildGuid[6]);

    dataBuffer->append(name.c_str(), name.length());            // Name

    dataBuffer->WriteByteSeq(guildGuid[3]);

    *dataBuffer << float(x);                                    // X
    *dataBuffer << uint32(0);                                   // UNK00 new field - Boost fieldand the pet fields
    *dataBuffer << uint8(face);                                 // Face
    *dataBuffer << uint8(playerClass);                          // Class

    dataBuffer->WriteByteSeq(guildGuid[5]);

    for (uint8 slot = 0; slot < INVENTORY_SLOT_BAG_END; ++slot)
    {
        uint32 visualbase = slot * 2;
        uint32 itemId = GetUInt32ValueFromArray(equipment, visualbase);

        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
        if (!proto)
        {
            *dataBuffer << uint8(0);
            *dataBuffer << uint32(0);
            *dataBuffer << uint32(0);
            continue;
        }

        SpellItemEnchantmentEntry const* enchant = NULL;
        uint32 enchants = GetUInt32ValueFromArray(equipment, visualbase + 1);
        for (uint8 enchantSlot = PERM_ENCHANTMENT_SLOT; enchantSlot <= TEMP_ENCHANTMENT_SLOT; ++enchantSlot)
        {
            // values stored in 2 uint16
            uint32 enchantId = 0x0000FFFF & (enchants >> enchantSlot*16);
            if (!enchantId)
                continue;

            enchant = sSpellItemEnchantmentStore.LookupEntry(enchantId);
            if (enchant)
                break;
        }

        *dataBuffer << uint32(enchant ? enchant->AuraID : 0);
        *dataBuffer << uint8(proto->InventoryType);
        *dataBuffer << uint32(proto->DisplayInfoID);
    }

    *dataBuffer << uint32(customizationFlag);                   // Character customization flags

    dataBuffer->WriteByteSeq(guid[3]);
    dataBuffer->WriteByteSeq(guid[5]);

    *dataBuffer << uint32(petFamily);                           // Pet family

    dataBuffer->WriteByteSeq(guildGuid[4]);

    *dataBuffer << uint32(mapId);                               // Map Id
    *dataBuffer << uint8(playerRace);                           // Race
    *dataBuffer << uint8(skin);                                 // Skin

    dataBuffer->WriteByteSeq(guildGuid[1]);

    *dataBuffer << uint8(level);                                // Level

    dataBuffer->WriteByteSeq(guid[0]);
    dataBuffer->WriteByteSeq(guid[2]);

    *dataBuffer << uint8(hairColor);                            // Hair color
    *dataBuffer << uint8(gender);                               // Gender
    *dataBuffer << uint8(facialHair);                           // Facial hair

    *dataBuffer << uint32(petLevel);                            // Pet level

    dataBuffer->WriteByteSeq(guid[4]);
    dataBuffer->WriteByteSeq(guid[7]);

    *dataBuffer << float(y);                                    // Y
    *dataBuffer << uint32(petDisplayId);                        // Pet DisplayID
    *dataBuffer << uint32(0);                                   // UNK03 - might be swaped with UNK02 and the pet fields

    dataBuffer->WriteByteSeq(guid[6]);

    *dataBuffer << uint32(charFlags);                           // Character flags
    *dataBuffer << uint32(zone);                                // Zone id

    dataBuffer->WriteByteSeq(guildGuid[7]);

    *dataBuffer << float(z);                                    // Z

    return true;
}

void Player::ToggleAFK()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    // afk player not allowed in battleground
    if (isAFK())
        if (Battleground* bg = GetBattleground())
            if (bg->IsBattleground() && !bg->IsRatedBG())
                LeaveBattleground();
}

void Player::ToggleDND()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
}

uint8 Player::GetChatTag() const
{
    uint8 tag = CHAT_TAG_NONE;

    if (isGMChat())
        tag |= CHAT_TAG_GM;
    if (isDND())
        tag |= CHAT_TAG_DND;
    if (isAFK())
        tag |= CHAT_TAG_AFK;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
        tag |= CHAT_TAG_DEV;

    return tag;
}

bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options)
{
    if (z > 500000.0f || z <= -200000.0f)
    {
        ACE_Stack_Trace st;
        TC_LOG_ERROR("shitlog", "WorldSession::HandleMoveWorldportAckOpcode z coordinate fucked: %s, map %u, z %f\n%s", GetSession()->GetPlayerInfo().c_str(), mapid, z, st.c_str());
    }

    if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
    {
        TC_LOG_ERROR("maps", "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
            mapid, x, y, z, orientation, GetGUIDLow(), GetName().c_str(), GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        return false;
    }

    if (GetSession()->GetSecurity() < SEC_GAMEMASTER && DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, mapid, this))
    {
        TC_LOG_ERROR("maps", "Player (GUID: %u, name: %s) tried to enter a forbidden map %u", GetGUIDLow(), GetName().c_str(), mapid);
        SendTransferAborted(mapid, TRANSFER_ABORT_MAP_NOT_ALLOWED);
        return false;
    }

    // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
    Pet* pet = GetPet();

    MapEntry const* mEntry = sMapStore.LookupEntry(mapid);

    // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
    // don't let gm level > 1 either
    if (!InBattleground() && mEntry->IsBattlegroundOrArena())
        return false;

    // client without expansion support
    if (GetSession()->Expansion() < mEntry->Expansion())
    {
        TC_LOG_DEBUG("maps", "Player %s using client without required expansion tried teleport to non accessible map %u", GetName().c_str(), mapid);

        if (Transport* transport = GetTransport())
        {
            transport->RemovePassenger(this);
            RepopAtGraveyard();                             // teleport to near graveyard if on transport, looks blizz like :)
        }

        SendTransferAborted(mapid, TRANSFER_ABORT_INSUF_EXPAN_LVL, mEntry->Expansion());

        return false;                                       // normal client can't teleport to this map...
    }
    else
        TC_LOG_DEBUG("maps", "Player %s is being teleported to map %u", GetName().c_str(), mapid);

    if (m_vehicle)
        ExitVehicle();

    // reset movement flags at teleport, because player will continue move with these flags after teleport
    SetUnitMovementFlags(GetUnitMovementFlags() & MOVEMENTFLAG_MASK_HAS_PLAYER_STATUS_OPCODE);
    m_movementInfo.ResetJump();
    DisableSpline();

    if (m_transport)
    {
        if (!(options & TELE_TO_NOT_LEAVE_TRANSPORT))
        {
            m_transport->RemovePassenger(this);
            m_transport = NULL;
            m_movementInfo.ResetTransport();
        }
    }

    // The player was ported to another map and loses the duel immediately.
    // We have to perform this check before the teleport, otherwise the
    // ObjectAccessor won't find the flag.
    if (duel && GetMapId() != mapid && GetMap()->GetGameObject(GetUInt64Value(PLAYER_FIELD_DUEL_ARBITER)))
        DuelComplete(DUEL_FLED);

    if (GetMapId() == mapid && !m_forcedTeleportFar)
    {
        //lets reset far teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportFar(false);
        //setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());
        //if teleport spell is casted in Unit::Update() func
        //then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetSemaphoreTeleportNear(true);
            //lets save teleport destination for player
            m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
            m_teleport_options = options;
            return true;
        }

        if (!(options & TELE_TO_NOT_UNSUMMON_PET))
        {
            //same map, only remove pet if out of range for new position
            if (pet && !pet->IsWithinDist3d(x, y, z, GetMap()->GetVisibilityRange()))
                UnsummonPetTemporaryIfAny();
        }

        if (TempSummon* tempSummon = GetBattlePetMgr().GetCurrentSummon())
            if (!tempSummon->IsWithinDist3d(x, y, z, GetMap()->GetVisibilityRange()))
                GetBattlePetMgr().UnSummonCurrentBattlePet(true);

        if (!(options & TELE_TO_NOT_LEAVE_COMBAT))
            CombatStop();

        // this will be used instead of the current location in SaveToDB
        m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
        SetFallInformation(0, z);
        m_lastTeleportOrChargeTime = getMSTime();

        // code for finish transfer called in WorldSession::HandleMovementOpcodes()
        // at client packet CMSG_MOVE_TELEPORT_ACK
        SetSemaphoreTeleportNear(true);
        // near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
        if (!GetSession()->PlayerLogout())
        {
            Position oldPos;
            GetPosition(&oldPos);
            Relocate(x, y, z, orientation);
            if (Transport* transport = GetTransport())
            {
                transport->CalculatePassengerOffset(x, y, z, &orientation);
                m_movementInfo.transport.pos.Relocate(x, y, z, orientation);
            }
            SendTeleportPacket(oldPos); // this automatically relocates to oldPos in order to broadcast the packet in the right place

            if (HasUnitState(UNIT_STATE_FLEEING | UNIT_STATE_CONFUSED | UNIT_STATE_POSSESSED) || IsCharmed() || isPossessed())
                SetClientControl(this, false);
        }
    }
    else
    {
        if (getClass() == CLASS_DEATH_KNIGHT && GetMapId() == 609 && !IsGameMaster() && getLevel() < 80 && !HasSpell(50977))
            return false;
        if (getRace() == RACE_GOBLIN && getClass() != CLASS_DEATH_KNIGHT && GetMapId() == 648 && !IsGameMaster() && getLevel() < 30 && !IsQuestRewarded(25266) && GetQuestStatus(25266) != QUEST_STATUS_COMPLETE)
            return false;
        if (getRace() == RACE_WORGEN && getClass() != CLASS_DEATH_KNIGHT && GetMapId() == 654 && !IsGameMaster() && getLevel() < 30 && !IsQuestRewarded(26706))
            return false;
        if (getRace() == RACE_PANDAREN_ALLIANCE && GetMapId() == 860 && !IsGameMaster() && getLevel() < 30 && !IsQuestRewarded(31450) && GetQuestStatus(31450) != QUEST_STATUS_COMPLETE)
            return false;
        if (getRace() == RACE_PANDAREN_HORDE && GetMapId() == 860 && !IsGameMaster() && getLevel() < 30 && !IsQuestRewarded(31450) && GetQuestStatus(31450) != QUEST_STATUS_COMPLETE)
            return false;

        // far teleport to another map
        Map* oldmap = IsInWorld() ? GetMap() : NULL;
        // check if we can enter before stopping combat / removing pet / totems / interrupting spells

        // Check enter rights before map getting to avoid creating instance copy for player
        // this check not dependent from map instance copy and same for all instance copies of selected map
        if (!sMapMgr->CanPlayerEnter(mapid, this, false))
            return false;

        //I think this always returns true. Correct me if I am wrong.
        // If the map is not created, assume it is possible to enter it.
        // It will be created in the WorldPortAck.
        //Map* map = sMapMgr->FindBaseNonInstanceMap(mapid);
        //if (!map || map->CanEnter(this))
        {
            //lets reset near teleport flag if it wasn't reset during chained teleports
            SetSemaphoreTeleportNear(false);
            //setup delayed teleport flag
            SetDelayedTeleportFlag(IsCanDelayTeleport());
            //if teleport spell is casted in Unit::Update() func
            //then we need to delay it until update process will be finished
            if (IsHasDelayedTeleport())
            {
                SetSemaphoreTeleportFar(true);
                //lets save teleport destination for player
                m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
                m_teleport_options = options;
                return true;
            }

            SetSelection(0);

            CombatStop();

            ResetContestedPvP();

            // remove player from battleground on far teleport (when changing maps)
            Battleground const* bg = GetBattleground();
            if (bg)
            {
                // Note: at battleground join battleground id set before teleport
                // and we already will found "current" battleground
                // just need check that this is targeted map or leave
                if (bg->GetMapId() != mapid)
                    LeaveBattleground(false);                   // don't teleport to entry point
            }

            // remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
            if (bg && (bg->IsArena() || bg->IsRatedBG()))
            {
                RemoveArenaSpellCooldowns(true);
                RemoveArenaAuras();
                if (pet)
                    pet->RemoveArenaAuras();
            }

            // remove pet on map change
            if (pet)
                UnsummonPetTemporaryIfAny();

            GetBattlePetMgr().UnSummonCurrentBattlePet(true);

            // remove all dyn objects
            RemoveAllDynObjects();

            // stop spellcasting
            // not attempt interrupt teleportation spell at caster teleport
            if (!(options & TELE_TO_SPELL))
                if (IsNonMeleeSpellCasted(true))
                    InterruptNonMeleeSpells(true);

            //remove auras before removing from map...
            RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING));

            if (!GetSession()->PlayerLogout())
            {
                // send transfer packets
                WorldPacket data(SMSG_TRANSFER_PENDING, 4 + 4 + 4);

                data.WriteBit(0);       // unknown
                data.WriteBit(m_transport != NULL);

                data << uint32(mapid);

                if (m_transport)
                {
                    // Might be in wrong order
                    data << GetMapId();
                    data << m_transport->GetEntry();
                }

                GetSession()->SendPacket(&data);
            }

            // After loading player can be teleported when they are still not in the world (but auras are already loaded)
            if (!IsInWorld())
                RemoveBoundAuras();

            // remove from old map now
            if (oldmap)
                oldmap->RemovePlayerFromMap(this, false);

            m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
            SetFallInformation(0, z);
            m_lastTeleportOrChargeTime = getMSTime();
            // if the player is saved before worldportack (at logout for example)
            // this will be used instead of the current location in SaveToDB

            if (!GetSession()->PlayerLogout())
            {
                WorldPacket data(SMSG_NEW_WORLD, 4 + 4 + 4 + 4 + 4);
                data << float(m_teleport_dest.GetPositionX());
                data << uint32(mapid);
                data << float(m_teleport_dest.GetPositionY());
                data << float(m_teleport_dest.GetPositionZ());
                data << float(m_teleport_dest.GetOrientation());
                GetSession()->SendPacket(&data);
                SendSavedInstances();
            }

            // move packet sent by client always after far teleport
            // code for finish transfer to new map called in WorldSession::HandleMoveWorldportAckOpcode at client packet
            SetSemaphoreTeleportFar(true);
        }
        //else
        //    return false;

        // Make all pending loot lockouts active after a far teleport
        m_lootLockouts->FlushPendingLootLockouts();
    }
    return true;
}

bool Player::TeleportTo(WorldLocation const &loc, uint32 options /*= 0*/)
{
    return TeleportTo(loc.GetMapId(), loc.GetPositionX(), loc.GetPositionY(), loc.GetPositionZ(), loc.GetOrientation(), options);
}

bool Player::TeleportToBGEntryPoint()
{
    if (m_bgData.joinPos.m_mapId == MAPID_INVALID)
        return false;

    if (m_bgData.joinPos.m_mapId == 37 && sWorld->getBoolConfig(CONFIG_ICORE_ROYALE_EVENT_ENABLED))
        return false;

    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);
    return TeleportTo(m_bgData.joinPos);
}

void Player::ProcessDelayedOperations()
{
    if (m_DelayedOperations == 0)
        return;

    if (m_DelayedOperations & DELAYED_RESURRECT_PLAYER && _resurrectionData)
    {
        uint64 resurrectorGuid = _resurrectionData->GUID;

        ResurrectPlayer(0.0f, false);

        uint32 health = _resurrectionData->Health;
        AddPct(health, GetResurrectHealthBonus());
        SetHealth(health);

        if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
            SetPower(POWER_MANA, _resurrectionData->Mana);
        else
            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

        SetPower(POWER_RAGE, 0);
        SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
        SetPower(POWER_ECLIPSE, 0);

        if (uint32 aura = _resurrectionData->Aura)
            CastSpell(this, aura, true, NULL, NULL, _resurrectionData->GUID);

        if (IS_PLAYER_GUID(resurrectorGuid))
            RestoreCombatWithPlayer(ObjectAccessor::GetPlayer(*this, resurrectorGuid));

        SpawnCorpseBones();
    }

    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
        SaveToDB();

    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
        ApplyDeserter();

    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
    {
        if (m_bgData.mountSpell)
        {
            CastSpell(this, m_bgData.mountSpell, true);
            m_bgData.mountSpell = 0;
        }
    }

    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
    {
        if (m_bgData.HasTaxiPath())
        {
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[0]);
            m_taxi.AddTaxiDestination(m_bgData.taxiPath[1]);
            m_taxi.SetLastNodeIndex(m_bgData.taxiLastNode);
            m_bgData.ClearTaxiPath();

            ContinueTaxiFlight();
        }
    }

    if (m_DelayedOperations & DELAYED_BG_GROUP_RESTORE)
    {
        if (Group* g = GetGroup())
            g->SendUpdateToPlayer(GetGUID());
    }

    //we have executed ALL delayed ops, so clear the flag
    m_DelayedOperations = 0;
}

void Player::AddToWorld()
{
    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be added when logging in
    Unit::AddToWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->AddToWorld();
}

void Player::RemoveFromWorld()
{
    // cleanup
    if (IsInWorld())
    {
        ///- Release charmed creatures, unsummon totems and remove pets/guardians
        StopCastingCharm();
        StopCastingBindSight();
        GetBattlePetMgr().UnSummonCurrentBattlePet(true);
        UnsummonPetTemporaryIfAny();

        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
    }

    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be removed when logging out
    Unit::RemoveFromWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
    {
        if (m_items[i])
            m_items[i]->RemoveFromWorld();
    }

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        iter->second->RemoveFromWorld();

    if (m_uint32Values)
    {
        if (WorldObject* viewpoint = GetViewpoint())
        {
            TC_LOG_ERROR("entities.player", "Player %s has viewpoint %u %u when removed from world",
                GetName().c_str(), viewpoint->GetEntry(), viewpoint->GetTypeId());
            SetViewpoint(viewpoint, false);
        }
    }
}

void Player::RegenerateAll()
{
    if (m_runes)
    {
        GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN);
        for (auto&& index : { 0, 2, 4 })
        {
            // This may be wrong, I didn't find any actual information about cooldown on miss
            for (auto&& i : { index, index + 1 })
            {
                auto& rune = m_runes->runes[i];
                if (rune.State == RuneState::PenaltyCooldown)
                {
                    uint32 regenedValue = m_regenTimer * GetFloatValue(PLAYER_FIELD_RUNE_REGEN + rune.CurrentRune) * 10;
                    rune.Readiness += regenedValue;
                    if (rune.Readiness + regenedValue >= RUNE_READINESS_FULL)
                    {
                        rune.Readiness = RUNE_READINESS_FULL;
                        rune.State = RuneState::Ready;
                    }
                }
            }

            int32 thisIndex = -1;

            if (m_runes->runes[index].State == RuneState::NormalCooldown)
            {
                ASSERT(m_runes->runes[index + 1].State != RuneState::NormalCooldown);
                thisIndex = index;
            }
            else if (m_runes->runes[index + 1].State == RuneState::NormalCooldown)
                thisIndex = index + 1;

            if (thisIndex >= 0)
            {
                uint8 otherIndex = GetOtherRune(thisIndex);
                auto& thisRune = m_runes->runes[thisIndex];
                auto& otherRune = m_runes->runes[otherIndex];

                uint32 regenedValue = m_regenTimer * GetFloatValue(PLAYER_FIELD_RUNE_REGEN + thisRune.CurrentRune) * 10;

                if (thisRune.Readiness + regenedValue >= RUNE_READINESS_FULL)
                {
                    regenedValue = (thisRune.Readiness + regenedValue) - RUNE_READINESS_FULL;
                    ActivateRune(thisIndex);
                    if (regenedValue)
                    {
                        if (otherRune.Readiness + regenedValue >= RUNE_READINESS_FULL)
                            ActivateRune(otherIndex);
                        else
                            otherRune.Readiness += regenedValue;
                    }
                }
                else
                    thisRune.Readiness += regenedValue;
            }
        }
    }

    if (!IsAlive())
    {
        m_regenTimer = 0;
        return;
    }

    m_regenTimerCount += m_regenTimer;

    Regenerate(POWER_ENERGY);
    Regenerate(POWER_MANA);
    Regenerate(POWER_RAGE);

    switch (getClass())
    {
        case CLASS_PALADIN:
            m_alternateRegenTimerCount += m_regenTimer;
            if (m_alternateRegenTimerCount >= 10000)
            {
                Regenerate(POWER_HOLY_POWER);
                m_alternateRegenTimerCount -= 10000;
            }
            break;
        case CLASS_HUNTER:
            Regenerate(POWER_FOCUS);
            break;
        case CLASS_MONK:
            m_alternateRegenTimerCount += m_regenTimer;
            if (m_alternateRegenTimerCount >= 10000)
            {
                Regenerate(POWER_CHI);
                m_alternateRegenTimerCount -= 10000;
            }
            break;
        case CLASS_WARLOCK:
            switch (GetTalentSpecialization())
            {
                case SPEC_WARLOCK_DEMONOLOGY:
                    m_alternateRegenTimerCount += m_regenTimer;
                    if (m_alternateRegenTimerCount >= 100)
                    {
                        Regenerate(POWER_DEMONIC_FURY);
                        m_alternateRegenTimerCount -= 100;
                    }
                    break;
                case SPEC_WARLOCK_DESTRUCTION:
                    m_alternateRegenTimerCount += m_regenTimer;
                    if (m_alternateRegenTimerCount >= 2000)
                    {
                        Regenerate(POWER_BURNING_EMBERS);
                        m_alternateRegenTimerCount -= 2000;
                    }
                    break;
                case SPEC_WARLOCK_AFFLICTION:
                    m_alternateRegenTimerCount += m_regenTimer;
                    if (m_alternateRegenTimerCount >= 20000)
                    {
                        Regenerate(POWER_SOUL_SHARDS);
                        m_alternateRegenTimerCount -= 20000;
                    }
                    break;
            }
            break;
    }

    if (m_regenTimerCount >= 2000)
    {
        // Not in combat or they have regeneration
        if (!IsInCombat() || IsPolymorphed() || m_baseHealthRegen ||
            HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) ||
            HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT))
        {
            RegenerateHealth();
        }

        if (getClass() == CLASS_DEATH_KNIGHT)
            Regenerate(POWER_RUNIC_POWER);

        m_regenTimerCount -= 2000;
    }

    m_regenTimer = 0;
}

void Player::Regenerate(Powers power)
{
    uint32 maxValue = GetMaxPower(power);
    if (!maxValue)
        return;

    uint32 curValue = GetPower(power);

    /// @todo possible use of miscvalueb instead of amount
    if (HasAuraTypeWithValue(SPELL_AURA_PREVENT_REGENERATE_POWER, power))
        return;

    // Skip regeneration for power type we cannot have
    uint32 powerIndex = GetPowerIndex(power);
    if (powerIndex == MAX_POWERS)
        return;

    float addvalue = 0.0f;

    switch (power)
    {
        case POWER_MANA:
            if (IsInCombat()) // Trinity Updates Mana in intervals of 2s, which is correct
                addvalue = GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) * (0.001f * m_regenTimer);
            else
                addvalue = GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * (0.001f * m_regenTimer);
            break;
        case POWER_RAGE:
        case POWER_FOCUS:
        case POWER_ENERGY:
            addvalue = GetPowerRegen(power) / IN_MILLISECONDS * m_regenTimer;
            break;
        case POWER_RUNIC_POWER:
            if (!IsInCombat() && !HasAuraType(SPELL_AURA_INTERRUPT_REGEN))
                addvalue = -30;         // 3 RunicPower by tick
            break;
        case POWER_HOLY_POWER:                                          // Regenerate holy power
        case POWER_CHI:                                                 // Regenerate chi (monk)
            if (!IsInCombat())
                addvalue = -1.0f;      // remove 1 each 10 sec
            break;
        case POWER_DEMONIC_FURY:
        {
            uint32 cur = GetPower(POWER_DEMONIC_FURY);
            if (!IsInCombat())
            {
                if (cur > 200)
                    addvalue = -1;
                else if (cur < 200)
                    addvalue = 1;
            }
            break;
        }
        case POWER_BURNING_EMBERS:
        {
            // After 15s return to one embers if no one
            // or return to one if more than one
            if (!IsInCombat() && GetPower(POWER_BURNING_EMBERS) < 10)
                SetPower(POWER_BURNING_EMBERS, GetPower(POWER_BURNING_EMBERS) + 1);
            else if (!IsInCombat() && GetPower(POWER_BURNING_EMBERS) > 10)
                SetPower(POWER_BURNING_EMBERS, GetPower(POWER_BURNING_EMBERS) - 1);
            break;
        }
        case POWER_SOUL_SHARDS:
        {
            // If isn't in combat, gain 1 shard every 20s
            if (!IsInCombat())
                SetPower(POWER_SOUL_SHARDS, GetPower(POWER_SOUL_SHARDS) + 100);
        }
        case POWER_RUNES:
            break;
        case POWER_HEALTH:
            return;
        default:
            break;
    }

    if (addvalue < 0.0f)
    {
        if (curValue == 0)
            return;
    }
    else if (addvalue > 0.0f)
    {
        if (curValue == maxValue)
            return;
    }
    else
        return;

    addvalue += m_powerFraction[powerIndex];
    uint32 integerValue = uint32(fabs(addvalue));

    if (addvalue < 0.0f)
    {
        if (curValue > integerValue)
        {
            curValue -= integerValue;
            m_powerFraction[powerIndex] = addvalue + integerValue;
        }
        else
        {
            curValue = 0;
            m_powerFraction[powerIndex] = 0;
        }
    }
    else
    {
        curValue += integerValue;

        if (curValue > maxValue)
        {
            curValue = maxValue;
            m_powerFraction[powerIndex] = 0;
        }
        else
            m_powerFraction[powerIndex] = addvalue - integerValue;
    }

    if (m_regenTimerCount >= 2000 || power > POWER_ENERGY)
        SetPower(power, curValue);
    else
        UpdateUInt32Value(UNIT_FIELD_POWER + powerIndex, curValue);
}

void Player::ResetAllPowers()
{
    SetHealth(GetMaxHealth());

    // Main powers
    Powers mainPower = GetPowerType();
    switch (mainPower)
    {
        case POWER_MANA:
        case POWER_FOCUS:
        case POWER_ENERGY:
            SetPower(mainPower, GetMaxPower(mainPower));
            break;
        case POWER_RAGE:
        case POWER_RUNIC_POWER:
            SetPower(mainPower, 0);
            break;
    }

    // Alternative powers
    SetPower(POWER_SOUL_SHARDS, 400);
    SetPower(POWER_ECLIPSE, 0);
    SetPower(POWER_HOLY_POWER, 0);
    SetPower(POWER_CHI, 0);
    SetPower(POWER_SHADOW_ORBS, 0);
    SetPower(POWER_BURNING_EMBERS, 10);
    SetPower(POWER_DEMONIC_FURY, 200);
}

bool Player::CanInteractWithQuestGiver(Object* questGiver)
{
    switch (questGiver->GetTypeId())
    {
        case TYPEID_UNIT:
            return GetNPCIfCanInteractWith(questGiver->GetGUID(), UNIT_NPC_FLAG_QUESTGIVER) != NULL;
        case TYPEID_GAMEOBJECT:
            return GetGameObjectIfCanInteractWith(questGiver->GetGUID(), GAMEOBJECT_TYPE_QUESTGIVER) != NULL;
        case TYPEID_PLAYER:
            return IsAlive() && questGiver->ToPlayer()->IsAlive();
        case TYPEID_ITEM:
            return IsAlive();
        default:
            break;
    }
    return false;
}

Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
{
    // unit checks
    if (!guid)
        return NULL;

    if (!IsInWorld())
        return NULL;

    if (IsInFlight())
        return NULL;

    // exist (we need look pets also for some interaction (quest/etc)
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (!creature)
        return NULL;

    // Deathstate checks
    if (!IsAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST))
        return NULL;

    // alive or spirit healer
    if (!creature->IsAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT))
        return NULL;

    // appropriate npc type
    if (npcflagmask && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS, npcflagmask))
        return NULL;

    // not allow interaction under control, but allow with own pets
    if (creature->GetCharmerGUID())
        return NULL;

    // not enemy
    if (creature->IsHostileTo(this))
        return NULL;

    // not unfriendly
    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
        if (factionTemplate->faction)
            if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->faction))
                if (faction->reputationListID >= 0 && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
                    return NULL;

    // not too far
    if (!creature->IsWithinDistInMap(this, npcflagmask & UNIT_NPC_FLAG_WILDPET_CAPTURABLE ? PETBATTLE_INTERACTION_DIST : (creature->GetEntry() == 60166 || creature->GetEntry() == 60167) ? 9.6f : INTERACTION_DISTANCE))
        return NULL;

    return creature;
}

Creature* Player::GetNPCIfCanInteractWithFlag2(uint64 guid, uint32 npcflagmask)
{
    // unit checks
    if (!guid)
        return NULL;

    if (!IsInWorld())
        return NULL;

    if (IsInFlight())
        return NULL;

    // exist (we need look pets also for some interaction (quest/etc)
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (!creature)
        return NULL;

    // Deathstate checks
    if (!IsAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST))
        return NULL;

    // alive or spirit healer
    if (!creature->IsAlive() && !(creature->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT))
        return NULL;

    // appropriate npc type
    if (npcflagmask && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS + 1, npcflagmask))
        return NULL;

    // not allow interaction under control, but allow with own pets
    if (creature->GetCharmerGUID())
        return NULL;

    // not enemy
    if (creature->IsHostileTo(this))
        return NULL;

    // not unfriendly
    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
    if (factionTemplate->faction)
    if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->faction))
    if (faction->reputationListID >= 0 && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
        return NULL;

    // not too far
    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return NULL;

    return creature;
}

GameObject* Player::GetGameObjectIfCanInteractWith(uint64 guid, GameobjectTypes type) const
{
    if (GameObject* go = GetMap()->GetGameObject(guid))
        if (go->GetGoType() == type)
            if (go->IsAtInteractDistance(this))
                return go;
    return nullptr;
}

bool Player::IsUnderWater() const
{
    return IsInWater() &&
        GetPositionZ() < (GetBaseMap()->GetWaterLevel(GetPositionX(), GetPositionY()) - GetCollisionHeight(IsMounted()));
}

void Player::SetInWater(bool apply)
{
    if (m_isInWater == apply)
        return;

    //define player in water by opcodes
    //move player's guid into HateOfflineList of those mobs
    //which can't swim and move guid back into ThreatList when
    //on surface.
    /// @todo exist also swimming mobs, and function must be symmetric to enter/leave water
    m_isInWater = apply;

    // remove auras that need water/land
    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);

    getHostileRefManager().updateThreatTables();
}

void Player::SetGameMaster(bool on)
{
    if (on)
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
        setFaction(35);
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        SetFlag(UNIT_FIELD_FLAGS2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* pet = GetPet())
        {
            pet->setFaction(35);
            pet->getHostileRefManager().setOnlineOfflineState(false);
        }

        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        ResetContestedPvP();

        getHostileRefManager().setOnlineOfflineState(false);
        CombatStopWithPets();

        SetPhaseMask(uint32(PHASEMASK_ANYWHERE), false);    // see and visible in all phases
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
    else
    {
        m_ExtraFlags &= ~ PLAYER_EXTRA_GM_ON;
        setFactionForRace(getRace());
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        RemoveFlag(UNIT_FIELD_FLAGS2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* pet = GetPet())
        {
            pet->setFaction(getFaction());
            pet->getHostileRefManager().setOnlineOfflineState(true);
        }

        // restore FFA PvP Server state
        if (sWorld->IsFFAPvPRealm())
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);

        // restore FFA PvP area state, remove not allowed for GM mounts
        UpdateArea(m_areaUpdateId);

        getHostileRefManager().setOnlineOfflineState(true);
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);

        phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_SERVERSIDE_CHANGED);
        phaseMgr.Update();
    }

    UpdateObjectVisibility();
}

void Player::SetGMVisible(bool on)
{
    if (on)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_INVISIBLE;         //remove flag
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
    }
    else
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_INVISIBLE;          //add flag

        SetAcceptWhispers(false);
        SetGameMaster(true);

        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
}

bool Player::IsGroupVisibleFor(Player const* p) const
{
    switch (sWorld->getIntConfig(CONFIG_GROUP_VISIBILITY))
    {
        default: return IsInSameGroupWith(p);
        case 1:  return IsInSameRaidWith(p);
        case 2:  return GetTeam() == p->GetTeam();
    }
}

bool Player::IsInSameGroupWith(Player const* p) const
{
    return p == this || (GetGroup() != NULL &&
        GetGroup() == p->GetGroup() &&
        GetGroup()->SameSubGroup(this, p));
}

bool Player::IsInSameRaidWith(Player const* p) const
{
    return p == this || (GetGroup() != NULL && GetGroup() == p->GetGroup());
}

///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
/// @todo Shouldn't we also check if there is no other invitees before disbanding the group?
void Player::UninviteFromGroup()
{
    Group* group = GetGroupInvite();
    if (!group)
        return;

    group->RemoveInvite(this);

    if (group->GetMembersCount() <= 1)                       // group has just 1 member => disband
    {
        if (group->IsCreated())
        {
            group->Disband(true);
        }
        else
        {
            group->RemoveAllInvites();
            delete group;
        }
    }
}

void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /* = 0 */, const char* reason /* = NULL */)
{
    if (group)
    {
        group->RemoveMember(guid, method, kicker, reason);
        group = NULL;
    }
}

void Player::SendLogXPGain(uint32 GivenXP, Unit* victim, uint32 BonusXP, bool recruitAFriend, float /*group_rate*/)
{
    ObjectGuid victimGuid = victim ? victim->GetGUID() : 0;

    WorldPacket data(SMSG_LOG_XPGAIN, 1 + 1 + 8 + 4 + 4 + 4 + 1);
    data.WriteBit(!victim);                // has XP
    data.WriteBit(victimGuid[1]);
    data.WriteBit(victimGuid[2]);
    data.WriteBit(victimGuid[7]);
    data.WriteBit(victimGuid[4]);
    data.WriteBit(victimGuid[3]);
    data.WriteBit(0);                      // unknown
    data.WriteBit(victimGuid[0]);
    data.WriteBit(victimGuid[5]);
    data.WriteBit(victimGuid[6]);
    data.WriteBit(0);                      // has group bonus

    data.FlushBits();

    data.WriteByteSeq(victimGuid[4]);
    data.WriteByteSeq(victimGuid[2]);
    data << uint8(recruitAFriend ? 1 : 0); // does the GivenXP include a RaF bonus?
    data << float(1);                      // 1 - none 0 - 100% group bonus output
    data.WriteByteSeq(victimGuid[7]);
    data.WriteByteSeq(victimGuid[1]);
    data.WriteByteSeq(victimGuid[3]);
    data.WriteByteSeq(victimGuid[6]);

    data << uint32(GivenXP + BonusXP);

    if (victim)
        data << uint32(GivenXP);          // experience without bonus

    data.WriteByteSeq(victimGuid[0]);
    data.WriteByteSeq(victimGuid[5]);

    GetSession()->SendPacket(&data);
}

void Player::GiveXP(uint32 xp, Unit* victim, float group_rate)
{
    if (xp < 1)
        return;

    if (!IsAlive() && !GetBattlegroundId())
        return;

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
        return;

    if (victim && victim->GetTypeId() == TYPEID_UNIT && !victim->ToCreature()->HasLootRecipient())
        return;

    uint8 level = getLevel();

    sScriptMgr->OnGivePlayerXP(this, xp, victim);

    // Favored experience increase START
    uint32 zone = GetZoneId();
    float favored_exp_mult = 0;
    if ((HasAura(32096) || HasAura(32098)) && (zone == 3483 || zone == 3562 || zone == 3836 || zone == 3713 || zone == 3714))
        favored_exp_mult = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
    xp = uint32(xp * (1 + favored_exp_mult));
    // Favored experience increase END

    // XP to money conversion processed in Player::RewardQuest
    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    uint32 bonus_xp = 0;
    bool recruitAFriend = GetsRecruitAFriendBonus(true);

    // RaF does NOT stack with rested experience
    if (recruitAFriend)
        bonus_xp = 2 * xp; // xp + bonus_xp must add up to 3 * xp for RaF; calculation for quests done client-side
    else
        bonus_xp = victim ? GetXPRestBonus(xp) : 0; // XP resting bonus

    SendLogXPGain(xp, victim, bonus_xp, recruitAFriend, group_rate);

    uint32 curXP = GetUInt32Value(PLAYER_FIELD_XP);
    uint32 nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    uint32 newXP = curXP + xp + bonus_xp;

    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        newXP -= nextLvlXP;

        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            GiveLevel(level + 1);

        level = getLevel();
        nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    }

    SetUInt32Value(PLAYER_FIELD_XP, newXP);
}

// Update player to next level
// Current player experience not update (must be update by caller)
void Player::GiveLevel(uint8 level)
{
    uint8 oldLevel = getLevel();
    if (level == oldLevel)
        return;

    if (Guild* guild = GetGuild())
        guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, basehp, basemana);

    // send levelup info to client
    WorldPacket data(SMSG_LEVELUP_INFO, ((MAX_POWERS_PER_CLASS * 4) + 4 + 4 + (MAX_STATS * 4) + 4));

    data << uint32(int32(basehp) - int32(GetCreateHealth()));

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)       // Stats loop (0-4)
        data << uint32(int32(info.stats[i]) - GetCreateStat(Stats(i)));

    bool talent = false;

    data << bool(talent);
    data << uint32(level);
    data << uint32(int32(basemana) - int32(GetCreateMana()));
    data << uint32(0); //unk
    data << uint32(0); //unk
    data << uint32(0); //unk
    data << uint32(0); //unk

    GetSession()->SendPacket(&data);

    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(level));

    //update level, max level of skills
    m_Played_time[PLAYED_TIME_LEVEL] = 0;                   // Level Played Time reset

    _ApplyAllLevelScaleItemMods(false);

    SetLevel(level);

    LearnDefaultSkills();
    UpdateSkillsForLevel();

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);
    SetCreateMana(basemana);

    InitTalentForLevel();
    InitTaxiNodesForLevel();
    InitGlyphsForLevel();

    UpdateAllStats();

    if (sWorld->getBoolConfig(CONFIG_ALWAYS_MAXSKILL)) // Max weapon skill when leveling up
        UpdateSkillsToMaxSkillsForLevel();

    _ApplyAllLevelScaleItemMods(true); // Moved to above SetFullHealth so player will have full health from Heirlooms

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
    SetPower(POWER_FOCUS, 0);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();

    if (MailLevelReward const* mailReward = sObjectMgr->GetMailLevelReward(level, getRaceMask()))
    {
        /// @todo Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft(mailReward->mailTemplateId).SendMailTo(trans, this, MailSender(MAIL_CREATURE, mailReward->senderEntry));
        CharacterDatabase.CommitTransaction(trans);
    }

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_LEVEL);

    PhaseUpdateData phaseUpdateData;
    phaseUpdateData.AddConditionType(CONDITION_LEVEL);

    phaseMgr.NotifyConditionChanged(phaseUpdateData);

    // Refer-A-Friend
    if (GetSession()->GetRecruiterId())
    {
        if (level < sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
        {
            if (level % 2 == 0)
            {
                ++m_grantableLevels;

                if (!HasByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, 1, 0x01))
                    SetByteFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, 1, 0x01);
            }
        }
    }

    LearnSpecializationSpells();

    // monk class quests
    std::map<uint8, uint32> monkQuestToLevel =
    {
        { 20, 31856 }, // The Peak of Serenity - Begin Your Training
        { 30, 31855 }, // The Peak of Serenity - Continue Your Training
        { 40, 31857 }, // The Peak of Serenity - Continue Your Training
        { 50, 31858 }, // The Peak of Serenity - Continue Your Training
        { 60, 31859 }, // The Peak of Serenity - Continue Your Training
        { 70, 31860 }, // The Peak of Serenity - Continue Your Training
        { 80, 31861 }, // The Peak of Serenity - Continue Your Training
        { 90, 31989 }, // The Peak of Serenity - Complete Your Training
    };

    auto itr = monkQuestToLevel.find(getLevel());
    if (itr != monkQuestToLevel.end())
        if (getClass() == CLASS_MONK && GetQuestStatus(itr->second) == QUEST_STATUS_NONE)
            if (Quest const* quest = sObjectMgr->GetQuestTemplate(itr->second))
            {
                AddQuest(quest, this);
                PlayerTalkClass->SendQuestGiverQuestDetails(quest, GetGUID(), true, true);
                if (CanCompleteQuest(quest->GetQuestId()))
                    CompleteQuest(quest->GetQuestId());
            }

    sScriptMgr->OnPlayerLevelChanged(this, oldLevel);

    SetSaveTimer(1);

    if (!(level % 10) && oldLevel < level)
        if (projectMemberInfo* info = GetSession()->GetprojectMemberInfo())
            info->Notify(this, projectMemberInfo::Notification::LevelUp);
}

void Player::InitTalentForLevel()
{
    uint8 level = getLevel();
    // talents base at level diff (talents = level - 9 but some can be used already)
    if (level < 15)
    {
        // Remove all talent points
        if (GetUsedTalentCount() > 0)                           // Free any used talents
            ResetTalents(true);
    }
    else
    {
        if (level < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL) || GetSpecsCount() == 0)
        {
            SetSpecsCount(1);
            SetActiveSpec(0);
        }
    }

    SetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS, CalculateTalentsPoints());

    if (!GetSession()->PlayerLoading())
        SendTalentsInfoData();                         // update at client
}

void Player::RemoveSpecializationSpells()
{
    std::list<uint32> spellToRemove;

    for (auto itr : GetSpellMap())
    {
        SpellInfo const* spell = sSpellMgr->GetSpellInfo(itr.first);
        if (spell && !spell->SpecializationIdList.empty())
            spellToRemove.push_back(itr.first);
    }

    for (auto itr : spellToRemove)
        RemoveSpell(itr);
}

void Player::InitStatsForLevel(bool reapplyMods)
{
    if (reapplyMods)                                        //reapply stats values only on .reset stats (level) command
        _RemoveAllStatBonuses();

    uint32 basehp = 0, basemana = 0;
    sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), basehp, basemana);

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);

    SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));

    // reset before any aura state sources (health set/aura apply)
    SetUInt32Value(UNIT_FIELD_AURA_STATE, 0);

    UpdateSkillsForLevel();

    // set default cast time multiplier
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.2f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    // set default cast time multiplier

    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    // reset size before reapply auras
    SetObjectScale(1.0f);

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetStat(Stats(i), info.stats[i]);

    SetCreateHealth(basehp);

    //set create powers
    SetCreateMana(basemana);

    SetArmor(int32(m_createStats[STAT_AGILITY]*2));

    InitStatBuffMods();

    //reset rating fields values
    for (uint16 index = PLAYER_FIELD_COMBAT_RATINGS; index < PLAYER_FIELD_COMBAT_RATINGS + CR_MAX_COMBAT_RATING; ++index)
        SetUInt32Value(index, 0);

    SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, 0);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_HEALING_DONE_PERCENT, 1.0f);
    for (uint8 i = 0; i < 7; ++i)
    {
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+i, 0);
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+i, 0);
        SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT+i, 1.0f);
    }

    SetFloatValue(PLAYER_FIELD_MOD_SPELL_POWER_PERCENT, 1.0f);

    //reset attack power, damage and attack speed fields
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME, 2000.0f);
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 1, 2000.0f); // offhand attack time
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME, 2000.0f);

    SetFloatValue(UNIT_FIELD_MIN_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS, 1.0f);

    SetInt32Value(UNIT_FIELD_ATTACK_POWER,            0);
    SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, 0.0f);
    SetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER,     0);
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, 0.0f);

    // Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    SetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE, 0.0f);

    // Init spell schools (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    for (uint8 i = 0; i < 7; ++i)
        SetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE+i, 0.0f);

    SetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE, 0.0f);

    // Static 30% damage blocked
    SetUInt32Value(PLAYER_FIELD_SHIELD_BLOCK, 30);

    // set armor (resistance 0) to original value (create_agility*2)
    SetArmor(int32(m_createStats[STAT_AGILITY]*2));
    SetResistanceBuffMods(SpellSchools(0), true, 0.0f);
    SetResistanceBuffMods(SpellSchools(0), false, 0.0f);
    // set other resistance to original value (0)
    for (uint8 i = 1; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetResistance(SpellSchools(i), 0);
        SetResistanceBuffMods(SpellSchools(i), true, 0.0f);
        SetResistanceBuffMods(SpellSchools(i), false, 0.0f);
    }

    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, 0);
    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE, 0);
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetUInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i, 0);
        SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i, 0.0f);
    }
    // Reset no reagent cost field
    for (uint8 i = 0; i < 3; ++i)
        SetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK + i, 0);
    // Init data for form but skip reapply item mods for form
    InitDataForForm(reapplyMods);

    // save new stats
    for (uint8 i = POWER_MANA; i < MAX_POWERS; ++i)
        SetMaxPower(Powers(i), GetCreatePowers(Powers(i)));

    SetMaxHealth(basehp);                     // stamina bonus will applied later

    // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
    SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, 0);

    // cleanup unit flags (will be re-applied if need at aura load).
    RemoveFlag(UNIT_FIELD_FLAGS,
        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_NOT_ATTACKABLE_1 |
        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
        UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
        UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
        UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
        UNIT_FLAG_SKINNABLE      | UNIT_FLAG_MOUNT        | UNIT_FLAG_TAXI_FLIGHT      );
    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);   // must be set

    SetFlag(UNIT_FIELD_FLAGS2, UNIT_FLAG2_REGENERATE_POWER);// must be set

    // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK | PLAYER_FLAGS_DND | PLAYER_FLAGS_GM | PLAYER_FLAGS_GHOST | PLAYER_FLAGS_ALLOW_ONLY_ABILITY);

    RemoveStandFlags(UNIT_STAND_FLAGS_ALL);                 // one form stealth modified bytes
    RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP | UNIT_BYTE2_FLAG_SANCTUARY);

    // restore if need some important flags
    //SetUInt32Value(PLAYER_FIELD_LIFETIME_MAX_RANK2, 0);                 // flags empty by default

    if (reapplyMods)                                        // reapply stats values only on .reset stats (level) command
        _ApplyAllStatBonuses();

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
    SetPower(POWER_RUNIC_POWER, 0);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();
}

void Player::SendInitialSpells()
{
    TC_LOG_DEBUG("network", "CHARACTER: sent SMSG_INITIAL_SPELLS ");

    uint16 spellCount = 0;

    WorldPacket data(SMSG_INITIAL_SPELLS, (1 + 2 + 4 * m_spells.size() + 2));
    data.WriteBit(false);

    size_t bitPos = data.bitwpos();
    data.WriteBits(0, 22); // spell count placeholder

    data.FlushBits();

    // Bug when Aspect of Hawk send after Aspect of Iron Hawk and it doubles on the stance panel.
    // This is because std::unordered_map don't keep the order of insertion.
    bool hasAspectOfIronHawk = false;

    for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
    {
        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_TEMPORARY)
            continue;

        if (!itr->second->active || itr->second->disabled)
            continue;

        if (itr->first == 109260)
        {
            hasAspectOfIronHawk = true;
            continue;
        }

        data << uint32(itr->first);

        ++spellCount;
    }

    if (hasAspectOfIronHawk)
    {
        data << uint32(109260);
        ++spellCount;
    }

    data.PutBits(bitPos, spellCount, 22);
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendUnlearnSpells()
{
    TC_LOG_DEBUG("network", "CHARACTER: sent SMSG_SEND_UNLEARN_SPELLS");

    WorldPacket data(SMSG_SEND_UNLEARN_SPELLS);
    data.WriteBits(0, 22);
    data.FlushBits();
    GetSession()->SendPacket(&data);
}

void Player::SendInitialSetup()
{
    TC_LOG_DEBUG("network", "CHARACTER: sent SMSG_INITIAL_SETUP");
    bool hasData = true;

    std::vector<uint8> QuestsCompleted;
    QuestsCompleted.reserve(QUESTS_COMPLETED_BITS_SIZE);
    boost::to_block_range(_completedQuestBits, std::back_inserter(QuestsCompleted));

    WorldPacket data(SMSG_INITIAL_SETUP, 2062);
    data.WriteBit(!hasData);
    data.WriteBits(QUESTS_COMPLETED_BITS_SIZE, 24);
    data << uint32(3);                         // Cfg_Regions.dbc, EU
    data << uint8(0);                          // ServerExpansionTier
    if (hasData)
        data << uint32(1135753200);            // Constant date, unk (28.12.2005 07:00)
    if (!QuestsCompleted.empty())
        data.append(QuestsCompleted.data(), QuestsCompleted.size());
    data << uint8(sWorld->getIntConfig(CONFIG_EXPANSION));
    GetSession()->SendPacket(&data);
}

void Player::RemoveMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->messageID == id)
        {
            //do not delete item, because Player::removeMail() is called when returning mail to sender.
            m_mail.erase(itr);
            return;
        }
    }
}

void Player::SendMailResult(uint32 mailId, MailResponseType mailAction, MailResponseResult mailError, uint32 equipError, uint32 item_guid, uint32 item_count)
{
    WorldPacket data(SMSG_SEND_MAIL_RESULT, 4 + 4 + 4 + 4 + 4 + 4);
    data << uint32(mailId);
    data << uint32(equipError);
    data << uint32(mailError);
    data << uint32(mailAction);
    data << uint32(item_guid);
    data << uint32(item_count);

    GetSession()->SendPacket(&data);
}

void Player::SendNewMail()
{
    // deliver undelivered mail
    WorldPacket data(SMSG_RECEIVED_MAIL, 4);
    data << float(0);
    GetSession()->SendPacket(&data);
}

void Player::UpdateNextMailTimeAndUnreads()
{
    // calculate next delivery time (min. from non-delivered mails
    // and recalculate unReadMail
    time_t cTime = time(NULL);
    m_nextMailDelivereTime = 0;
    unReadMails = 0;
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->deliver_time > cTime)
        {
            if (!m_nextMailDelivereTime || m_nextMailDelivereTime > (*itr)->deliver_time)
                m_nextMailDelivereTime = (*itr)->deliver_time;
        }
        else if (((*itr)->checked & MAIL_CHECK_MASK_READ) == 0)
            ++unReadMails;
    }
}

void Player::AddNewMailDeliverTime(time_t deliver_time)
{
    if (deliver_time <= time(NULL))                          // ready now
    {
        ++unReadMails;
        SendNewMail();
    }
    else                                                    // not ready and no have ready mails
    {
        if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
            m_nextMailDelivereTime = deliver_time;
    }
}

void DeleteSpellFromAllPlayers(uint32 spellId)
{
    CharacterDatabaseStatements stmts[2] = {CHAR_DEL_INVALID_SPELL_SPELLS, CHAR_DEL_INVALID_SPELL_TALENTS};
    for (uint8 i = 0; i < 2; i++)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(stmts[i]);

        stmt->setUInt32(0, spellId);

        CharacterDatabase.Execute(stmt);
    }
}

bool Player::AddTalent(uint32 spellId, uint8 spec, bool learning)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_ERROR("spells", "Player::AddTalent: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", spellId);

            DeleteSpellFromAllPlayers(spellId);
        }
        else
            TC_LOG_ERROR("spells", "Player::AddTalent: Non-existed in SpellStore spell #%u request.", spellId);

        return false;
    }

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_ERROR("spells", "Player::AddTalent: Broken spell #%u learning not allowed, deleting for all characters in `character_talent`.", spellId);

            DeleteSpellFromAllPlayers(spellId);
        }
        else
            TC_LOG_ERROR("spells", "Player::AddTalent: Broken spell #%u learning not allowed.", spellId);

        return false;
    }

    PlayerTalentMap::iterator itr = GetTalentMap(spec)->find(spellId);
    if (itr == GetTalentMap(spec)->end())
    {
        if (TalentSpellPos const* talentPos = GetTalentSpellPos(spellId))
        {
            PlayerTalent* newtalent = new PlayerTalent();

            newtalent->state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;
            newtalent->spec = spec;

            (*GetTalentMap(spec))[spellId] = newtalent;
            return true;
        }
    }
    else
        itr->second->state = PLAYERSPELL_UNCHANGED;

    return false;
}

bool Player::AddSpell(uint32 spellId, bool active, bool learning, bool dependent, bool disabled, bool loading /*= false*/)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_ERROR("spells", "Player::AddSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", spellId);

            DeleteSpellFromAllPlayers(spellId);
        }
        else
            TC_LOG_ERROR("spells", "Player::AddSpell: Non-existed in SpellStore spell #%u request.", spellId);

        return false;
    }

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_ERROR("spells", "Player::AddSpell: Broken spell #%u learning not allowed, deleting for all characters in `character_spell`.", spellId);

            DeleteSpellFromAllPlayers(spellId);
        }
        else
            TC_LOG_ERROR("spells", "Player::AddSpell: Broken spell #%u learning not allowed.", spellId);

        return false;
    }

    if (GetSession()->GetSecurity() < SEC_GAMEMASTER)
    {
        if (spellInfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && getRaceMask() & RACEMASK_ALLIANCE)
            return false;

        if (spellInfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && getRaceMask() & RACEMASK_HORDE)
            return false;

        if (spellInfo->IsAbilityOfSkillType(SKILL_MOUNTS))
            if (!IsMountCanBeAllowedForPlayer(spellInfo->Id, getRaceMask()))
                return false;
    }

    SkillLineAbilityMapBounds skillBounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);

    for (auto itr = skillBounds.first; itr != skillBounds.second; ++itr)
        if (!itr->second->learnOnGetSkill && IsPrimaryProfessionSkill(itr->second->skillId))
            if (!HasSkill(itr->second->skillId))
                if (!spellInfo->HasEffect(SPELL_EFFECT_SKILL))
                    return false;

    PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    bool dependent_set = false;
    bool disabled_case = false;
    bool superceded_old = false;

    PlayerSpellMap::iterator itr = m_spells.find(spellId);

    // Remove temporary spell if found to prevent conflicts
    if (itr != m_spells.end() && itr->second->state == PLAYERSPELL_TEMPORARY)
        RemoveTemporarySpell(spellId);
    else if (itr != m_spells.end())
    {
        uint32 next_active_spell_id = 0;
        // fix activate state for non-stackable low rank (and find next spell for !active case)
        if (spellInfo->IsRanked())
        {
            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
            {
                if (HasSpell(next))
                {
                    // high rank already known so this must !active
                    active = false;
                    next_active_spell_id = next;
                }
            }
        }

        // not do anything if already known in expected state
        if (itr->second->state != PLAYERSPELL_REMOVED && itr->second->active == active &&
            itr->second->dependent == dependent && itr->second->disabled == disabled)
        {
            if (!IsInWorld() && !learning)                   // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;

            return false;
        }

        // dependent spell known as not dependent, overwrite state
        if (itr->second->state != PLAYERSPELL_REMOVED && !itr->second->dependent && dependent)
        {
            itr->second->dependent = dependent;
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            dependent_set = true;
        }

        // update active state for known spell
        if (itr->second->active != active && itr->second->state != PLAYERSPELL_REMOVED && !itr->second->disabled)
        {
            itr->second->active = active;

            if (!IsInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
                itr->second->state = PLAYERSPELL_UNCHANGED;
            else if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;

            if (active)
            {
                if (spellInfo->IsPassive() && IsNeedCastPassiveSpellAtLearn(spellInfo))
                    CastSpell (this, spellId, true);
            }
            else if (IsInWorld())
            {
                if (next_active_spell_id)
                {
                    // update spell ranks in spellbook and action bar
                    WorldPacket data(SMSG_SUPERCEDED_SPELL);
                    data.WriteBits(1, 22);
                    data.WriteBits(1, 22);
                    data << uint32(spellId);
                    data << uint32(next_active_spell_id);
                    GetSession()->SendPacket(&data);
                }
                else
                {
                    WorldPacket data(SMSG_REMOVED_SPELL, 7);
                    data.WriteBits(1, 22); // Count
                    data << uint32(spellId);
                    GetSession()->SendPacket(&data);
                }
            }

            return active;                                  // learn (show in spell book if active now)
        }

        if (itr->second->disabled != disabled && itr->second->state != PLAYERSPELL_REMOVED)
        {
            if (itr->second->state != PLAYERSPELL_NEW)
                itr->second->state = PLAYERSPELL_CHANGED;
            itr->second->disabled = disabled;

            if (disabled)
                return false;

            disabled_case = true;
        }
        else switch (itr->second->state)
        {
            case PLAYERSPELL_UNCHANGED:                     // known saved spell
                return false;
            case PLAYERSPELL_REMOVED:                       // re-learning removed not saved spell
            {
                delete itr->second;
                m_spells.erase(itr);
                state = PLAYERSPELL_CHANGED;
                break;                                      // need re-add
            }
            default:                                        // known not saved yet spell (new or modified)
            {
                // can be in case spell loading but learned at some previous spell loading
                if (!IsInWorld() && !learning && !dependent_set)
                    itr->second->state = PLAYERSPELL_UNCHANGED;

                return false;
            }
        }
    }

    if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
    {
        // non talent spell: learn low ranks (recursive call)
        if (uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spellId))
        {
            if (!IsInWorld() || disabled)                    // at spells loading, no output, but allow save
                AddSpell(prev_spell, active, true, true, disabled);
            else                                            // at normal learning
                LearnSpell(prev_spell, true);
        }

        PlayerSpell* newspell = new PlayerSpell;
        newspell->state     = state;
        newspell->active    = active;
        newspell->dependent = dependent;
        newspell->disabled  = disabled;

        // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
        if (newspell->active && !newspell->disabled && spellInfo->IsRanked())
        {
            WorldPacket data(SMSG_SUPERCEDED_SPELL);
            uint32 bitCount = 0;
            ByteBuffer dataBuffer;
            for (PlayerSpellMap::iterator itr2 = m_spells.begin(); itr2 != m_spells.end(); ++itr2)
            {
                if (itr2->second->state == PLAYERSPELL_REMOVED)
                    continue;

                SpellInfo const* i_spellInfo = sSpellMgr->GetSpellInfo(itr2->first);
                if (!i_spellInfo)
                    continue;

                if (spellInfo->IsDifferentRankOf(i_spellInfo))
                {
                    if (itr2->second->active)
                    {
                        if (spellInfo->IsHighRankOf(i_spellInfo))
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                dataBuffer << uint32(spellId);
                                dataBuffer << uint32(itr2->first);
                            }

                            // mark old spell as disable (SMSG_SUPERCEDED_SPELL replace it in client by new)
                            itr2->second->active = false;
                            if (itr2->second->state != PLAYERSPELL_NEW)
                                itr2->second->state = PLAYERSPELL_CHANGED;
                            superceded_old = true;          // new spell replace old in action bars and spell book.
                        }
                        else
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                bitCount++;
                                dataBuffer << uint32(itr2->first);
                                dataBuffer << uint32(spellId);
                            }

                            // mark new spell as disable (not learned yet for client and will not learned)
                            newspell->active = false;
                            if (newspell->state != PLAYERSPELL_NEW)
                                newspell->state = PLAYERSPELL_CHANGED;
                        }
                    }
                }
            }
            data.WriteBits(bitCount, 22);
            data.WriteBits(bitCount, 22);
            data.FlushBits();
            if (dataBuffer.size())
                data.append(dataBuffer);
            GetSession()->SendPacket(&data);
        }

        m_spells[spellId] = newspell;

        // return false if spell disabled
        if (newspell->disabled)
            return false;
    }

    if (uint32 species = db2::GetBattlePetSpeciesFromSpell(spellId))
    {
        // Learn from spell only once, if for some reason we already have pet - skip
        if (GetBattlePetMgr().GetBattlePetCount(species))
            return false;

        GetBattlePetMgr().Create(species);
    }

    uint32 talentCost = GetTalentSpellCost(spellId);

    // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
    // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
    if (!loading && talentCost > 0 && spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
    {
        // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
        CastSpell(this, spellId, true);
    }
    // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
    else if (spellInfo->IsPassive())
    {
        if (IsNeedCastPassiveSpellAtLearn(spellInfo))
            CastSpell(this, spellId, true);
    }
    else if (spellInfo->HasEffect(SPELL_EFFECT_SKILL_STEP))
    {
        CastSpell(this, spellId, true);
        return false;
    }

    // update used talent points count
    SetUsedTalentCount(GetUsedTalentCount() + talentCost);

    // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
    if (uint32 freeProfs = GetFreePrimaryProfessionPoints())
    {
        if (spellInfo->IsPrimaryProfessionFirstRank())
            SetFreePrimaryProfessions(freeProfs-1);
    }

    // add dependent skills
    uint16 maxskill     = GetMaxSkillValueForLevel();

    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spellId);

    if (spellLearnSkill)
    {
        uint32 skill_value = GetPureSkillValue(spellLearnSkill->skill);
        uint32 skill_max_value = GetPureMaxSkillValue(spellLearnSkill->skill);

        if (skill_value < spellLearnSkill->value)
            skill_value = spellLearnSkill->value;

        uint32 new_skill_max_value = spellLearnSkill->maxvalue == 0 ? maxskill : spellLearnSkill->maxvalue;

        if (skill_max_value < new_skill_max_value)
            skill_max_value = new_skill_max_value;

        SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skill_value, skill_max_value);
    }
    else
    {
        // not ranked skills
        for (auto itr = skillBounds.first; itr != skillBounds.second; ++itr)
        {
            SkillLineEntry const* skill = sSkillLineStore.LookupEntry(itr->second->skillId);
            if (!skill)
                continue;

            if (HasSkill(skill->id))
                continue;

            if (itr->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL ||
                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
                ((skill->id == SKILL_LOCKPICKING || skill->id == SKILL_RUNEFORGING) && (itr->second->max_value == 0 || itr->second->max_value == 1)))
            {
                if (auto entry = GetSkillRaceClassInfo(skill->id, getRace(), getClass()))
                    LearnDefaultSkill(entry);
            }
        }
    }

    // learn dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spellId);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
    {
        if (!itr2->second.autoLearned)
        {
            if (!IsInWorld() || !itr2->second.active)       // at spells loading, no output, but allow save
                AddSpell(itr2->second.spell, itr2->second.active, true, true, false, loading);
            else                                            // at normal learning
                LearnSpell(itr2->second.spell, true);
        }
    }

    if (!GetSession()->PlayerLoading())
    {
        // not ranked skills
        for (auto itr = skillBounds.first; itr != skillBounds.second; ++itr)
        {
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LINE, itr->second->skillId);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILLLINE_SPELLS, itr->second->skillId);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SPELL, spellId);
    }

    // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
    return active && !disabled && !superceded_old;
}

void Player::AddTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already added - do not do anything
    if (itr != m_spells.end())
        return;
    PlayerSpell* newspell = new PlayerSpell;
    newspell->state     = PLAYERSPELL_TEMPORARY;
    newspell->active    = true;
    newspell->dependent = false;
    newspell->disabled  = false;
    m_spells[spellId]   = newspell;
}

void Player::RemoveTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::iterator itr = m_spells.find(spellId);
    // spell already not in list - do not do anything
    if (itr == m_spells.end())
        return;
    // spell has other state than temporary - do not change it
    if (itr->second->state != PLAYERSPELL_TEMPORARY)
        return;
    delete itr->second;
    m_spells.erase(itr);
}

bool Player::IsNeedCastPassiveSpellAtLearn(SpellInfo const* spellInfo) const
{
    // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
    // talent dependent passives activated at form apply have proper stance data
    ShapeshiftForm form = GetShapeshiftForm();
    bool need_cast = (!spellInfo->Stances || (form && (spellInfo->Stances & (1 << (form - 1)))) ||
        (!form && (spellInfo->AttributesEx2 & SPELL_ATTR2_NOT_NEED_SHAPESHIFT)));

    if (spellInfo->AttributesEx8 & SPELL_ATTR8_MASTERY_SPECIALIZATION)
        need_cast &= IsCurrentSpecMasterySpell(spellInfo);

    //Check CasterAuraStates
    return need_cast && (!spellInfo->CasterAuraState || HasAuraState(AuraStateType(spellInfo->CasterAuraState)));
}

bool Player::IsCurrentSpecMasterySpell(SpellInfo const* spellInfo) const
{
    if (ChrSpecializationEntry const* specialization = sChrSpecializationStore.LookupEntry(GetTalentSpecialization(GetActiveSpec())))
        return spellInfo->Id == specialization->MasterySpellId;

    return false;
}

void Player::LearnSpell(uint32 spell_id, bool dependent)
{
    PlayerSpellMap::iterator itr = m_spells.find(spell_id);

    bool disabled = (itr != m_spells.end()) ? itr->second->disabled : false;
    bool active = disabled ? itr->second->active : true;

    bool learning = AddSpell(spell_id, active, true, dependent, false);

    // prevent duplicated entires in spell book, also not send if not in world (loading)
    if (learning && IsInWorld())
    {
        WorldPacket data(SMSG_LEARNED_SPELL, 8);
        uint32 spellCount = 1;

        data.WriteBits(spellCount, 22);
        data.WriteBit(0);

        for (uint32 i = 0; i < spellCount; ++i)
            data << uint32(spell_id);

        GetSession()->SendPacket(&data);
    }

    // learn all disabled higher ranks and required spells (recursive)
    if (disabled)
    {
        if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
        {
            PlayerSpellMap::iterator iter = m_spells.find(nextSpell);
            if (iter != m_spells.end() && iter->second->disabled)
                LearnSpell(nextSpell, false);
        }

        SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
        for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
        {
            PlayerSpellMap::iterator iter2 = m_spells.find(itr2->second);
            if (iter2 != m_spells.end() && iter2->second->disabled)
                LearnSpell(itr2->second, false);
        }
    }
}

void Player::RemoveSpell(uint32 spell_id, bool disabled, bool learn_low_rank)
{
    PlayerSpellMap::iterator itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;

    if (itr->second->state == PLAYERSPELL_REMOVED || (disabled && itr->second->disabled) || itr->second->state == PLAYERSPELL_TEMPORARY)
        return;

    // unlearn non talent higher ranks (recursive)
    if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
    {
        if (HasSpell(nextSpell) && !GetTalentSpellPos(nextSpell))
            RemoveSpell(nextSpell, disabled, false);
    }
    //unlearn spells dependent from recently removed spells
    SpellsRequiringSpellMapBounds spellsRequiringSpell = sSpellMgr->GetSpellsRequiringSpellBounds(spell_id);
    for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequiringSpell.first; itr2 != spellsRequiringSpell.second; ++itr2)
        RemoveSpell(itr2->second, disabled);

    // re-search, it can be corrupted in prev loop
    itr = m_spells.find(spell_id);
    if (itr == m_spells.end())
        return;                                             // already unleared

    bool giveTalentPoints = disabled || !itr->second->disabled;

    bool cur_active    = itr->second->active;
    bool cur_dependent = itr->second->dependent;

    if (disabled)
    {
        itr->second->disabled = disabled;
        if (itr->second->state != PLAYERSPELL_NEW)
            itr->second->state = PLAYERSPELL_CHANGED;
    }
    else
    {
        if (itr->second->state == PLAYERSPELL_NEW)
        {
            delete itr->second;
            m_spells.erase(itr);
        }
        else
            itr->second->state = PLAYERSPELL_REMOVED;
    }

    RemoveOwnedAura(spell_id, GetGUID());

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);

    // remove pet auras and overrides
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (PetAura const* petSpell = sSpellMgr->GetPetAura(spell_id, i))
            RemovePetAura(petSpell);

        if (spellInfo)
            if (spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS || spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2)
                RemoveAurasDueToSpell(spellInfo->Effects[i].BasePoints);
    }

    while (AreaTrigger* atrigger = GetAreaTrigger(spell_id))
        atrigger->Remove();

    // free talent points
    uint32 talentCosts = GetTalentSpellCost(spell_id);
    if (talentCosts > 0 && giveTalentPoints)
    {
        if (talentCosts < GetUsedTalentCount())
            SetUsedTalentCount(GetUsedTalentCount() - talentCosts);
        else
            SetUsedTalentCount(0);
    }

    // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
    if (spellInfo && spellInfo->IsPrimaryProfessionFirstRank())
    {
        uint32 freeProfs = GetFreePrimaryProfessionPoints()+1;
        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
            SetFreePrimaryProfessions(freeProfs);
    }

    // remove dependent skill
    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spell_id);
    if (spellLearnSkill)
    {
        uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spell_id);
        if (!prev_spell)                                    // first rank, remove skill
            SetSkill(spellLearnSkill->skill, 0, 0, 0);
        else
        {
            // search prev. skill setting by spell ranks chain
            SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
            while (!prevSkill && prev_spell)
            {
                prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
                prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
            }

            if (!prevSkill)                                 // not found prev skill setting, remove skill
                SetSkill(spellLearnSkill->skill, 0, 0, 0);
            else                                            // set to prev. skill setting values
            {
                uint32 skill_value = GetPureSkillValue(prevSkill->skill);
                uint32 skill_max_value = GetPureMaxSkillValue(prevSkill->skill);

                if (skill_value > prevSkill->value)
                    skill_value = prevSkill->value;

                uint32 new_skill_max_value = prevSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : prevSkill->maxvalue;

                if (skill_max_value > new_skill_max_value)
                    skill_max_value = new_skill_max_value;

                SetSkill(prevSkill->skill, prevSkill->step, skill_value, skill_max_value);
            }
        }
    }
    else
    {
        // not ranked skills
        SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);

        for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
        {
            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->skillId);
            if (!pSkill)
                continue;

            if ((_spell_idx->second->learnOnGetSkill == ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL &&
                pSkill->categoryId != SKILL_CATEGORY_CLASS) ||// not unlearn class skills (spellbook/talent pages)
                // lockpicking/runeforging special case, not have ABILITY_LEARNED_ON_GET_RACE_OR_CLASS_SKILL
                ((pSkill->id == SKILL_LOCKPICKING || pSkill->id == SKILL_RUNEFORGING) && (_spell_idx->second->max_value == 0 || _spell_idx->second->max_value == 1)))
            {
                // not reset skills for professions and racial abilities
                if ((pSkill->categoryId == SKILL_CATEGORY_SECONDARY || pSkill->categoryId == SKILL_CATEGORY_PROFESSION) &&
                    (IsProfessionSkill(pSkill->id) || _spell_idx->second->racemask != 0))
                    continue;

                SetSkill(pSkill->id, GetSkillStep(pSkill->id), 0, 0);
            }
        }
    }

    // remove dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spell_id);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
        RemoveSpell(itr2->second.spell, disabled);

    // activate lesser rank in spellbook/action bar, and cast it if need
    bool prev_activate = false;

    if (uint32 prev_id = sSpellMgr->GetPrevSpellInChain(spell_id))
    {
        // if talent then lesser rank also talent and need learn
        if (talentCosts)
        {
            // I cannot see why mangos has these lines.
            //if (learn_low_rank)
            //    LearnSpell(prev_id, false);
        }
        // if ranked non-stackable spell: need activate lesser rank and update dendence state
        /// No need to check for spellInfo != NULL here because if cur_active is true, then that means that the spell was already in m_spells, and only valid spells can be pushed there.
        else if (cur_active && spellInfo->IsRanked())
        {
            // need manually update dependence state (learn spell ignore like attempts)
            PlayerSpellMap::iterator prev_itr = m_spells.find(prev_id);
            if (prev_itr != m_spells.end())
            {
                if (prev_itr->second->dependent != cur_dependent)
                {
                    prev_itr->second->dependent = cur_dependent;
                    if (prev_itr->second->state != PLAYERSPELL_NEW)
                        prev_itr->second->state = PLAYERSPELL_CHANGED;
                }

                // now re-learn if need re-activate
                if (cur_active && !prev_itr->second->active && learn_low_rank)
                {
                    if (AddSpell(prev_id, true, false, prev_itr->second->dependent, prev_itr->second->disabled))
                    {
                        // downgrade spell ranks in spellbook and action bar
                        WorldPacket data(SMSG_SUPERCEDED_SPELL);
                        data.WriteBits(1, 22);
                        data.WriteBits(1, 22);
                        data << uint32(spell_id);
                        data << uint32(prev_id);
                        GetSession()->SendPacket(&data);
                        prev_activate = true;
                    }
                }
            }
        }
    }

    if (spell_id == 46917 && m_canTitanGrip)
        SetCanTitanGrip(false);
    if (m_canDualWield)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
        if (spellInfo->IsPassive())
        {
            for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_DUAL_WIELD)
                {
                    SetCanDualWield(false);
                    break;
                }
        }
    }

    if (sWorld->getBoolConfig(CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN))
        AutoUnequipOffhandIfNeed();

    // remove from spell book if not replaced by lesser rank
    if (!prev_activate)
    {
        WorldPacket data(SMSG_REMOVED_SPELL, 7);
        data.WriteBits(1, 22); // Count
        data << uint32(spell_id);
        GetSession()->SendPacket(&data);
    }
}

void Player::RemoveSpellCooldown(uint32 spell_id, bool update /* = false */)
{
    GetSpellHistory()->RemoveCooldown(spell_id, update);
}

void Player::RemoveArenaSpellCooldowns(bool removeActivePetCooldowns)
{
    GetSpellHistory()->RemoveArenaSpellCooldowns(removeActivePetCooldowns);
}

void Player::RemoveAllSpellCooldown()
{
    GetSpellHistory()->RemoveAllCooldowns();
}

uint32 Player::GetNextResetSpecializationCost() const
{
    // The first time reset costs 1 gold
    if (GetSpecializationResetCost() < 1 * GOLD)
        return 1 * GOLD;
    // then 5 gold
    else if (GetSpecializationResetCost() < 5 * GOLD)
        return 5 * GOLD;
    // After that it increases in increments of 5 gold
    else if (GetSpecializationResetCost() < 10 * GOLD)
        return 10 * GOLD;
    else
    {
        uint64 months = (sWorld->GetGameTime() - GetSpecializationResetTime()) / MONTH;
        if (months > 0)
        {
            // This cost will be reduced by a rate of 5 gold per month
            int32 new_cost = int32(GetSpecializationResetCost() - 5 * GOLD*months);
            // to a minimum of 10 gold.
            return (new_cost < 10 * GOLD ? 10 * GOLD : new_cost);
        }
        else
        {
            // After that it increases in increments of 5 gold
            int32 new_cost = GetSpecializationResetCost() + 5 * GOLD;
            // until it hits a cap of 50 gold.
            if (new_cost > 50 * GOLD)
                new_cost = 50 * GOLD;
            return new_cost;
        }
    }
}

uint32 Player::GetNextResetTalentsCost() const
{
    // The first time reset costs 1 gold
    if (GetTalentResetCost() < 1*GOLD)
        return 1*GOLD;
    // then 5 gold
    else if (GetTalentResetCost() < 5*GOLD)
        return 5*GOLD;
    // After that it increases in increments of 5 gold
    else if (GetTalentResetCost() < 10*GOLD)
        return 10*GOLD;
    else
    {
        uint64 months = (sWorld->GetGameTime() - GetTalentResetTime())/MONTH;
        if (months > 0)
        {
            // This cost will be reduced by a rate of 5 gold per month
            int32 new_cost = int32(GetTalentResetCost() - 5*GOLD*months);
            // to a minimum of 10 gold.
            return (new_cost < 10*GOLD ? 10*GOLD : new_cost);
        }
        else
        {
            // After that it increases in increments of 5 gold
            int32 new_cost = GetTalentResetCost() + 5*GOLD;
            // until it hits a cap of 50 gold.
            if (new_cost > 50*GOLD)
                new_cost = 50*GOLD;
            return new_cost;
        }
    }
}

bool Player::ResetTalents(bool noCost, bool resetTalents, bool resetSpecialization)
{
    if (!resetTalents && !resetSpecialization)
        return false;

    // Shouldn't happen
    if (!noCost && resetTalents && resetSpecialization)
        return false;

    if (resetSpecialization)
        LeaveFromSoloQueueIfNeed();

    sScriptMgr->OnPlayerTalentsReset(this, noCost);

    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_TALENTS, true);

    uint32 cost = 0;

    if (!noCost && !sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST))
    {
        cost = resetTalents ? GetNextResetTalentsCost() : GetNextResetSpecializationCost();

        if (!HasEnoughMoney(uint64(cost)))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
            return false;
        }
    }

    RemovePet(PET_REMOVE_DISMISS, PET_REMOVE_FLAG_RETURN_REAGENT | PET_REMOVE_FLAG_RESET_CURRENT);

    if (resetTalents)
    {
        for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
        {
            TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);

            if (!talentInfo)
                continue;

            if (talentInfo->PlayerClass != getClass())
                continue;

            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(talentInfo->SpellId);
            if (!spellEntry)
                continue;

            RemoveSpell(talentInfo->SpellId, true);

            // search for spells that the talent teaches and unlearn them
            for (auto&& spellEffect : spellEntry->Effects)
                if (spellEffect.TriggerSpell > 0 && spellEffect.Effect == SPELL_EFFECT_LEARN_SPELL)
                    RemoveSpell(spellEffect.TriggerSpell, true);
        }
        for (auto&& it : *GetTalentMap(GetActiveSpec()))
            it.second->state = PLAYERSPELL_REMOVED;
    }

    if (resetSpecialization)
    {
        RemoveSpecializationSpells();
        SetTalentSpecialization(GetActiveSpec(), SPEC_NONE);
        SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, 0);
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveTalents(trans);
    _SaveSpells(trans);
    CharacterDatabase.CommitTransaction(trans);

    if (!noCost)
    {
        ModifyMoney(-(int64)cost);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, cost);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);

        if (resetTalents)
            SetTalentResetCost(cost);
        else
            SetSpecializationResetCost(cost);
        
        SetTalentResetTime(time(NULL));
    }

    return true;
}

bool Player::RemoveTalent(uint32 talentId)
{
    TalentEntry const* talent = sTalentStore.LookupEntry(talentId);
    if (!talent)
        return false;

    uint32 spellId = talent->SpellId;

    SpellInfo const* unlearnSpellProto = sSpellMgr->GetSpellInfo(spellId);

    RemoveSpell(spellId, true);

    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
        if (unlearnSpellProto->Effects[i].TriggerSpell > 0 && unlearnSpellProto->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL)
            RemoveSpell(unlearnSpellProto->Effects[i].TriggerSpell, true);

    PlayerTalentMap::iterator itr = GetTalentMap(GetActiveSpec())->find(spellId);
    if (itr != GetTalentMap(GetActiveSpec())->end())
        itr->second->state = PLAYERSPELL_REMOVED;

    // Needs to be executed orthewise the talents will be screwedsx
    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveTalents(trans);
    _SaveSpells(trans);
    CharacterDatabase.CommitTransaction(trans);

    SendTalentsInfoData();
    return true;
}

Roles Player::GetRoleForGroup(uint32 specializationId)
{
    Roles roleId = ROLES_DEFAULT;

    switch (specializationId)
    {
        case SPEC_MAGE_FROST:
        case SPEC_MAGE_FIRE:
        case SPEC_MAGE_ARCANE:
        case SPEC_ROGUE_COMBAT:
        case SPEC_ROGUE_ASSASSINATION:
        case SPEC_ROGUE_SUBTLETY:
        case SPEC_HUNTER_BEAST_MASTERY:
        case SPEC_HUNTER_MARKSMANSHIP:
        case SPEC_HUNTER_SURVIVAL:
        case SPEC_WARLOCK_AFFLICTION:
        case SPEC_WARLOCK_DEMONOLOGY:
        case SPEC_WARLOCK_DESTRUCTION:
        case SPEC_PRIEST_SHADOW:
        case SPEC_DEATH_KNIGHT_FROST:
        case SPEC_DEATH_KNIGHT_UNHOLY:
        case SPEC_MONK_WINDWALKER:
        case SPEC_PALADIN_RETRIBUTION:
        case SPEC_SHAMAN_ELEMENTAL:
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_WARRIOR_ARMS:
        case SPEC_WARRIOR_FURY:
        case SPEC_DRUID_BALANCE:
        case SPEC_DRUID_FERAL:
            roleId = ROLES_DPS;
            break;
        case SPEC_MONK_MISTWEAVER:
        case SPEC_PALADIN_HOLY:
        case SPEC_PRIEST_DISCIPLINE:
        case SPEC_PRIEST_HOLY:
        case SPEC_SHAMAN_RESTORATION:
        case SPEC_DRUID_RESTORATION:
            roleId = ROLES_HEALER;
            break;
        case SPEC_MONK_BREWMASTER:
        case SPEC_DEATH_KNIGHT_BLOOD:
        case SPEC_WARRIOR_PROTECTION:
        case SPEC_DRUID_GUARDIAN:
        case SPEC_PALADIN_PROTECTION:
            roleId = ROLES_TANK;
            break;
        default: // SPEC_NONE
            roleId = ROLES_DEFAULT;
            break;
    }

    return roleId;
}

Mail* Player::GetMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        if ((*itr)->messageID == id)
            return (*itr);

    return NULL;
}

void Player::BuildCreateUpdateBlockForPlayer(UpdateData* data, Player* target) const
{
    if (target == this)
    {
        for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
        }
    }

    Unit::BuildCreateUpdateBlockForPlayer(data, target);
}

void Player::DestroyForPlayer(Player* target, bool onDeath) const
{
    Unit::DestroyForPlayer(target, onDeath);

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] == NULL)
            continue;

        m_items[i]->DestroyForPlayer(target);
    }

    if (target == this)
    {
        for (uint8 i = INVENTORY_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        {
            if (m_items[i] == NULL)
                continue;

            m_items[i]->DestroyForPlayer(target);
        }
    }
}

bool Player::HasSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        !itr->second->disabled);
}

bool Player::HasTalent(uint32 spell, uint8 spec) const
{
    PlayerTalentMap::const_iterator itr = GetTalentMap(spec)->find(spell);
    return (itr != GetTalentMap(spec)->end() && itr->second->state != PLAYERSPELL_REMOVED);
}

bool Player::HasActiveSpell(uint32 spell) const
{
    PlayerSpellMap::const_iterator itr = m_spells.find(spell);
    return (itr != m_spells.end() && itr->second->state != PLAYERSPELL_REMOVED &&
        itr->second->active && !itr->second->disabled);
}

TrainerSpellState Player::GetTrainerSpellState(TrainerSpell const* trainer_spell) const
{
    if (!trainer_spell)
        return TRAINER_SPELL_RED;

    bool hasSpell = true;
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        if (!HasSpell(trainer_spell->learnedSpell[i]))
        {
            hasSpell = false;
            break;
        }
    }
    // known spell
    if (hasSpell)
        return TRAINER_SPELL_GRAY;

    // check skill requirement
    if (trainer_spell->reqSkill && GetBaseSkillValue(trainer_spell->reqSkill) < trainer_spell->reqSkillValue)
        return TRAINER_SPELL_RED;

    // check level requirement
    if (getLevel() < trainer_spell->reqLevel)
        return TRAINER_SPELL_RED;

    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        // check race/class requirement
        if (!IsSpellFitByClassAndRace(trainer_spell->learnedSpell[i]))
            return TRAINER_SPELL_RED;

        if (uint32 prevSpell = sSpellMgr->GetPrevSpellInChain(trainer_spell->learnedSpell[i]))
        {
            // check prev.rank requirement
            if (prevSpell && !HasSpell(prevSpell))
                return TRAINER_SPELL_RED;
        }

        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(trainer_spell->learnedSpell[i]);
        for (SpellsRequiringSpellMap::const_iterator itr = spellsRequired.first; itr != spellsRequired.second; ++itr)
        {
            // check additional spell requirement
            if (!HasSpell(itr->second))
                return TRAINER_SPELL_RED;
        }
    }

    // check primary prof. limit
    // first rank of primary profession spell when there are no proffesions avalible is disabled
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;
        SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[i]);

        if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank() && (GetFreePrimaryProfessionPoints() == 0))
            return TRAINER_SPELL_GREEN_DISABLED;
    }

    return TRAINER_SPELL_GREEN;
}

/**
 * Deletes a character from the database
 *
 * The way characters will be deleted is decided based on the config option.
 *
 * @see Player::DeleteOldCharacters
 *
 * @param playerguid       the low-GUID from the player which should be deleted
 * @param accountId        the account id from the player
 * @param updateRealmChars when this flag is set, the amount of characters on that realm will be updated in the realmlist
 * @param deleteFinally    if this flag is set, the config option will be ignored and the character will be permanently removed from the database
 */
void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmChars, bool deleteFinally)
{
    // Avoid realm-update for non-existing account
    if (accountId == 0)
        updateRealmChars = false;

    // Convert guid to low GUID for CharacterNameData, but also other methods on success
    uint32 guid = GUID_LOPART(playerguid);
    uint32 charDelete_method = sWorld->getIntConfig(CONFIG_CHARDELETE_METHOD);

    if (deleteFinally)
        charDelete_method = CHAR_DELETE_REMOVE;
    else if (CharacterNameData const* nameData = sWorld->GetCharacterNameData(guid))    // To avoid a query, we select loaded data. If it doesn't exist, return.
    {
        // Define the required variables
        uint32 charDelete_minLvl = sWorld->getIntConfig(nameData->m_class != CLASS_DEATH_KNIGHT ? CONFIG_CHARDELETE_MIN_LEVEL : CONFIG_CHARDELETE_HEROIC_MIN_LEVEL);

        // if we want to finalize the character removal or the character does not meet the level requirement of either heroic or non-heroic settings,
        // we set it to mode CHAR_DELETE_REMOVE
        if (nameData->m_level < charDelete_minLvl)
            charDelete_method = CHAR_DELETE_REMOVE;
    }

    // convert corpse to bones if exist (to prevent exiting Corpse in World without DB entry)
    // bones will be deleted by corpse/bones deleting thread shortly
    sObjectAccessor->ConvertCorpseForPlayer(playerguid);

    if (uint32 guildId = GetGuildIdFromDB(playerguid))
        if (Guild* guild = sGuildMgr->GetGuildById(guildId))
            guild->DeleteMember(guid, false, false, true);

    // the player was uninvited already on logout so just remove from group
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
    stmt->setUInt32(0, guid);
    PreparedQueryResult resultGroup = CharacterDatabase.Query(stmt);

    if (resultGroup)
        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*resultGroup)[0].GetUInt32()))
            RemoveFromGroup(group, playerguid);

    // Remove signs from petitions (also remove petitions if owner);
    RemovePetitionsAndSigns(playerguid, 10);

    switch (charDelete_method)
    {
        // Completely remove from the database
        case CHAR_DELETE_REMOVE:
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);

            if (resultMail)
            {
                do
                {
                    Field* mailFields = resultMail->Fetch();

                    uint32 mail_id       = mailFields[0].GetUInt32();
                    uint8 mailType       = mailFields[1].GetUInt8();
                    uint16 mailTemplateId= mailFields[2].GetUInt16();
                    uint32 sender        = mailFields[3].GetUInt32();
                    std::string subject  = mailFields[4].GetString();
                    std::string body     = mailFields[5].GetString();
                    uint64 money         = mailFields[6].GetUInt64();
                    bool has_items       = mailFields[7].GetBool();

                    // We can return mail now
                    // So firstly delete the old one
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    // Mail is not from player
                    if (mailType != MAIL_NORMAL)
                    {
                        if (has_items)
                        {
                            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                            stmt->setUInt32(0, mail_id);
                            trans->Append(stmt);
                        }
                        continue;
                    }

                    MailDraft draft(subject, body);
                    if (mailTemplateId)
                        draft = MailDraft(mailTemplateId, false);    // items are already included

                    if (has_items)
                    {
                        // Data needs to be at first place for Item::LoadFromDB
                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
                        stmt->setUInt32(0, mail_id);
                        PreparedQueryResult resultItems = CharacterDatabase.Query(stmt);
                        if (resultItems)
                        {
                            do
                            {
                                Field* itemFields = resultItems->Fetch();
                                uint32 item_guidlow = itemFields[18].GetUInt32();
                                uint32 item_template = itemFields[19].GetUInt32();

                                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
                                if (!itemProto)
                                {
                                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                                    stmt->setUInt32(0, item_guidlow);
                                    trans->Append(stmt);
                                    continue;
                                }

                                Item* pItem = NewItemOrBag(itemProto);
                                if (!pItem->LoadFromDB(item_guidlow, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER), itemFields, item_template))
                                {
                                    pItem->FSetState(ITEM_REMOVED);
                                    pItem->SaveToDB(trans);              // it also deletes item object!
                                    continue;
                                }

                                draft.AddItem(pItem);
                            }
                            while (resultItems->NextRow());
                        }
                    }

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    uint32 pl_account = sObjectMgr->GetPlayerAccountIdByGUID(MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

                    draft.AddMoney(money).SendReturnToSender(pl_account, guid, sender, trans);
                }
                while (resultMail->NextRow());
            }

            // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
            // NOW we can finally clear other DB data related to character
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);

            if (resultPets)
            {
                do
                {
                    uint32 petguidlow = (*resultPets)[0].GetUInt32();
                    Pet::DeleteFromDB(petguidlow);
                } while (resultPets->NextRow());
            }

            // Delete char from social list of online chars
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_SOCIAL);
            stmt->setUInt32(0, guid);
            PreparedQueryResult resultFriends = CharacterDatabase.Query(stmt);

            if (resultFriends)
            {
                do
                {
                    if (Player* pFriend = ObjectAccessor::FindPlayer(MAKE_NEW_GUID((*resultFriends)[0].GetUInt32(), 0, HIGHGUID_PLAYER)))
                    {
                        if (pFriend->IsInWorld())
                        {
                            pFriend->GetSocial()->RemoveFromSocialList(guid, false);
                            sSocialMgr->SendFriendStatus(pFriend, FRIEND_REMOVED, guid, false);
                        }
                    }
                } while (resultFriends->NextRow());
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE_ALL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENT_PROGRESS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            stmt->setUInt32(1, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_CURRENCY);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_DESERTER_INFO);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BATTLEGROUND_STATS);
            stmt->setUInt32(0, guid);
            trans->Append(stmt);

            CharacterDatabase.CommitTransaction(trans);
            break;
        }
        // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
        case CHAR_DELETE_UNLINK:
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_DELETE_INFO);

            stmt->setUInt32(0, guid);

            CharacterDatabase.Execute(stmt);
            break;
        }
        default:
            TC_LOG_ERROR("entities.player", "Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
            return;
    }

    if (updateRealmChars)
        sWorld->UpdateRealmCharCount(accountId);

    sWorld->DeleteCharacterNameData(guid);
}

/**
 * Characters which were kept back in the database after being deleted and are now too old (see config option "CharDelete.KeepDays"), will be completely deleted.
 *
 * @see Player::DeleteFromDB
 */
void Player::DeleteOldCharacters(bool startup)
{
    uint32 keepDays = sWorld->getIntConfig(CONFIG_CHARDELETE_KEEP_DAYS);
    if (!keepDays)
        return;

    Player::DeleteOldCharacters(keepDays, startup);
}

/**
 * Characters which were kept back in the database after being deleted and are older than the specified amount of days, will be completely deleted.
 *
 * @see Player::DeleteFromDB
 *
 * @param keepDays overrite the config option by another amount of days
 */
void Player::DeleteOldCharacters(uint32 keepDays, bool startup)
{
    TC_LOG_INFO("entities.player", "Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));

    // special for deleted items
    CharacterDatabase.PQuery("DELETE FROM item_deleted WHERE delete_date IS NOT NULL AND delete_date < '%u'", uint32(time(NULL) - time_t(sWorld->getIntConfig(CONFIG_DELETING_ITEM_KEEP_DAYS) * DAY)));

    if (startup)
    {
        PreparedQueryResult result = CharacterDatabase.Query(stmt);
        if (result)
        {
            TC_LOG_DEBUG("entities.player", "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
            do
            {
                Field* fields = result->Fetch();
                Player::DeleteFromDB(fields[0].GetUInt32(), fields[1].GetUInt32(), true, true);
            } while (result->NextRow());
        }
    }
    else
    {
        CharacterDatabase.Async(stmt)->ContinueWith(
            [](PreparedQueryResult&& result)
        {
            if (!result)
                return;
            
            TC_LOG_DEBUG("entities.player", "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
            do
            {
                Field* fields = result->Fetch();
                uint32 guid = fields[0].GetUInt32();
                uint32 acc = fields[1].GetUInt32();
                TaskMgr::Default()->ScheduleInvocation([=]
                {
                    Player::DeleteFromDB(guid, acc, true, true);
                });
            } while (result->NextRow());
        });
    }
}

/* Preconditions:
  - a resurrectable corpse must not be loaded for the player (only bones)
  - the player must be in world
*/
void Player::BuildPlayerRepop()
{
    ObjectGuid guid;
    WorldPacket data(SMSG_PRE_RESURRECT, 8);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[4]);

    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[3]);
    GetSession()->SendPacket(&data);

    if (getRace() == RACE_NIGHTELF)
        CastSpell(this, 20584, true);
    CastSpell(this, 8326, true);

    // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
    // there must be SMSG.STOP_MIRROR_TIMER
    // there we must send 888 opcode

    // the player cannot have a corpse already, only bones which are not returned by GetCorpse
    if (GetCorpse())
    {
        TC_LOG_ERROR("entities.player", "BuildPlayerRepop: player %s(%d) already has a corpse", GetName().c_str(), GetGUIDLow());
        return;
    }

    // create a corpse and place it at the player's location
    CreateCorpse();
    Corpse* corpse = GetCorpse();
    if (!corpse)
    {
        TC_LOG_ERROR("entities.player", "Error creating corpse for Player %s [%u]", GetName().c_str(), GetGUIDLow());
        return;
    }
    GetMap()->AddToMap(corpse);

    // convert player body to ghost
    SetHealth(1);

    SetWaterWalking(true);
    if (!GetSession()->isLogingOut() && !HasUnitState(UNIT_STATE_STUNNED))
        SetRooted(false);

    // BG - remove insignia related
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);

//    SendCorpseReclaimDelay();

    // to prevent cheating
    corpse->ResetGhostTime();

    StopMirrorTimers();                                     //disable timers(bars)

    // set and clear other
    SetAnimationTier(UnitAnimationTier::Ground);
}

void Player::ResurrectPlayer(float restore_percent, bool applySickness)
{
    WorldPacket data(SMSG_DEATH_RELEASE_LOC, 4 * 4);          // remove spirit healer position
    data << uint32(-1);
    data << float(0);
    data << float(0);
    data << float(0);
    GetSession()->SendPacket(&data);

    // speed change, land walk

    // remove death flag + set aura
    SetAnimationTier(UnitAnimationTier::Ground);
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
    if (getRace() == RACE_NIGHTELF)
        RemoveAurasDueToSpell(20584);                       // speed bonuses
    RemoveAurasDueToSpell(8326);                            // SPELL_AURA_GHOST
    RemoveAurasDueToSpell(84559);                           // The Quick and the Dead

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    setDeathState(ALIVE);

    SetWaterWalking(false, true);
    if (!HasUnitState(UNIT_STATE_STUNNED))
        SetRooted(false);

    m_deathTimer = 0;

    // set health/powers (0- will be set in caller)
    if (restore_percent > 0.0f)
    {
        SetHealth(uint32(GetMaxHealth()*restore_percent));
        SetPower(POWER_MANA, uint32(GetMaxPower(POWER_MANA)*restore_percent));
        SetPower(POWER_RAGE, 0);
        SetPower(POWER_ENERGY, uint32(GetMaxPower(POWER_ENERGY)*restore_percent));
        SetPower(POWER_FOCUS, uint32(GetMaxPower(POWER_FOCUS)*restore_percent));
        SetPower(POWER_ECLIPSE, 0);
    }

    // trigger update zone for alive state zone updates
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea);
    UpdateZone(newzone, newarea);
    sOutdoorPvPMgr->HandlePlayerResurrects(this, newzone);

    if (InBattleground())
    {
        if (Battleground* bg = GetBattleground())
            bg->HandlePlayerResurrect(this);
    }

    // update visibility
    UpdateObjectVisibility();

    UpdatePromotionAuras();

    if (!applySickness)
        return;

    //Characters from level 1-10 are not affected by resurrection sickness.
    //Characters from level 11-19 will suffer from one minute of sickness
    //for each level they are above 10.
    //Characters level 20 and up suffer from ten minutes of sickness.
    int32 startLevel = sWorld->getIntConfig(CONFIG_DEATH_SICKNESS_LEVEL);

    if (int32(getLevel()) >= startLevel)
    {
        // set resurrection sickness
        CastSpell(this, 15007, true);

        // not full duration
        if (int32(getLevel()) < startLevel+9)
        {
            int32 delta = (int32(getLevel()) - startLevel + 1)*MINUTE;

            if (Aura* aur = GetAura(15007, GetGUID()))
            {
                aur->SetDuration(delta*IN_MILLISECONDS);
            }
        }
    }
}

void Player::KillPlayer()
{
    if (IsFlying() && !GetTransport())
        GetMotionMaster()->MoveFall();

    SetRooted(true);

    StopMirrorTimers();                                     //disable timers(bars)

    setDeathState(CORPSE);
    //SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);

    SetUInt32Value(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
    ApplyModFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_FIELD_BYTE_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION));

    // 6 minutes until repop at graveyard
    m_deathTimer = 6 * MINUTE * IN_MILLISECONDS;

    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
    //SendCorpseReclaimDelay();

    // don't create corpse at this moment, player might be falling

    // update visibility
    UpdateObjectVisibility();
}

void Player::CreateCorpse()
{
    // prevent existence 2 corpse for player
    SpawnCorpseBones();

    uint32 _uf, _pb, _pb2, _cfb1, _cfb2;

    Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
    SetPvPDeath(false);

    if (!corpse->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_CORPSE), this))
    {
        delete corpse;
        return;
    }

    _uf = getRace();
    _pb = GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID);
    _pb2 = GetUInt32Value(PLAYER_FIELD_REST_STATE);

    uint8 race       = (uint8)(_uf);
    uint8 skin       = (uint8)(_pb);
    uint8 face       = (uint8)(_pb >> 8);
    uint8 hairstyle  = (uint8)(_pb >> 16);
    uint8 haircolor  = (uint8)(_pb >> 24);
    uint8 facialhair = (uint8)(_pb2);

    _cfb1 = ((0x00) | (race << 8) | (getGender() << 16) | (skin << 24));
    _cfb2 = ((face) | (hairstyle << 8) | (haircolor << 16) | (facialhair << 24));

    corpse->SetUInt32Value(CORPSE_FIELD_SKIN_ID, _cfb1);
    corpse->SetUInt32Value(CORPSE_FIELD_FACIAL_HAIR_STYLE_ID, _cfb2);

    uint32 flags = CORPSE_FLAG_UNK2;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM))
        flags |= CORPSE_FLAG_HIDE_HELM;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
        flags |= CORPSE_FLAG_HIDE_CLOAK;
    if (InBattleground() && !InArena())
        flags |= CORPSE_FLAG_LOOTABLE;                      // to be able to remove insignia

    corpse->SetUInt32Value(CORPSE_FIELD_FLAGS, flags);
    corpse->SetUInt32Value(CORPSE_FIELD_DISPLAY_ID, GetNativeDisplayId());

    uint32 iDisplayID;
    uint32 iIventoryType;
    uint32 _cfi;
    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; i++)
    {
        if (m_items[i])
        {
            iDisplayID = m_items[i]->GetTemplate()->DisplayInfoID;
            iIventoryType = m_items[i]->GetTemplate()->InventoryType;

            _cfi = iDisplayID | (iIventoryType << 24);
            corpse->SetUInt32Value(CORPSE_FIELD_ITEMS + i, _cfi);
        }
    }

    // we do not need to save corpses for BG/arenas
    if (!GetMap()->IsBattlegroundOrArena())
        corpse->SaveToDB();

    // register for player, but not show
    sObjectAccessor->AddCorpse(corpse);
}

void Player::SpawnCorpseBones()
{
    if (sObjectAccessor->ConvertCorpseForPlayer(GetGUID()))
        if (!GetSession()->PlayerLogoutWithSave())          // at logout we will already store the player
            SaveToDB();                                     // prevent loading as ghost without corpse
}

Corpse* Player::GetCorpse() const
{
    return sObjectAccessor->GetCorpseForPlayerGUID(GetGUID());
}

void Player::DurabilityLossAll(double percent, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityLoss(pItem, percent);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityLoss(pItem, percent);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = GetBagByPos(i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityLoss(pItem, percent);
    }
}

void Player::DurabilityLoss(Item* item, double percent)
{
    if (!item)
        return;

    uint32 pMaxDurability = item ->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);

    if (!pMaxDurability)
        return;

    percent /= GetTotalAuraMultiplier(SPELL_AURA_MOD_DURABILITY_LOSS);

    uint32 pDurabilityLoss = uint32(pMaxDurability*percent);

    if (pDurabilityLoss < 1)
        pDurabilityLoss = 1;

    DurabilityPointsLoss(item, pDurabilityLoss);
}

void Player::DurabilityPointsLossAll(int32 points, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityPointsLoss(pItem, points);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityPointsLoss(pItem, points);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityPointsLoss(pItem, points);
    }
}

void Player::DurabilityPointsLoss(Item* item, int32 points)
{
    if (GetMap()->IsChallengeDungeon())
        return;

    int32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    int32 pOldDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
    int32 pNewDurability = pOldDurability - points;

    if (pNewDurability < 0)
        pNewDurability = 0;
    else if (pNewDurability > pMaxDurability)
        pNewDurability = pMaxDurability;

    if (pOldDurability != pNewDurability)
    {
        // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
        if (pNewDurability == 0 && pOldDurability > 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), false);

        item->SetUInt32Value(ITEM_FIELD_DURABILITY, pNewDurability);

        // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
        if (pNewDurability > 0 && pOldDurability == 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), true);

        item->SetState(ITEM_CHANGED, this);
    }
}

void Player::DurabilityPointLossForEquipSlot(EquipmentSlots slot)
{
    if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
        DurabilityPointsLoss(pItem, 1);
}

uint32 Player::DurabilityRepairAll(bool cost, float discountMod, bool guildBank)
{
    uint32 TotalCost = 0;
    // equipped, backpack, bags itself
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        TotalCost += DurabilityRepair(((INVENTORY_SLOT_BAG_0 << 8) | i), cost, discountMod, guildBank);

    // bank, buyback and keys not repaired

    // items in inventory bags
    for (uint8 j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; j++)
        for (uint8 i = 0; i < MAX_BAG_SIZE; i++)
            TotalCost += DurabilityRepair(((j << 8) | i), cost, discountMod, guildBank);
    return TotalCost;
}

uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank)
{
    Item* item = GetItemByPos(pos);

    uint32 TotalCost = 0;
    if (!item)
        return TotalCost;

    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    if (!maxDurability)
        return TotalCost;

    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);

    if (cost)
    {
        uint32 LostDurability = maxDurability - curDurability;
        if (LostDurability>0)
        {
            ItemTemplate const* ditemProto = item->GetTemplate();

            DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
            if (!dcost)
            {
                TC_LOG_ERROR("entities.player.items", "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
                return TotalCost;
            }

            uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
            DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
            if (!dQualitymodEntry)
            {
                TC_LOG_ERROR("entities.player.items", "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
                return TotalCost;
            }

            uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
            uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));

            costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));

            if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                costs = 1;

            if (guildBank)
            {
                if (GetGuildId() == 0)
                {
                    TC_LOG_DEBUG("entities.player.items", "You are not member of a guild");
                    return TotalCost;
                }

                Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
                if (!guild)
                    return TotalCost;

                if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
                    return TotalCost;

                TotalCost = costs;
            }
            else if (!HasEnoughMoney(uint64(costs)))
            {
                TC_LOG_DEBUG("entities.player.items", "You do not have enough money");
                return TotalCost;
            }
            else
                ModifyMoney(-int64(costs));
        }
    }

    item->SetUInt32Value(ITEM_FIELD_DURABILITY, maxDurability);
    item->SetState(ITEM_CHANGED, this);

    // reapply mods for total broken and repaired item if equipped
    if (IsEquipmentPos(pos) && !curDurability)
        _ApplyItemMods(item, pos & 255, true);
    return TotalCost;
}

void Player::RepopAtGraveyard()
{
    // note: this can be called also when the player is alive
    // for example from WorldSession::HandleMovementOpcodes

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(GetAreaId());

    // Such zones are considered unreachable as a ghost and the player must be automatically revived
    if ((!IsAlive() && zone && zone->flags & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < (zone ? zone->MaxDepth : -500.0f))
    {
        ResurrectPlayer(0.5f);
        SpawnCorpseBones();
    }

    WorldSafeLocsEntry const* ClosestGrave = NULL;

    // Special handle for battleground maps
    if (Battleground* bg = GetBattleground())
        ClosestGrave = bg->GetClosestGraveYard(this);
    else
    {
        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(GetZoneId()))
            ClosestGrave = bf->GetClosestGraveYard(this);
        else
            ClosestGrave = sObjectMgr->GetClosestGraveYard(*this, GetTeam(), this);
    }

    // stop countdown until repop
    m_deathTimer = 0;

    // if no grave found, stay at the current location
    // and don't show spirit healer location
    if (ClosestGrave)
    {
        float const* orientation = sObjectMgr->GetGraveyardOrientation(ClosestGrave->ID);
        TeleportTo(ClosestGrave->map_id, ClosestGrave->x, ClosestGrave->y, ClosestGrave->z, orientation ? *orientation : GetOrientation());
        if (isDead())                                        // not send if alive, because it used in TeleportTo()
        {
            WorldPacket data(SMSG_DEATH_RELEASE_LOC, 4 * 4);  // show spirit healer position on minimap
            data << ClosestGrave->map_id;
            data << ClosestGrave->y;
            data << ClosestGrave->x;
            data << ClosestGrave->z;
            GetSession()->SendPacket(&data);
        }
    }
    else if (GetPositionZ() < GetMap()->GetMinHeight(GetPositionX(), GetPositionY()))
        TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());

    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
}

bool Player::CanJoinConstantChannelInZone(ChatChannelsEntry const* channel, AreaTableEntry const* zone)
{
    // Player can join LFG anywhere
    if (channel->flags & CHANNEL_DBC_FLAG_LFG)
        return true;

    if (channel->flags & CHANNEL_DBC_FLAG_ZONE_DEP && zone->flags & AREA_FLAG_ARENA_INSTANCE)
        return false;

    if ((channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY) && (!(zone->flags & AREA_FLAG_SLAVE_CAPITAL)))
        return false;

    if ((channel->flags & CHANNEL_DBC_FLAG_GUILD_REQ) && GetGuildId())
        return false;

    return true;
}

void Player::JoinedChannel(Channel* c)
{
    m_channels.push_back(c);
}

void Player::LeftChannel(Channel* c)
{
    m_channels.remove(c);
}

void Player::CleanupChannels()
{
    while (!m_channels.empty())
    {
        Channel* ch = *m_channels.begin();
        m_channels.erase(m_channels.begin());               // remove from player's channel list
        ch->LeaveChannel(this, false);                     // not send to client, not remove from player's channel list
        if (ChannelMgr* cMgr = ChannelMgr::forTeam(GetTeam()))
            cMgr->LeftChannel(ch->GetName());               // deleted channel if empty
    }
    TC_LOG_DEBUG("chat.system", "Player %s: channels cleaned up!", GetName().c_str());
}

void Player::UpdateLocalChannels(uint32 newZone)
{
    if (GetSession()->PlayerLoading() && !IsBeingTeleportedFar())
        return;                                              // The client handles it automatically after loading, but not after teleporting

    AreaTableEntry const* current_zone = sAreaTableStore.LookupEntry(newZone);
    if (!current_zone)
        return;

    ChannelMgr* cMgr = ChannelMgr::forTeam(GetTeam());
    if (!cMgr)
        return;

    for (uint32 i = 0; i < sChatChannelsStore.GetNumRows(); ++i)
    {
        if (ChatChannelsEntry const* channel = sChatChannelsStore.LookupEntry(i))
        {
            Channel* usedChannel = NULL;

            for (JoinedChannelsList::iterator itr = m_channels.begin(); itr != m_channels.end(); ++itr)
            {
                if ((*itr)->GetChannelId() == i)
                {
                    usedChannel = *itr;
                    break;
                }
            }

            Channel* removeChannel = NULL;
            Channel* joinChannel = NULL;
            bool sendRemove = true;

            if (CanJoinConstantChannelInZone(channel, current_zone))
            {
                if (!(channel->flags & CHANNEL_DBC_FLAG_GLOBAL))
                {
                    if (channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
                        continue;                            // Already on the channel, as city channel names are not changing

                    char new_channel_name_buf[200];
                    char const* currentNameExt;

                    if (channel->flags & CHANNEL_DBC_FLAG_CITY_ONLY)
                        currentNameExt = sObjectMgr->GetTrinityString(LANG_CHANNEL_CITY, LocaleConstant(sWorld->getIntConfig(CONFIG_CHANNEL_CONSTANT_LOCALE)));
                    else
                        currentNameExt = current_zone->area_name[GetSession()->GetSessionDbcLocale()];

                    snprintf(new_channel_name_buf, 200, channel->pattern[sWorld->getIntConfig(CONFIG_CHANNEL_CONSTANT_LOCALE)], currentNameExt);

                    joinChannel = cMgr->GetJoinChannel(new_channel_name_buf, channel->ChannelID);
                    if (usedChannel)
                    {
                        if (joinChannel != usedChannel)
                        {
                            removeChannel = usedChannel;
                            sendRemove = false;              // Do not send leave channel, it already replaced at client
                        }
                        else
                            joinChannel = NULL;
                    }
                }
                else
                    joinChannel = cMgr->GetJoinChannel(channel->pattern[sWorld->getIntConfig(CONFIG_CHANNEL_CONSTANT_LOCALE)], channel->ChannelID);
            }
            else
                removeChannel = usedChannel;

            if (joinChannel)
                joinChannel->JoinChannel(this, "");          // Changed Channel: ... or Joined Channel: ...

            if (removeChannel)
            {
                removeChannel->LeaveChannel(this, sendRemove); // Leave old channel
                std::string name = removeChannel->GetName(); // Store name, (*i)erase in LeftChannel
                LeftChannel(removeChannel);                  // Remove from player's channel list
                cMgr->LeftChannel(name);                     // Delete if empty
            }
        }
    }
}

void Player::LeaveLFGChannel()
{
    for (JoinedChannelsList::iterator i = m_channels.begin(); i != m_channels.end(); ++i)
    {
        if ((*i)->IsLFG())
        {
            (*i)->LeaveChannel(this);
            break;
        }
    }
}

float Player::GetMeleeCritFromAgility()
{
    uint8 level = getLevel();
    uint32 pclass = getClass();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

    GtChanceToMeleeCritBaseEntry const* critBase  = sGtChanceToMeleeCritBaseStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
    GtChanceToMeleeCritEntry     const* critRatio = sGtChanceToMeleeCritStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
    if (critBase == NULL || critRatio == NULL)
        return 0.0f;

    return ((critBase->base * 100.0f) + GetStat(STAT_AGILITY) / critRatio->ratio);
}

float Player::GetSpellCritFromIntellect()
{
    uint8 level = getLevel();
    uint32 pclass = getClass();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

    GtChanceToSpellCritBaseEntry const* critBase = sGtChanceToSpellCritBaseStore.LookupEntry((pclass - 1) * GT_MAX_LEVEL + level - 1);
    GtChanceToSpellCritEntry const* critRatio = sGtChanceToSpellCritStore.LookupEntry((pclass - 1) * GT_MAX_LEVEL + level - 1);
    if (critBase == NULL || critRatio == NULL)
        return 0.0f;

    return ((critBase->base * 100.0f) + GetStat(STAT_INTELLECT) / critRatio->ratio);
}

float Player::GetRatingMultiplier(CombatRating cr) const
{
    uint8 level = getLevel();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

    GtCombatRatingsEntry const* Rating = sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL+level-1);
    // gtOCTClassCombatRatingScalarStore.dbc starts with 1, CombatRating with zero, so cr+1
    GtOCTClassCombatRatingScalarEntry const* classRating = sGtOCTClassCombatRatingScalarStore.LookupEntry((getClass()-1)*GT_MAX_RATING+cr+1);
    if (!Rating || !classRating)
        return 1.0f;                                        // By default use minimum coefficient (not must be called)

    return classRating->ratio / Rating->ratio;
}

float Player::GetRatingBonusValue(CombatRating cr) const
{
    return float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) * GetRatingMultiplier(cr);
}

float Player::GetExpertiseDodgeOrParryReduction(WeaponAttackType attType) const
{
    float expertise = GetFloatValue(PLAYER_FIELD_COMBAT_RATING_EXPERTISE);
    switch (attType)
    {
        case BASE_ATTACK:
            expertise += GetFloatValue(PLAYER_FIELD_MAINHAND_EXPERTISE);
            break;
        case OFF_ATTACK:
            expertise += GetFloatValue(PLAYER_FIELD_OFFHAND_EXPERTISE);
            break;
        case RANGED_ATTACK:
            expertise += GetFloatValue(PLAYER_FIELD_RANGED_EXPERTISE);
            break;
        default:
            break;
    }
    return expertise;
}

float Player::OCTRegenMPPerSpirit()
{
    uint8 level = getLevel();
    uint32 pclass = getClass();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;

//    GtOCTRegenMPEntry     const* baseRatio = sGtOCTRegenMPStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
    GtRegenMPPerSptEntry  const* moreRatio = sGtRegenMPPerSptStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
    if (moreRatio == NULL)
        return 0.0f;

    // Formula get from PaperDollFrame script
    float spirit    = GetStat(STAT_SPIRIT);
    float regen     = spirit * moreRatio->ratio;
    return regen;
}

void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
{
    m_baseRatingValue[cr] += (apply ? value : -value);
    UpdateRating(cr);
}

void Player::UpdateRating(CombatRating cr)
{
    int32 amount = m_baseRatingValue[cr];
    amount += GetTotalAuraModifier(SPELL_AURA_MOD_RATING, MiscMask(1 << cr));
    // Apply bonus from SPELL_AURA_MOD_RATING_FROM_STAT
    // stat used stored in miscValueB for this aura
    AuraEffectList const& modRatingFromStat = GetAuraEffectsByType(SPELL_AURA_MOD_RATING_FROM_STAT);
    for (AuraEffectList::const_iterator i = modRatingFromStat.begin(); i != modRatingFromStat.end(); ++i)
        if ((*i)->GetMiscValue() & (1<<cr))
            amount += int32(CalculatePct(GetStat(Stats((*i)->GetMiscValueB())), (*i)->GetAmount()));
    if (amount < 0)
        amount = 0;

    amount *= GetTotalAuraMultiplier(SPELL_AURA_MOD_HASTE_RATING_PCT, MiscMask(1 << cr));

    SetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr, uint32(amount));

    bool affectStats = CanModifyStats();

    switch (cr)
    {
        case CR_WEAPON_SKILL:
        case CR_DEFENSE_SKILL:
            break;
        case CR_DODGE:
            UpdateDodgePercentage();
            break;
        case CR_PARRY:
            UpdateParryPercentage();
            break;
        case CR_BLOCK:
            UpdateBlockPercentage();
            break;
        case CR_HIT_MELEE:
            UpdateMeleeHitChances();
            break;
        case CR_HIT_RANGED:
            UpdateRangedHitChances();
            break;
        case CR_HIT_SPELL:
            UpdateSpellHitChances();
            break;
        case CR_CRIT_MELEE:
            if (affectStats)
            {
                UpdateCritPercentage(BASE_ATTACK);
                UpdateCritPercentage(OFF_ATTACK);
            }
            break;
        case CR_CRIT_RANGED:
            if (affectStats)
                UpdateCritPercentage(RANGED_ATTACK);
            break;
        case CR_CRIT_SPELL:
            if (affectStats)
                UpdateAllSpellCritChances();
            break;
        case CR_HIT_TAKEN_MELEE:                            // Deprecated since Cataclysm
        case CR_HIT_TAKEN_RANGED:                           // Deprecated since Cataclysm
        case CR_HIT_TAKEN_SPELL:                            // Deprecated since Cataclysm
        case CR_RESILIENCE_PLAYER_DAMAGE_TAKEN:
        case CR_RESILIENCE_CRIT_TAKEN:
        case CR_CRIT_TAKEN_SPELL:                           // Deprecated since Cataclysm
            break;
        case CR_HASTE_MELEE:
            UpdateAttackSpeed(BASE_ATTACK);
            UpdateAttackSpeed(OFF_ATTACK);
        case CR_HASTE_RANGED:
            UpdateAttackSpeed(RANGED_ATTACK);
            break;
        case CR_HASTE_SPELL:
            UpdateCastingSpeed();
            UpdateHasteRegen();
            break;
        case CR_WEAPON_SKILL_MAINHAND:                      // Implemented in Unit::RollMeleeOutcomeAgainst
        case CR_WEAPON_SKILL_OFFHAND:
        case CR_WEAPON_SKILL_RANGED:
            break;
        case CR_EXPERTISE:
            if (affectStats)
            {
                UpdateExpertise(BASE_ATTACK);
                UpdateExpertise(OFF_ATTACK);
                UpdateExpertise(RANGED_ATTACK);
            }
            break;
        case CR_ARMOR_PENETRATION:
            if (affectStats)
                UpdateArmorPenetration(amount);
            break;
        case CR_MASTERY:
            UpdateMastery();
            break;
        case CR_PVP_POWER:
            UpdatePvpPower();
            break;
    }
}

void Player::UpdateAllRatings()
{
    for (int cr = 0; cr < CR_MAX_COMBAT_RATING; ++cr)
        UpdateRating(CombatRating(cr));
}

void Player::UpdatePowerRegeneration()
{
    // We need to update mana/rune regen after changing items or modifiers
    switch (GetPowerType())
    {
        case POWER_MANA:
            UpdateManaRegen();
            break;
        case POWER_RUNIC_POWER:
            UpdateRuneRegen();
            break;
        case POWER_RAGE:
        case POWER_ENERGY:
            if (getClass() == CLASS_DRUID)
                UpdateManaRegen();
            break;
        default:
            break;
    }
}

void Player::SetRegularAttackTime()
{
    for (uint8 i = 0; i < MAX_ATTACK; ++i)
    {
        Item* tmpitem = GetWeaponForAttack(WeaponAttackType(i), true);
        if (tmpitem && !tmpitem->IsBroken())
        {
            ItemTemplate const* proto = tmpitem->GetTemplate();
            if (proto->Delay)
                SetAttackTime(WeaponAttackType(i), proto->Delay);
        }
        else
            SetAttackTime(WeaponAttackType(i), BASE_ATTACK_TIME);  // If there is no weapon reset attack time to base (might have been changed from forms)
    }
}

//skill+step, checking for max value
bool Player::UpdateSkill(uint32 skill_id, uint32 step)
{
    if (!skill_id)
        return false;

    if (skill_id == SKILL_FIST_WEAPONS)
        skill_id = SKILL_UNARMED;

    SkillStatusMap::iterator itr = mSkillStatus.find(skill_id);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return false;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);

    if (!max || !value || value >= max)
        return false;

    if (value < max)
    {
        uint16 new_value = value + step;
        if (new_value > max)
            new_value = max;

        SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, new_value);
        if (itr->second.uState != SKILL_NEW)
            itr->second.uState = SKILL_CHANGED;

        UpdateSkillEnchantments(skill_id, value, new_value);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
        return true;
    }

    return false;
}

inline int SkillGainChance(uint32 SkillValue, uint32 GrayLevel, uint32 GreenLevel, uint32 YellowLevel)
{
    if (SkillValue >= GrayLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREY)*10;
    if (SkillValue >= GreenLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREEN)*10;
    if (SkillValue >= YellowLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_YELLOW)*10;
    return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10;
}

bool Player::UpdateCraftSkill(uint32 spellid)
{
    TC_LOG_DEBUG("entities.player.skills", "UpdateCraftSkill spellid %d", spellid);

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellid);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        if (_spell_idx->second->skillId)
        {
            uint32 SkillValue = GetPureSkillValue(_spell_idx->second->skillId);

            // Alchemy Discoveries here
            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(spellid);
            if (spellEntry && spellEntry->Mechanic == MECHANIC_DISCOVERY)
            {
                if (uint32 discoveredSpell = GetSkillDiscoverySpell(_spell_idx->second->skillId, spellid, this))
                    LearnSpell(discoveredSpell, false);
            }

            uint32 craft_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_CRAFTING);
            uint32 points = _spell_idx->second->character_points;
            if (points && SkillValue < _spell_idx->second->min_value)
                craft_skill_gain *= points;

            return UpdateSkillPro(_spell_idx->second->skillId, SkillGainChance(SkillValue,
                _spell_idx->second->max_value,
                (_spell_idx->second->max_value + _spell_idx->second->min_value)/2,
                _spell_idx->second->min_value),
                craft_skill_gain);
        }
    }
    return false;
}

bool Player::UpdateGatherSkill(uint32 skillId, uint32 skillValue, uint32 redLevel, uint32 multiplicator, WorldObject const* lootObject)
{
    TC_LOG_DEBUG("entities.player.skills", "UpdateGatherSkill(SkillId %d SkillLevel %d RedLevel %d)", skillId, skillValue, redLevel);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
    switch (skillId)
    {
        case SKILL_HERBALISM:
        case SKILL_MINING:
        {
            uint32 gray = redLevel + 100;
            uint32 green = redLevel + 50;
            uint32 yellow = redLevel + 25;
            ASSERT(lootObject);
            if (!redLevel)
            {
                if (GameObject const* gobject = lootObject->ToGameObject())
                {
                    if (gobject->GetGOInfo()->chest.xpLevel < 85)   // Copper, Silverleaf, Peacebloom
                    {
                        gray = gobject->GetGOInfo()->chest.trivialSkillHigh;
                        yellow = gobject->GetGOInfo()->chest.trivialSkillLow;
                        green = (gray - yellow) / 2;
                    }
                    else                                            // Pandaria
                    {
                        green = gobject->GetGOInfo()->chest.trivialSkillHigh;
                        yellow = gobject->GetGOInfo()->chest.trivialSkillLow;
                        int32 diff = int32(green) - int32(yellow);
                        gray = green + diff;
                    }
                }
            }
            if (GameObject const* gobject = lootObject->ToGameObject())
            {
                uint32 gain = Trinity::XP::BaseGain(getLevel(), gobject->GetGOInfo()->chest.xpLevel, GetContentLevelsForMapAndZone(GetMapId(), GetZoneId()));
                gain *= sWorld->getRate(RATE_XP_GATHER);
                gain += GetXPRestBonus(gain);

                int32 diff = gobject->GetGOInfo()->chest.xpLevel - getLevel();
                gain = diff > int32(sWorld->getIntConfig(CONFIG_XP_GATHER_LEVEL_DIFFERENCE)) ? 0 : gain;
                GiveXP(gain, nullptr);
            }
            return UpdateSkillPro(skillId, SkillGainChance(skillValue, gray, green, yellow) * multiplicator, gathering_skill_gain);
        }
        case SKILL_LOCKPICKING:
        case SKILL_JEWELCRAFTING:
        case SKILL_INSCRIPTION:
            return UpdateSkillPro(skillId, SkillGainChance(skillValue, redLevel+100, redLevel+50, redLevel+25)*multiplicator, gathering_skill_gain);
        case SKILL_SKINNING:
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS) == 0)
                return UpdateSkillPro(skillId, SkillGainChance(skillValue, redLevel+100, redLevel+50, redLevel+25)*multiplicator, gathering_skill_gain);
            else
                return UpdateSkillPro(skillId, (SkillGainChance(skillValue, redLevel+100, redLevel+50, redLevel+25)*multiplicator) >> (skillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS)), gathering_skill_gain);
    }
    return false;
}

bool Player::UpdateFishingSkill()
{
    TC_LOG_DEBUG("entities.player.skills", "UpdateFishingSkill");

    uint32 SkillValue = GetPureSkillValue(SKILL_FISHING);

    int32 chance = SkillValue < 75 ? 100 : 10000 / (SkillValue + 25);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    return UpdateSkillPro(SKILL_FISHING, chance*10, gathering_skill_gain);
}

bool Player::UpdateSkillPro(uint16 skillId, int32 chance, uint32 step)
{
    // levels sync. with spell requirement for skill levels to learn
    // bonus abilities in sSkillLineAbilityStore
    // Used only to avoid scan DBC at each skill grow
    static uint32 bonusSkillLevels[] = { 75, 150, 225, 300, 375, 450, 525, 600 };
    static const size_t bonusSkillLevelsSize = sizeof(bonusSkillLevels) / sizeof(uint32);

    TC_LOG_DEBUG("entities.player.skills", "UpdateSkillPro(SkillId %d, Chance %3.1f%%)", skillId, chance / 10.0f);
    if (!skillId)
        return false;

    if (chance <= 0)                                         // speedup in 0 chance case
    {
        TC_LOG_DEBUG("entities.player.skills", "Player::UpdateSkillPro Chance=%3.1f%% missed", chance / 10.0f);
        return false;
    }

    SkillStatusMap::iterator itr = mSkillStatus.find(skillId);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return false;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);

    if (!max || !value || value >= max)
        return false;

    AddPct(chance, GetMaxPositiveAuraModifier(SPELL_AURA_INCREASE_SKILL_GAIN_CHANCE));

    if (irand(1, 1000) > chance)
    {
        TC_LOG_DEBUG("entities.player.skills", "Player::UpdateSkillPro Chance=%3.1f%% missed", chance / 10.0f);
        return false;
    }

    uint16 new_value = value + step;
    if (new_value > max)
        new_value = max;

    SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, new_value);
    if (itr->second.uState != SKILL_NEW)
        itr->second.uState = SKILL_CHANGED;

    for (size_t i = 0; i < bonusSkillLevelsSize; ++i)
    {
        uint32 bsl = bonusSkillLevels[i];
        if (value < bsl && new_value >= bsl)
        {
            LearnSkillRewardedSpells(skillId, new_value);
            break;
        }
    }

    UpdateSkillEnchantments(skillId, value, new_value);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, skillId);
    TC_LOG_DEBUG("entities.player.skills", "Player::UpdateSkillPro Chance=%3.1f%% taken", chance / 10.0f);
    if (skillId == SKILL_ARCHAEOLOGY)
    {
        UpdateResearchDigsites();
        UpdateResearchProjects();
    }
    else if (skillId >= SKILL_WAY_OF_THE_GRILL && skillId <= SKILL_WAY_OF_THE_BREW)
    {
        UpdateSkillPro(SKILL_COOKING, 1000, step);
    }
    return true;
}

void Player::ModifySkillBonus(uint32 skillid, int32 val, bool talent)
{
    SkillStatusMap::const_iterator itr = mSkillStatus.find(skillid);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return;

    uint16 field = itr->second.pos / 2 + (talent ? PLAYER_FIELD_SKILL_TALENTS : PLAYER_FIELD_SKILL_MODIFIERS);
    uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

    uint16 bonus = GetUInt16Value(field, offset);

    SetUInt16Value(field, offset, bonus + val);
}

void Player::UpdateSkillsForLevel()
{
    uint32 maxSkill = GetMaxSkillValueForLevel();

    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
    {
        if (itr->second.uState == SKILL_DELETED)
            continue;

        uint32 pskill = itr->first;
        SkillRaceClassInfoEntry const* entry = GetSkillRaceClassInfo(pskill, getRace(), getClass());
        if (!entry)
            continue;

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

        auto skillLine = sSkillLineStore.LookupEntry(entry->SkillId);
        if (GetSkillRangeType(skillLine, false) == SKILL_RANGE_LEVEL)
        {
            if (!IsWeaponSkill(entry->SkillId))
            {
                uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);

                /// update only level dependent max skill values
                if (max != 1)
                {
                    SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, maxSkill);
                    SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, maxSkill);
                    if (itr->second.uState != SKILL_NEW)
                        itr->second.uState = SKILL_CHANGED;
                }
            }
        }

        // Update level dependent skillline spells
        LearnSkillRewardedSpells(entry->SkillId, GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset));
    }
}

void Player::UpdateSkillsToMaxSkillsForLevel()
{
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
    {
        if (itr->second.uState == SKILL_DELETED)
            continue;

        uint32 pskill = itr->first;
        SkillRaceClassInfoEntry const* entry = GetSkillRaceClassInfo(pskill, getRace(), getClass());
        if (!entry)
            continue;

        if (IsProfessionOrRidingSkill(entry->SkillId))
            continue;

        if (IsWeaponSkill(entry->SkillId))
            continue;

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);

        if (max > 1)
        {
            SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, max);

            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_CHANGED;
        }
    }
}

// This functions sets a skill line value (and adds if doesn't exist yet)
// To "remove" a skill line, set it's values to zero
void Player::SetSkill(uint16 id, uint16 step, uint16 newVal, uint16 maxVal)
{
    if (!id)
        return;

    uint16 currVal;
    SkillStatusMap::iterator itr = mSkillStatus.find(id);

    //has skill
    if (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED)
    {
        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2
        currVal = GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
        if (newVal)
        {
            // if skill value is going down, update enchantments before setting the new value
            if (newVal < currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL_STEPS + field, offset, step);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, newVal);
            SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, maxVal);

            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_CHANGED;

            LearnSkillRewardedSpells(id, newVal);
            // if skill value is going up, update enchantments after setting the new value
            if (newVal > currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
        }
        else                                                //remove
        {
            //remove enchantments needing this skill
            UpdateSkillEnchantments(id, currVal, 0);
            // clear skill fields
            SetUInt16Value(PLAYER_FIELD_SKILL_LINEIDS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_STEPS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset, 0);

            // mark as deleted or simply remove from map if not saved yet
            if (itr->second.uState != SKILL_NEW)
                itr->second.uState = SKILL_DELETED;
            else
                mSkillStatus.erase(itr);

            // remove all spells that related to this skill
            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
                if (SkillLineAbilityEntry const* pAbility = sSkillLineAbilityStore.LookupEntry(j))
                    if (pAbility->skillId == id)
                        RemoveSpell(sSpellMgr->GetFirstSpellInChain(pAbility->spellId));

            if (id == SKILL_JEWELCRAFTING)
                RemoveSpell(55534);

            // Clear profession lines
            if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, 0);
            else if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, 0);
        }
    }
    else if (newVal)                                        //add
    {
        currVal = 0;
        for (uint32 i = 0; i < PLAYER_MAX_SKILLS; ++i)
        {
            uint16 field = i / 2;
            uint8 offset = i & 1; // i % 2

            if (!GetUInt16Value(PLAYER_FIELD_SKILL_LINEIDS + field, offset))
            {
                SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(id);
                if (!skillEntry)
                {
                    TC_LOG_ERROR("misc", "Skill not found in SkillLineStore: skill #%u", id);
                    return;
                }

                SetUInt16Value(PLAYER_FIELD_SKILL_LINEIDS + field, offset, id);
                if (skillEntry->categoryId == SKILL_CATEGORY_PROFESSION)
                {
                    if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, id);
                    else if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, id);
                }

                SetUInt16Value(PLAYER_FIELD_SKILL_STEPS + field, offset, step);
                SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, newVal);
                SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, maxVal);

                UpdateSkillEnchantments(id, currVal, newVal);
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);

                // insert new entry or update if not deleted old entry yet
                if (itr != mSkillStatus.end())
                {
                    itr->second.pos = i;
                    itr->second.uState = SKILL_CHANGED;
                }
                else
                    mSkillStatus.insert(SkillStatusMap::value_type(id, SkillStatusData(i, SKILL_NEW)));

                // apply skill bonuses
                SetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset, 0);
                SetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset, 0);

                // temporary bonuses
                AuraEffectList const& mModSkill = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL);
                for (AuraEffectList::const_iterator j = mModSkill.begin(); j != mModSkill.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // permanent bonuses
                AuraEffectList const& mModSkillTalent = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_TALENT);
                for (AuraEffectList::const_iterator j = mModSkillTalent.begin(); j != mModSkillTalent.end(); ++j)
                    if ((*j)->GetMiscValue() == int32(id))
                        (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // Learn all spells for skill
                LearnSkillRewardedSpells(id, newVal);
                return;
            }
        }
    }

    if (id == SKILL_ARCHAEOLOGY)
    {
        UpdateResearchProjects(); // this will unlock new projects after archaeology skill is learned or increased (or it will remove all projects if archaeology is unlearned)
        UpdateResearchDigsites(); // this will unlock new digsites after archaeology skill is learned or increased (or it will remove all digsites if archaeology is unlearned)
    }
}

bool Player::HasSkill(uint32 skill) const
{
    if (!skill)
        return false;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    return (itr != mSkillStatus.end() && itr->second.uState != SKILL_DELETED);
}

uint16 Player::GetSkillStep(uint16 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    return GetUInt16Value(PLAYER_FIELD_SKILL_STEPS + itr->second.pos / 2, itr->second.pos & 1);
}

uint16 Player::GetSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureMaxSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);
}

uint16 Player::GetBaseSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureSkillValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
}

int16 Player::GetSkillPermBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset);
}

int16 Player::GetSkillTempBonusValue(uint32 skill) const
{
    if (!skill)
        return 0;

    SkillStatusMap::const_iterator itr = mSkillStatus.find(skill);
    if (itr == mSkillStatus.end() || itr->second.uState == SKILL_DELETED)
        return 0;

    uint16 field = itr->second.pos / 2;
    uint8 offset = itr->second.pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset);
}

void Player::SendActionButtons(uint32 state) const
{
    WorldPacket data(SMSG_ACTION_BUTTONS, 1+(MAX_ACTION_BUTTONS*8));

    uint8 buttons [MAX_ACTION_BUTTONS][8];
    ActionButtonPACKET* buttonsTab = (ActionButtonPACKET*)buttons;
    memset(buttons, 0, MAX_ACTION_BUTTONS*8);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
    {
        ActionButton const* ab = ((Player*)this)->GetActionButton(i);
        if (!ab)
        {
            buttonsTab[i].id = 0;
            buttonsTab[i].type = 0;
            continue;
        }

        buttonsTab[i].id = ab->GetAction();
        buttonsTab[i].type = uint32(ab->GetType()) << 24;
    }

    // Bits
    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][4]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][5]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][3]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][1]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][6]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][7]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][0]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteBit(buttons[i][2]);

    // Data
    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][0]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][1]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][4]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][6]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][7]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][2]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][5]);

    for (uint8 i = 0; i < MAX_ACTION_BUTTONS; ++i)
        data.WriteByteSeq(buttons[i][3]);

    data << uint8(state);
    GetSession()->SendPacket(&data);
    TC_LOG_INFO("network", "Action Buttons for '%u' spec '%u' Sent", GetGUIDLow(), GetActiveSpec());
}

bool Player::IsActionButtonDataValid(uint8 button, uint32 action, uint8 type)
{
    if (button >= MAX_ACTION_BUTTONS)
    {
        TC_LOG_ERROR("entities.player", "Action %u not added into button %u for player %s (GUID: %u): button must be < %u", action, button, GetName().c_str(), GUID_LOPART(GetGUID()), MAX_ACTION_BUTTONS );
        return false;
    }

    if (action >= MAX_ACTION_BUTTON_ACTION_VALUE)
    {
        TC_LOG_ERROR("entities.player", "Action %u not added into button %u for player %s (GUID: %u): action must be < %u", action, button, GetName().c_str(), GUID_LOPART(GetGUID()), MAX_ACTION_BUTTON_ACTION_VALUE);
        return false;
    }

    switch (type)
    {
        case ACTION_BUTTON_SPELL:
            if (!sSpellMgr->GetSpellInfo(action))
            {
                TC_LOG_ERROR("entities.player", "Spell action %u not added into button %u for player %s (GUID: %u): spell not exist", action, button, GetName().c_str(), GUID_LOPART(GetGUID()));
                return false;
            }

            if (!HasSpell(action))
            {
                TC_LOG_ERROR("entities.player", "Spell action %u not added into button %u for player %s (GUID: %u): player don't known this spell", action, button, GetName().c_str(), GUID_LOPART(GetGUID()));
                return false;
            }
            break;
        case ACTION_BUTTON_ITEM:
            if (!sObjectMgr->GetItemTemplate(action))
            {
                TC_LOG_ERROR("entities.player", "Item action %u not added into button %u for player %s (GUID: %u): item not exist", action, button, GetName().c_str(), GUID_LOPART(GetGUID()));
                return false;
            }
            break;
        case ACTION_BUTTON_C:
        case ACTION_BUTTON_CMACRO:
        case ACTION_BUTTON_MACRO:
        case ACTION_BUTTON_EQSET:
        case ACTION_BUTTON_DROPDOWN:
            break;
        default:
            TC_LOG_ERROR("entities.player", "Unknown action type %u", type);
            return false;                                          // other cases not checked at this moment
    }

    return true;
}

ActionButton* Player::addActionButton(uint8 button, uint32 action, uint8 type)
{
    if (!IsActionButtonDataValid(button, action, type))
        return NULL;

    // it create new button (NEW state) if need or return existed
    ActionButton& ab = m_actionButtons[button];

    // set data and update to CHANGED if not NEW
    ab.SetActionAndType(action, ActionButtonType(type));

    TC_LOG_DEBUG("entities.player", "Player '%u' Added Action '%u' (type %u) to Button '%u'", GetGUIDLow(), action, type, button);
    return &ab;
}

void Player::removeActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return;

    if (buttonItr->second.uState == ACTIONBUTTON_NEW)
        m_actionButtons.erase(buttonItr);                   // new and not saved
    else
        buttonItr->second.uState = ACTIONBUTTON_DELETED;    // saved, will deleted at next save

    TC_LOG_DEBUG("entities.player", "Action Button '%u' Removed from Player '%u'", button, GetGUIDLow());
}

ActionButton const* Player::GetActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return NULL;

    return &buttonItr->second;
}

bool Player::UpdatePosition(float x, float y, float z, float orientation, bool teleport)
{
    if (!Unit::UpdatePosition(x, y, z, orientation, teleport))
        return false;

    //if (movementInfo.flags & MOVEMENTFLAG_MOVING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
    //if (movementInfo.flags & MOVEMENTFLAG_TURNING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
    //AURA_INTERRUPT_FLAG_JUMP not sure

    // group update
    if (GetGroup())
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);

    if (GetTrader() && !IsWithinDistInMap(GetTrader(), INTERACTION_DISTANCE))
        GetSession()->SendCancelTrade();

    CheckAreaExploreAndOutdoor();

    UpdateMount();

    return true;
}

void Player::SaveRecallPosition()
{
    m_recallMap = GetMapId();
    m_recallX = GetPositionX();
    m_recallY = GetPositionY();
    m_recallZ = GetPositionZ();
    m_recallO = GetOrientation();
}

void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self)
{
    if (self)
        GetSession()->SendPacket(data);

    Trinity::MessageDistDeliverer notifier(this, data, dist);
    VisitNearbyWorldObject(dist, notifier, false, true);
}

void Player::SendMessageToSetInRange(WorldPacket* data, float dist, bool self, bool own_team_only)
{
    if (self)
        GetSession()->SendPacket(data);

    Trinity::MessageDistDeliverer notifier(this, data, dist, own_team_only);
    VisitNearbyWorldObject(dist, notifier, false, true);
}

void Player::SendMessageToSet(WorldPacket* data, Player const* skipped_rcvr)
{
    if (skipped_rcvr != this)
        GetSession()->SendPacket(data);

    // we use World::GetMaxVisibleDistance() because i cannot see why not use a distance
    // update: replaced by GetMap()->GetVisibilityDistance()
    Trinity::MessageDistDeliverer notifier(this, data, GetVisibilityRange() + 2 * World::Visibility_RelocationLowerLimit, false, skipped_rcvr);
    VisitNearbyWorldObject(GetVisibilityRange() + 2 * World::Visibility_RelocationLowerLimit, notifier, false, true);
}

void Player::SendDirectMessage(WorldPacket* data)
{
    m_session->SendPacket(data);
}

void Player::SendCinematicStart(uint32 CinematicSequenceId)
{
    WorldPacket data(SMSG_TRIGGER_CINEMATIC, 4);
    data << uint32(CinematicSequenceId);
    SendDirectMessage(&data);
}

void Player::SendMovieStart(uint32 MovieId)
{
    WorldPacket data(SMSG_TRIGGER_MOVIE, 4);
    data << uint32(MovieId);
    SendDirectMessage(&data);
}

void Player::CheckAreaExploreAndOutdoor()
{
    if (!IsAlive())
        return;

    if (IsInFlight())
        return;

    if (GetTransport())
        return;

    bool isOutdoor;
    uint32 areaId = GetBaseMap()->GetAreaId(GetPositionX(), GetPositionY(), GetPositionZ(), &isOutdoor);
    AreaTableEntry const* areaEntry = sAreaTableStore.LookupEntry(areaId);

    if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !isOutdoor)
    {
        for (auto itr = m_appliedAuras.begin(); itr != m_appliedAuras.end();)
        {
            auto* spellInfo = itr->second->GetBase()->GetSpellInfo();
            if (spellInfo->HasAttribute(SPELL_ATTR0_OUTDOORS_ONLY) && !spellInfo->HasAttribute(SPELL_ATTR0_PASSIVE))
                RemoveAura(itr);
            else
                ++itr;
        }
    }

    if (!areaId)
        return;
    if (!areaEntry)
    {
        TC_LOG_ERROR("entities.player", "Player '%s' (" UI64FMTD ") discovered unknown area (x: %f y: %f z: %f map: %u)",
            GetName().c_str(), GetGUID(), GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
        return;
    }

    if (GetQuestStatus(33161) == QUEST_STATUS_INCOMPLETE)
    {
        switch (areaId)
        {
            case 6780: // Cavern of Lost Spirits
                KilledMonsterCredit(73577);
                break;
            case 6824: // Croaking Hollow
                KilledMonsterCredit(73576);
                break;
            case 6825: // Firewalker Ruins
                KilledMonsterCredit(73579);
                break;
            case 6835: // Misty Strand
                KilledMonsterCredit(73578);
                break;
            case 6773: // Old Pi'jiu
                KilledMonsterCredit(73574);
                break;
            case  6841: // Red Stone Run
                KilledMonsterCredit(73575);
                break;
        }
    }

    uint32 offset = areaEntry->exploreFlag / 32;

    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
    {
        TC_LOG_ERROR("entities.player", "Player::CheckAreaExploreAndOutdoor: Wrong area flag %u in map data for (X: %f Y: %f) point to field PLAYER_EXPLORED_ZONES_1 + %u ( %u must be < %u ).",
            areaEntry->exploreFlag, GetPositionX(), GetPositionY(), offset, offset, PLAYER_EXPLORED_ZONES_SIZE);
        return;
    }

    uint32 val = (uint32)(1 << (areaEntry->exploreFlag % 32));
    uint32 currFields = GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset);

    if (!(currFields & val))
    {
        SetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset, (uint32)(currFields | val));

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EXPLORE_AREA);

        if (areaEntry->area_level > 0)
        {
            if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            {
                SendExplorationExperience(areaId, 0);
            }
            else
            {
                int32 diff = int32(getLevel()) - areaEntry->area_level;
                uint32 XP = 0;
                if (diff < -5)
                {
                    XP = uint32(sObjectMgr->GetBaseXP(getLevel()+5)*sWorld->getRate(RATE_XP_EXPLORE, this));
                }
                else if (diff > 5)
                {
                    int32 exploration_percent = 100 - ((diff - 5) * 5);
                    if (exploration_percent < 0)
                        exploration_percent = 0;

                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->area_level)*exploration_percent/100*sWorld->getRate(RATE_XP_EXPLORE, this));
                }
                else
                {
                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->area_level)*sWorld->getRate(RATE_XP_EXPLORE, this));
                }

                GiveXP(XP, NULL);
                SendExplorationExperience(areaId, XP);
            }
            TC_LOG_INFO("entities.player", "Player %u discovered a new area: %u", GetGUIDLow(), areaId);
        }
    }
}

uint32 Player::TeamForRace(uint8 race)
{
    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race))
    {
        switch (rEntry->TeamID)
        {
            case 1: return HORDE;
            case 7: return ALLIANCE;
			case 42: return PANDAREN_NEUTRAL;
        }
        TC_LOG_ERROR("entities.player", "Race (%u) has wrong teamid (%u) in DBC: wrong DBC files?", uint32(race), rEntry->TeamID);
    }
    else
        TC_LOG_ERROR("entities.player", "Race (%u) not found in DBC: wrong DBC files?", uint32(race));

    return ALLIANCE;
}

void Player::setFactionForRace(uint8 race)
{
    m_team = TeamForRace(race);

    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
    setFaction(rEntry ? rEntry->FactionID : 0);
}

ReputationRank Player::GetReputationRank(uint32 faction) const
{
    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction);
    return GetReputationMgr().GetRank(factionEntry);
}

// Calculate total reputation percent player gain with quest/creature level
float Player::CalculateReputationGain(ReputationSource source, uint32 creatureOrQuestLevel, int32 rep, int32 faction, bool noQuestBonus)
{
    float val = rep;
    float percent = 100.0f;

    float repMod = noQuestBonus ? 0.0f : float(GetTotalAuraModifier(SPELL_AURA_MOD_REPUTATION_GAIN));

    // faction specific auras only seem to apply to kills
    if (source == REPUTATION_SOURCE_KILL)
        repMod += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction);

    percent += rep > 0 ? repMod : -repMod;

    float rate;
    switch (source)
    {
        case REPUTATION_SOURCE_KILL:
            rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_KILL);
            break;
        case REPUTATION_SOURCE_QUEST:
        case REPUTATION_SOURCE_DAILY_QUEST:
        case REPUTATION_SOURCE_WEEKLY_QUEST:
        case REPUTATION_SOURCE_MONTHLY_QUEST:
        case REPUTATION_SOURCE_REPEATABLE_QUEST:
            rate = sWorld->getRate(RATE_REPUTATION_LOWLEVEL_QUEST);
            break;
        case REPUTATION_SOURCE_SPELL:
        default:
            rate = 1.0f;
            break;
    }

    if (rate != 1.0f && creatureOrQuestLevel <= Trinity::XP::GetGrayLevel(getLevel()))
        percent *= rate;

    if (percent <= 0.0f)
        return 0;

    // Multiply result with the faction specific rate
    if (RepRewardRate const* repData = sObjectMgr->GetRepRewardRate(faction))
    {
        float repRate = 0.0f;
        switch (source)
        {
            case REPUTATION_SOURCE_KILL:
                repRate = repData->creatureRate;
                break;
            case REPUTATION_SOURCE_QUEST:
                repRate = repData->questRate;
                break;
            case REPUTATION_SOURCE_DAILY_QUEST:
                repRate = repData->questDailyRate;
                break;
            case REPUTATION_SOURCE_WEEKLY_QUEST:
                repRate = repData->questWeeklyRate;
                break;
            case REPUTATION_SOURCE_MONTHLY_QUEST:
                repRate = repData->questMonthlyRate;
                break;
            case REPUTATION_SOURCE_REPEATABLE_QUEST:
                repRate = repData->questRepeatableRate;
                break;
            case REPUTATION_SOURCE_SPELL:
                repRate = repData->spellRate;
                break;
        }

        // for custom, a rate of 0.0 will totally disable reputation gain for this faction/type
        if (repRate <= 0.0f)
            return 0;

        percent *= repRate;
    }

    if (source != REPUTATION_SOURCE_SPELL && GetsRecruitAFriendBonus(false))
        percent *= 1.0f + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS);

    return CalculatePct(val, percent);
}

// Calculates how many reputation points player gains in victim's enemy factions
void Player::RewardReputation(Unit* victim, float rate)
{
    if (!victim || victim->GetTypeId() == TYPEID_PLAYER)
        return;

    if (victim->ToCreature()->IsReputationGainDisabled())
        return;

    ReputationOnKillEntry const* Rep = sObjectMgr->GetReputationOnKilEntry(victim->ToCreature()->GetCreatureTemplate()->Entry);
    if (!Rep)
        return;

    uint32 team = GetTeam();

    if (Rep->RepFaction1 && (!Rep->TeamDependent || team == ALLIANCE))
    {
        float donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, Rep->RepFaction1);
        donerep1 = donerep1 * rate;

        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(Rep->RepFaction1);
        uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
        if (factionEntry1 && current_reputation_rank1 <= Rep->ReputationMaxCap1)
            GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
    }

    if (Rep->RepFaction2 && (!Rep->TeamDependent || team == HORDE))
    {
        float donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, Rep->RepFaction2);
        donerep2 = donerep2 * rate;

        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(Rep->RepFaction2);
        uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
        if (factionEntry2 && current_reputation_rank2 <= Rep->ReputationMaxCap2)
            GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
    }
}

// Calculate how many reputation points player gain with the quest
void Player::RewardReputation(Quest const* quest)
{
    for (uint8 i = 0; i < QUEST_REPUTATIONS_COUNT; ++i)
    {
        if (!quest->RewardFactionId[i])
            continue;

        float rep = 0;
        bool noQuestBonus = false;

        if (quest->RewardFactionValueIdOverride[i])
        {
            rep = quest->RewardFactionValueIdOverride[i] / 100;
            noQuestBonus = true;
        }
        else
        {
            uint32 row = ((quest->RewardFactionValueId[i] < 0) ? 1 : 0) + 1;
            if (QuestFactionRewEntry const* questFactionRewEntry = sQuestFactionRewardStore.LookupEntry(row))
            {
                uint32 field = abs(quest->RewardFactionValueId[i]);
                rep = questFactionRewEntry->QuestRewFactionValue[field];
            }
        }

        if (!rep)
            continue;

        if (quest->IsDaily())
            rep = CalculateReputationGain(REPUTATION_SOURCE_DAILY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        else if (quest->IsWeekly())
            rep = CalculateReputationGain(REPUTATION_SOURCE_WEEKLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        else if (quest->IsMonthly())
            rep = CalculateReputationGain(REPUTATION_SOURCE_MONTHLY_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        else if (quest->IsRepeatable())
            rep = CalculateReputationGain(REPUTATION_SOURCE_REPEATABLE_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);
        else
            rep = CalculateReputationGain(REPUTATION_SOURCE_QUEST, GetQuestLevel(quest), rep, quest->RewardFactionId[i], noQuestBonus);

        if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(quest->RewardFactionId[i]))
            GetReputationMgr().ModifyReputation(factionEntry, rep);
    }
}

void Player::RewardReputationOnChampioning(Unit* victim)
{
    Creature* target = victim->ToCreature();
    if (!target)
        return;

    if (!target->isElite() && !target->isWorldBoss() && !target->IsDungeonBoss())
        return;

    if (target->IsSummon())
        return;

    Map const* map = GetMap();
    if (!map->IsNonRaidDungeon())
        return;

    if (!m_championingExpansion)
        if (m_championingExpansion == EXPANSION_THE_BURNING_CRUSADE || m_championingExpansion == EXPANSION_WRATH_OF_THE_LICH_KING)
            if (sObjectMgr->GetReputationOnKilEntry(victim->ToCreature()->GetCreatureTemplate()->Entry))
                return;

    uint32 championingFaction = 0;
    if (!m_championingExpansion || m_championingExpansion == map->GetEntry()->Expansion())
        championingFaction = m_championingFaction;

    if (!championingFaction)
        return;

    int32 rep = target->isWorldBoss() || target->IsDungeonBoss() ? 300 : 15;
    if (target->getLevel() <= Trinity::XP::GetGrayLevel(getLevel()))
        rep /= 5;

    if (auto factionEntry = sFactionStore.LookupEntry(championingFaction))
    {
        float donerep = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), rep, championingFaction);
        GetReputationMgr().ModifyReputation(factionEntry, donerep);
    }
}

void Player::UpdateHonorFields()
{
    /// called when rewarding honor and at each save
    time_t now = time_t(time(NULL));
    time_t today = time_t(time(NULL) / DAY) * DAY;

    if (m_lastHonorUpdateTime < today)
    {
        time_t yesterday = today - DAY;

        uint16 kills_today = PAIR32_LOPART(GetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS));

        // update yesterday's contribution
        if (m_lastHonorUpdateTime >= yesterday)
        {
            // this is the first update today, reset today's contribution
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, MAKE_PAIR32(0, kills_today));
        }
        else
        {
            // no honor/kills yesterday or today, reset
            SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
        }
    }

    m_lastHonorUpdateTime = now;
}

///Calculate the amount of honor gained based on the victim
///and the size of the group for which the honor is divided
///An exact honor value can also be given (overriding the calcs)
bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvptoken)
{
    // do not reward honor in arenas, but enable onkill spellproc
    if (InArena())
    {
        if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
            return false;

        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
            return false;

        return true;
    }

    // 'Inactive' this aura prevents the player from gaining honor points and battleground Tokenizer
    if (HasAura(SPELL_AURA_PLAYER_INACTIVE))
        return false;

    uint64 victim_guid = 0;
    uint32 victim_rank = 0;

    // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
    UpdateHonorFields();

    // do not reward honor in arenas, but return true to enable onkill spellproc
    if (InBattleground() && GetBattleground() && GetBattleground()->IsArena())
        return true;

    // Promote to float for calculations
    float honor_f = (float)honor;

    if (honor_f <= 0)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return false;

        victim_guid = victim->GetGUID();

        if (Player* plrVictim = victim->ToPlayer())
        {
            if (GetTeam() == plrVictim->GetTeam() && !sWorld->IsFFAPvPRealm() && !(GetMap()->IsBattleground() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_IGNORE_FACTION)))
                return false;

            uint8 k_level = getLevel();
            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
            uint8 v_level = victim->getLevel();

            if (v_level <= k_grey)
                return false;

            // PLAYER_FIELD_PLAYER_TITLE VALUES DESCRIPTION
            //  [0]      Just name
            //  [1..14]  Alliance honor titles and player name
            //  [15..28] Horde honor titles and player name
            //  [29..38] Other title and player name
            //  [39+]    Nothing
            uint32 victim_title = victim->GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE);
                                                        // Get Killer titles, CharTitlesEntry::bit_index
            // Ranks:
            //  title[1..14]  -> rank[5..18]
            //  title[15..28] -> rank[5..18]
            //  title[other]  -> 0
            if (victim_title == 0)
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
            else if (victim_title < 15)
                victim_rank = victim_title + 4;
            else if (victim_title < 29)
                victim_rank = victim_title - 14 + 4;
            else
                victim_guid = 0;                        // Don't show HK: <rank> message, only log.

            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));

            // count the number of playerkills in one day
            ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);
            // and those in a lifetime
            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL, 1);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass(), 0, 0, victim);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace(), 0, 0, victim);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);
            if (Guild* guild = GetGuild())
                guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, victim, this);
        }
        else
        {
            if (!victim->ToCreature()->IsRacialLeader())
                return false;

            honor_f = 100.0f;                               // ??? need more info
            victim_rank = 19;                               // HK: Leader
        }
    }

    if (victim != NULL)
    {
        if (groupsize > 1)
            honor_f /= groupsize;

        // apply honor multiplier from aura (not stacking-get highest)
        AddPct(honor_f, GetMaxPositiveAuraModifier(SPELL_AURA_MOD_HONOR_GAIN_PCT));
    }

    honor_f *= sWorld->getRate(RATE_HONOR, this);
    // Back to int now
    honor = int32(honor_f);
    // honor - for show honor points in log
    // victim_guid - for show victim name in log
    // victim_rank [1..4]  HK: <dishonored rank>
    // victim_rank [5..19] HK: <alliance\horde rank>
    // victim_rank [0, 20+] HK: <>
    WorldPacket data(SMSG_PVP_CREDIT, 4+8+4);
    data << uint32(victim_rank);
    data << uint32(honor);
    data.WriteGuidMask(victim_guid, 4, 2, 5, 3, 0, 6, 1, 7);
    data.WriteGuidBytes(victim_guid, 6, 7, 5, 0, 1, 3, 4, 2);

    GetSession()->SendPacket(&data);

    // add honor points
    ModifyCurrency(CURRENCY_TYPE_HONOR_POINTS, int32(honor));

    if (InBattleground() && honor > 0)
    {
        if (Battleground* bg = GetBattleground())
        {
            bg->UpdatePlayerScore(this, SCORE_BONUS_HONOR, honor, false); //false: prevent looping
        }
    }

    if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE) && pvptoken)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return true;

        if (victim->GetTypeId() == TYPEID_PLAYER)
        {
            // Check if allowed to receive it in current map
            uint8 MapType = sWorld->getIntConfig(CONFIG_PVP_TOKEN_MAP_TYPE);
            if ((MapType == 1 && !InBattleground() && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 2 && !HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
                || (MapType == 3 && !InBattleground()))
                return true;

            uint32 itemId = sWorld->getIntConfig(CONFIG_PVP_TOKEN_ID);
            int32 count = sWorld->getIntConfig(CONFIG_PVP_TOKEN_COUNT);

            if (AddItem(itemId, count))
                ChatHandler(GetSession()).PSendSysMessage("You have been awarded a token for slaying another player.");
        }
    }

    return true;
}


void Player::_LoadCurrency(PreparedQueryResult result)
{
    if (!result)
        return;
    do
    {
        Field* fields = result->Fetch();

        uint16 currencyID = fields[0].GetUInt16();

        CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyID);
        if (!currency)
            continue;

        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_UNCHANGED;
        cur.weekCount = fields[1].GetUInt32();
        cur.totalCount = fields[2].GetUInt32();
        cur.seasonCount = fields[3].GetUInt32();
        cur.flags = fields[4].GetUInt8();

        _currencyStorage.insert(PlayerCurrenciesMap::value_type(currencyID, cur));

    } while (result->NextRow());
}

void Player::_SaveCurrency(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
        if (!entry) // should never happen
            continue;

        switch (itr->second.state)
        {
            case PLAYERCURRENCY_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt16(1, itr->first);
                stmt->setUInt32(2, itr->second.weekCount);
                stmt->setUInt32(3, itr->second.totalCount);
                stmt->setUInt32(4, itr->second.seasonCount);
                stmt->setUInt8(5, itr->second.flags);
                trans->Append(stmt);
                break;
            case PLAYERCURRENCY_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_CURRENCY);
                stmt->setUInt32(0, itr->second.weekCount);
                stmt->setUInt32(1, itr->second.totalCount);
                stmt->setUInt32(2, itr->second.seasonCount);
                stmt->setUInt16(3, itr->second.flags);
                stmt->setUInt32(4, GetGUIDLow());
                stmt->setUInt16(5, itr->first);
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.state = PLAYERCURRENCY_UNCHANGED;
    }
}

void Player::SendNewCurrency(uint32 id) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return;

    ByteBuffer currencyData;
    WorldPacket packet(SMSG_INIT_CURRENCY, 3 + 1 + 4 + 4 + 4 + 4);
    packet.WriteBits(1, 21);

    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
    if (!entry) // should never happen
        return;

    uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
    uint32 weekCount = itr->second.weekCount / precision;
    uint32 weekCap = GetCurrencyWeekCap(entry) / precision;
    uint32 seasonCount = itr->second.flags / precision;
    bool validForSeason = seasonCount != 0 && (entry->ID == CURRENCY_TYPE_CONQUEST_POINTS || entry->ID == CURRENCY_TYPE_HONOR_POINTS || entry->ID == CURRENCY_TYPE_JUSTICE_POINTS || entry->ID == CURRENCY_TYPE_VALOR_POINTS);

    packet.WriteBit(validForSeason);
    packet.WriteBits(itr->second.flags, 5);
    packet.WriteBit(weekCap);
    packet.WriteBit(weekCount);

    packet.FlushBits();

    if (weekCount)
        packet << uint32(weekCount);

    packet << uint32(entry->ID);

    if (validForSeason)
        packet << uint32(seasonCount);

    packet << uint32(itr->second.totalCount / precision);

    if (weekCap)
        packet << uint32(weekCap);

    GetSession()->SendPacket(&packet);
}

void Player::SendCurrencies() const
{
    ByteBuffer currencyData;
    WorldPacket packet(SMSG_INIT_CURRENCY, 3 + (_currencyStorage.size() * (1 + 4 + 4 + 4 + 4)));
    size_t count_pos = packet.bitwpos();
    packet.WriteBits(_currencyStorage.size(), 21);

    size_t count = 0;
    for (PlayerCurrenciesMap::const_iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);

        // not send init meta currencies.
        if (!entry || entry->Category == CURRENCY_CATEGORY_META_CONQUEST)
            continue;

        uint32 precision = (entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
        uint32 weekCount = itr->second.weekCount / precision;
        uint32 weekCap = GetCurrencyWeekCap(entry) / precision;
        uint32 seasonCount = itr->second.seasonCount / precision;
        bool validForSeason = seasonCount != 0 && (entry->ID == CURRENCY_TYPE_CONQUEST_POINTS || entry->ID == CURRENCY_TYPE_HONOR_POINTS || entry->ID == CURRENCY_TYPE_JUSTICE_POINTS || entry->ID == CURRENCY_TYPE_VALOR_POINTS);

        packet.WriteBit(validForSeason);
        packet.WriteBits(itr->second.flags, 5);
        packet.WriteBit(weekCap);
        packet.WriteBit(weekCount);

        if (weekCount)
            currencyData << uint32(weekCount);

        currencyData << uint32(entry->ID);

        if (validForSeason)
            currencyData << uint32(seasonCount);

        currencyData << uint32(itr->second.totalCount / precision);

        if (weekCap)
            currencyData << uint32(weekCap);

        ++count;
    }

    packet.FlushBits();
    packet.append(currencyData);
    packet.PutBits(count_pos, count, 21);
    GetSession()->SendPacket(&packet);
}

void Player::SendPvpRewards() const
{
    uint32 capArenaOrRandomBg = GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ARENA, true);
    uint32 capRatedBg = GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_RATED_BG, true);
    uint32 capMax = std::max(capArenaOrRandomBg, capRatedBg);
    uint32 currentArenaOrRandomBg = GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_ARENA, true);
    uint32 currentRatedBg = GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_META_RATED_BG, true);
    uint32 currentMax = GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_POINTS, true);

    WorldPacket data(SMSG_REQUEST_PVP_REWARDS_RESPONSE, 24);
    data << capMax;
    data << currentArenaOrRandomBg;
    data << currentRatedBg;
    data << currentArenaOrRandomBg;
    data << uint32(sWorld->getIntConfig(CONFIG_CURRENCY_CONQUEST_POINTS_RATED_BG_REWARD) / 100);
    data << capArenaOrRandomBg;
    data << uint32(sWorld->getIntConfig(CONFIG_CURRENCY_CONQUEST_POINTS_ARENA_REWARD) / 100);
    data << capRatedBg;
    data << currentMax;
    data << capArenaOrRandomBg;
    GetSession()->SendPacket(&data);
}

uint32 Player::GetCurrency(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.totalCount / precision;
}

uint32 Player::GetCurrencyOnWeek(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.weekCount / precision;
}

uint32 Player::GetCurrencyOnSeason(uint32 id, bool usePrecision) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    uint32 precision = (usePrecision && currency->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return itr->second.seasonCount / precision;
}

bool Player::HasCurrency(uint32 id, uint32 count) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    return itr != _currencyStorage.end() && itr->second.totalCount >= count;
}

void Player::ModifyCurrencyFlag(uint32 id, uint8 flag)
{
    if (!id)
        return;

    if (_currencyStorage.find(id) == _currencyStorage.end())
        return;

    _currencyStorage[id].flags = flag;
    if (_currencyStorage[id].state != PLAYERCURRENCY_NEW)
        _currencyStorage[id].state = PLAYERCURRENCY_CHANGED;
}

void Player::ModifyCurrency(uint32 id, int32 count, bool printLog/* = true*/, bool ignoreMultipliers/* = false*/, bool ignoreLimit /* = false */)
{
    if (!count)
        return;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    ASSERT(currency);

    if (!ignoreMultipliers)
        count *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_CURRENCY_GAIN, id);

    if (!ignoreLimit && currency->Category == CURRENCY_CATEGORY_META_CONQUEST)
    {
        ModifyCurrencyMetaConquest(currency, count, printLog);
        return;
    }

    int32 countBeforCap = count;

    int32 precision = currency->Flags & CURRENCY_FLAG_HIGH_PRECISION ? CURRENCY_PRECISION : 1;
    uint32 oldTotalCount = 0;
    uint32 oldWeekCount = 0;
    uint32 oldSeasonCount = 0;

    PlayerCurrenciesMap::iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonCount = 0;
        cur.flags = 0;
        _currencyStorage[id] = cur;
        itr = _currencyStorage.find(id);
    }
    else
    {
        oldTotalCount = itr->second.totalCount;
        oldWeekCount = itr->second.weekCount;
        oldSeasonCount = itr->second.seasonCount;
    }

    // count can't be more then weekCap if used (weekCap > 0)
    uint32 weekCap = GetCurrencyWeekCap(currency);
    if (!ignoreLimit && weekCap && count > int32(weekCap))
        count = weekCap;

    // count can't be more then totalCap if used (totalCap > 0)
    uint32 totalCap = GetCurrencyTotalCap(currency);
    if (totalCap && count > int32(totalCap))
        count = totalCap;

    int32 newSeasonCount = !ignoreLimit ? int32(oldSeasonCount) + (count > 0 ? count : 0) : int32(oldSeasonCount);
    if (newSeasonCount < 0)
        newSeasonCount = 0;

    int32 newTotalCount = int32(oldTotalCount) + count;
    if (newTotalCount < 0)
        newTotalCount = 0;

    int32 newWeekCount = !ignoreLimit ? (int32(oldWeekCount) + (count > 0 ? count : 0)) : int32(oldWeekCount);
    if (newWeekCount < 0)
        newWeekCount = 0;

    if (!ignoreLimit)
    {
        // if we get more then weekCap just set to limit
        if (weekCap && int32(weekCap) < newWeekCount)
        {
            count -= (newWeekCount - weekCap);
            newWeekCount = int32(weekCap);
            // weekCap - oldWeekCount always >= 0 as we set limit before!
            newTotalCount = oldTotalCount + count;
            newSeasonCount = oldSeasonCount + count;
        }

        // if we get more then totalCap set to maximum;
        if (totalCap && int32(totalCap) < newTotalCount)
        {
            count -= (newTotalCount - totalCap);
            newWeekCount = oldWeekCount + count;
            newTotalCount = int32(totalCap);
            newSeasonCount = oldSeasonCount + count;
        }
    }

    if (uint32(newTotalCount) != oldTotalCount)
    {
        if (itr->second.state != PLAYERCURRENCY_NEW)
            itr->second.state = PLAYERCURRENCY_CHANGED;

        itr->second.totalCount = newTotalCount;
        itr->second.weekCount = newWeekCount;
        itr->second.seasonCount = newSeasonCount;

        if (count > 0 && !ignoreLimit)
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_CURRENCY, id, count);

        TC_LOG_INFO("currency", "Player::ModifyCurrency player: %u, currency: %u, count: %u, totalCount: %u, weekCount: %u, seasonCount: %u", GetGUIDLow(), id, count, newTotalCount, newWeekCount, newSeasonCount);

        if (currency->Category == CURRENCY_CATEGORY_META_CONQUEST)
        {
            // count was changed to week limit, now we can modify original points.
            ModifyCurrency(CURRENCY_TYPE_CONQUEST_POINTS, count, printLog);
            return;
        }

        bool validForSeason = newSeasonCount != 0 && (currency->ID == CURRENCY_TYPE_CONQUEST_POINTS || currency->ID == CURRENCY_TYPE_HONOR_POINTS || currency->ID == CURRENCY_TYPE_JUSTICE_POINTS || currency->ID == CURRENCY_TYPE_VALOR_POINTS);
        WorldPacket packet(SMSG_UPDATE_CURRENCY, 12);

        packet << uint32(id);
        packet << uint32(0);
        packet << uint32(newTotalCount / precision);

        packet.WriteBit(weekCap != 0);
        packet.WriteBit(!printLog); // print in log
        packet.WriteBit(validForSeason);

        packet.FlushBits();

        if (weekCap)
            packet << uint32(newWeekCount / precision);

        if (validForSeason)
            packet << uint32(newSeasonCount / precision);

        GetSession()->SendPacket(&packet);
    }

    if (id == CURRENCY_TYPE_VALOR_POINTS)
        UpdateValorOfTheAncients();

    if (Group* group = GetGroup())
        if (countBeforCap> 0 && group->IsLogging())
            group->LogEvent("Currency recieved: %s, currency: %s, count: %i, count received: %i", Group::Format(this).c_str(), currency->Name[DEFAULT_LOCALE], countBeforCap, count);
}

void Player::SetCurrency(uint32 id, uint32 count, bool /*printLog*/ /*= true*/)
{
    PlayerCurrenciesMap::iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = count;
        cur.weekCount = 0;
        _currencyStorage[id] = cur;
    }
}

uint32 Player::GetCurrencyWeekCap(uint32 id, bool usePrecision) const
{
    CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id);
    if (!entry)
        return 0;

    uint32 precision = (usePrecision && entry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

    return GetCurrencyWeekCap(entry) / precision;
}

void Player::ResetCurrencyWeekCap()
{
    TC_LOG_INFO("currency", "Player::ResetCurrencyWeekCap player: %u", GetGUIDLow());

    for (auto&& itr : _currencyStorage)
    {
        itr.second.weekCount = 0;
        itr.second.state = PLAYERCURRENCY_CHANGED;
    }

    WorldPacket data(SMSG_WEEKLY_RESET_CURRENCY, 0);
    SendDirectMessage(&data);
}

uint32 Player::GetCurrencyWeekCap(CurrencyTypesEntry const* currency) const
{
    if (!currency)
        return 0;

    uint32 cap = currency->WeekCap;

    switch (currency->ID)
    {
        case CURRENCY_TYPE_CONQUEST_META_ARENA:        
        {
            cap = Trinity::Currency::ConquestRatingCalculator(GetMaxArenaRating()) * CURRENCY_PRECISION;
            break;
        }
        case CURRENCY_TYPE_CONQUEST_META_RATED_BG:
        {
            cap = Trinity::Currency::BgConquestRatingCalculator(GetMaxArenaRating()) * CURRENCY_PRECISION;
            break;
        }
    }

    return cap;
}

uint32 Player::GetCurrencyTotalCap(CurrencyTypesEntry const* currency) const
{
    uint32 cap = currency->TotalCap;

    switch (currency->ID)
    {
        case CURRENCY_TYPE_HONOR_POINTS:
        {
            uint32 honorcap = sWorld->getIntConfig(CONFIG_CURRENCY_MAX_HONOR_POINTS);
            if (honorcap > 0)
                cap = honorcap;
            break;
        }
        case CURRENCY_TYPE_JUSTICE_POINTS:
        {
            uint32 justicecap = sWorld->getIntConfig(CONFIG_CURRENCY_MAX_JUSTICE_POINTS);
            if (justicecap > 0)
                cap = justicecap;
            break;
        }
    }

    return cap;
}

void Player::UpdateConquestCurrencyCap(uint32 currency)
{
    uint32 currenciesToUpdate[2] = { currency, CURRENCY_TYPE_CONQUEST_POINTS };

    for (uint32 i = 0; i < 2; ++i)
    {
        CurrencyTypesEntry const* currencyEntry = sCurrencyTypesStore.LookupEntry(currenciesToUpdate[i]);
        if (!currencyEntry)
            continue;

        uint32 precision = (currencyEntry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? 100 : 1;
        uint32 cap = GetCurrencyWeekCap(currencyEntry);

        WorldPacket packet(SMSG_UPDATE_CURRENCY_WEEK_LIMIT, 8);
        packet << uint32(cap / precision);
        packet << uint32(currenciesToUpdate[i]);
        GetSession()->SendPacket(&packet);
    }
}

void Player::SetInGuild(uint32 guildId)
{
    if (guildId)
        SetUInt64Value(OBJECT_FIELD_DATA, MAKE_NEW_GUID(guildId, 0, HIGHGUID_GUILD));
    else
        SetUInt64Value(OBJECT_FIELD_DATA, 0);

    ApplyModFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GUILD_LEVEL_ENABLED, guildId != 0 && sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED));
    SetUInt16Value(OBJECT_FIELD_TYPE, 1, guildId != 0);
}

uint32 Player::GetGuildIdFromDB(uint64 guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt32(0, GUID_LOPART(guid));
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        return result->Fetch()[0].GetUInt32();

    return 0;
}

uint8 Player::GetRankFromDB(uint64 guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt32(0, GUID_LOPART(guid));
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        return result->Fetch()[1].GetUInt8();

    return 0;
}

uint32 Player::GetZoneIdFromDB(uint64 guid)
{
    uint32 guidLow = GUID_LOPART(guid);
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
    stmt->setUInt32(0, guidLow);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;
    Field* fields = result->Fetch();
    uint32 zone = fields[0].GetUInt16();

    if (!zone)
    {
        // stored zone is zero, use generic and slow zone detection
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
        stmt->setUInt32(0, guidLow);
        PreparedQueryResult result = CharacterDatabase.Query(stmt);

        if (!result)
            return 0;
        fields = result->Fetch();
        uint32 map = fields[0].GetUInt16();
        float posx = fields[1].GetFloat();
        float posy = fields[2].GetFloat();
        float posz = fields[3].GetFloat();

        if (!sMapStore.LookupEntry(map))
            return 0;

        zone = sMapMgr->GetZoneId(map, posx, posy, posz);

        if (zone > 0)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ZONE);

            stmt->setUInt16(0, uint16(zone));
            stmt->setUInt32(1, guidLow);

            CharacterDatabase.Execute(stmt);
        }
    }

    return zone;
}

uint32 Player::GetLevelFromDB(uint64 guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_LEVEL);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;

    Field* fields = result->Fetch();
    uint8 level = fields[0].GetUInt8();

    return level;
}

void Player::UpdateArea(uint32 newArea)
{
    // FFA_PVP flags are area and not zone id dependent
    // so apply them accordingly
    m_areaUpdateId    = newArea;

    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    AreaTableEntry const* area = sAreaTableStore.LookupEntry(newArea);
    pvpInfo.IsInFFAPvPArea = area && (area->flags & AREA_FLAG_ARENA);
    UpdatePvPState(true);

    UpdateAreaDependentAuras(newArea);

    // previously this was in UpdateZone (but after UpdateArea) so nothing will break
    pvpInfo.IsInNoPvPArea = false;
    if (area && area->IsSanctuary())    // in sanctuary
    {
        SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_SANCTUARY);
        pvpInfo.IsInNoPvPArea = true;
        CombatStopWithPets();
    }
    else
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_SANCTUARY);

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);

    if (GetGroup())
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_AREA | GROUP_UPDATE_FLAG_PHASE);
}

void Player::UpdateZone(uint32 newZone, uint32 newArea)
{
    phaseMgr.AddUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);

    if (m_zoneUpdateId != newZone)
    {
        sOutdoorPvPMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sOutdoorPvPMgr->HandlePlayerEnterZone(this, newZone);
        sBattlefieldMgr->HandlePlayerLeaveZone(this, m_zoneUpdateId);
        sBattlefieldMgr->HandlePlayerEnterZone(this, newZone);
        SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
        if (Guild* guild = GetGuild())
            guild->UpdateMemberData(this, GUILD_MEMBER_DATA_ZONEID, newZone);

        // Let there be light! :3
        if (m_zoneUpdateId == 876 || newZone == 876) // GM Island
        {
            WorldPacket data(SMSG_OVERRIDE_LIGHT, 12);
            data << uint32(newZone == 876 ? 500 : 0);
            data << uint32(2488);
            data << uint32(1);
            SendDirectMessage(&data);
        }
    }

    // group update
    if (GetGroup())
        SetGroupUpdateFlag(GROUP_UPDATE_FULL);

    m_zoneUpdateId    = newZone;
    m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;

    // zone changed, so area changed as well, update it
    UpdateArea(newArea);

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(newZone);
    if (!zone)
        return;

    if (sWorld->getBoolConfig(CONFIG_WEATHER) && !HasAuraType(SPELL_AURA_FORCE_WEATHER))
    {
        if (Weather* weather = WeatherMgr::FindWeather(zone->ID))
            weather->SendWeatherUpdateToPlayer(this);
        else
        {
            if (!WeatherMgr::AddWeather(zone->ID))
            {
                // send fine weather packet to remove old zone's weather
                WeatherMgr::SendFineWeatherUpdateToPlayer(this);
            }
        }
    }

    sScriptMgr->OnPlayerUpdateZone(this, newZone, newArea);

    // in PvP, any not controlled zone (except zone->team == 6, default case)
    // in PvE, only opposition team capital
    switch (zone->team)
    {
        case AREATEAM_ALLY:
            pvpInfo.IsInHostileArea = GetTeam() != ALLIANCE && (sWorld->IsPvPRealm() || zone->flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_HORDE:
            pvpInfo.IsInHostileArea = GetTeam() != HORDE && (sWorld->IsPvPRealm() || zone->flags & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_NONE:
            // overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
            pvpInfo.IsInHostileArea = sWorld->IsPvPRealm() || InBattleground() || zone->flags & AREA_FLAG_WINTERGRASP;
            break;
        default:                                            // 6 in fact
            pvpInfo.IsInHostileArea = false;
            break;
    }

    // Treat players having a quest flagging for PvP as always in hostile area
    pvpInfo.IsHostile = pvpInfo.IsInHostileArea || HasPvPForcingQuest();

    if (zone->flags & AREA_FLAG_CAPITAL)                     // Is in a capital city
    {
        if (!pvpInfo.IsHostile || zone->IsSanctuary() || zone->team == AREATEAM_NONE)
        {
            SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
            SetRestType(REST_TYPE_IN_CITY);
            InnEnter(time(0), GetMapId(), 0, 0, 0);
        }
        pvpInfo.IsInNoPvPArea = true;
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
        {
            if (GetRestType() == REST_TYPE_IN_TAVERN)        // Still inside a tavern or has recently left
            {
                // Remove rest state if we have recently left a tavern.
                if (GetMapId() != GetInnPosMapId() || GetExactDist(GetInnPosX(), GetInnPosY(), GetInnPosZ()) > 1.0f)
                {
                    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                    SetRestType(REST_TYPE_NO);
                }
            }
            else                                             // Recently left a capital city
            {
                RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                SetRestType(REST_TYPE_NO);
            }
        }
    }

    UpdatePvPState();

    // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
    // if player resurrected at teleport this will be applied in resurrect code
    if (IsAlive())
        DestroyZoneLimitedItem(true, newZone);

    // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
    AutoUnequipOffhandIfNeed();

    // recent client version not send leave/join channel packets for built-in local channels
    UpdateLocalChannels(newZone);

    UpdateZoneDependentAuras(newZone);

    phaseMgr.RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);

    uint32 questId = 0;
    if (GetTeamId() == TEAM_ALLIANCE)
        questId = 33229;
    else
        questId = 33230;

    if (questId && newZone == 5840 && getLevel() == 90 && GetQuestStatus(questId) == QUEST_STATUS_NONE)
    {
        if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
        {
            AddQuest(quest, this);
            PlayerTalkClass->SendQuestGiverQuestDetails(quest, GetGUID(), true, true);
            if (CanCompleteQuest(quest->GetQuestId()))
                CompleteQuest(quest->GetQuestId());
        }
    }
}

//If players are too far away from the duel flag... they lose the duel
void Player::CheckDuelDistance(time_t currTime)
{
    if (!duel)
        return;

    uint64 duelFlagGUID = GetUInt64Value(PLAYER_FIELD_DUEL_ARBITER);
    GameObject* obj = GetMap()->GetGameObject(duelFlagGUID);
    if (!obj)
        return;

    if (duel->outOfBound == 0)
    {
        if (!IsWithinDistInMap(obj, 50))
        {
            duel->outOfBound = currTime;

            WorldPacket data(SMSG_DUEL_OUTOFBOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
    }
    else
    {
        if (IsWithinDistInMap(obj, 40))
        {
            duel->outOfBound = 0;

            WorldPacket data(SMSG_DUEL_INBOUNDS, 0);
            GetSession()->SendPacket(&data);
        }
        else if (currTime >= (duel->outOfBound+10))
            DuelComplete(DUEL_FLED);
    }
}

bool Player::IsOutdoorPvPActive()
{
    return IsAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !IsInFlight();
}

void Player::DuelComplete(DuelCompleteType type)
{
    // duel not requested
    if (!duel)
        return;

    TC_LOG_DEBUG("entities.unit", "Duel Complete %s %s", GetName().c_str(), duel->opponent->GetName().c_str());

    WorldPacket data(SMSG_DUEL_COMPLETE, 1);
    data.WriteBit(type != DUEL_INTERRUPTED);
    data.FlushBits();
    GetSession()->SendPacket(&data);

    if (duel->opponent->GetSession())
        duel->opponent->GetSession()->SendPacket(&data);

    if (type != DUEL_INTERRUPTED)
    {
        data.Initialize(SMSG_DUEL_WINNER, 1 + 20);          // we guess size
        data.WriteBit(type != DUEL_WON);                    // 0 = just won; 1 = fled
        data.WriteBits(duel->opponent->GetName().length(), 6);
        data.WriteBits(GetName().length(), 6);
        data << uint32(realmID);
        data.WriteString(duel->opponent->GetName());
        data << uint32(realmID);
        data.WriteString(GetName());
        SendMessageToSet(&data, true);
    }

    sScriptMgr->OnPlayerDuelEnd(duel->opponent, this, type);

    switch (type)
    {
        case DUEL_FLED:
            // if initiator and opponent are on the same team
            // or initiator and opponent are not PvP enabled, forcibly stop attacking
            if (duel->initiator->GetTeam() == duel->opponent->GetTeam())
            {
                duel->initiator->AttackStop();
                duel->opponent->AttackStop();
            }
            else
            {
                if (!duel->initiator->IsPvP())
                    duel->initiator->AttackStop();
                if (!duel->opponent->IsPvP())
                    duel->opponent->AttackStop();
            }
            break;
        case DUEL_WON:
            duel->opponent->CombatStopWithPets(true);
            CombatStopWithPets(true);
            CastSpell(this, 7267, true);                  // beg

            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOSE_DUEL, 1);
            duel->opponent->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_WIN_DUEL, 1);

            // Credit for quest Death's Challenge
            if (getClass() == CLASS_DEATH_KNIGHT && duel->opponent->GetQuestStatus(12733) == QUEST_STATUS_INCOMPLETE)
                duel->opponent->CastSpell(duel->opponent, 52994, true);

            // Honor points after duel (the winner) - ImpConfig
            if (uint32 amount = sWorld->getIntConfig(CONFIG_HONOR_AFTER_DUEL))
                duel->opponent->RewardHonor(NULL, 1, amount);

            break;
        default:
            break;
    }

    // Victory emote spell
    if (type != DUEL_INTERRUPTED)
        duel->opponent->CastSpell(duel->opponent, 52852, true);

    //Remove Duel Flag object
    GameObject* obj = GetMap()->GetGameObject(GetUInt64Value(PLAYER_FIELD_DUEL_ARBITER));
    if (obj)
        duel->initiator->RemoveGameObject(obj, true);

    /* remove auras */
    AuraApplicationMap &itsAuras = duel->opponent->GetAppliedAuras();
    for (AuraApplicationMap::iterator i = itsAuras.begin(); i != itsAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && aura->GetCasterGUID() == GetGUID() && aura->GetApplyTime() >= duel->startTime)
            duel->opponent->RemoveAura(i);
        else
            ++i;
    }

    AuraApplicationMap &myAuras = GetAppliedAuras();
    for (AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && aura->GetCasterGUID() == duel->opponent->GetGUID() && aura->GetApplyTime() >= duel->startTime)
            RemoveAura(i);
        else
            ++i;
    }

    // cleanup combo points
    if (GetComboTarget() == duel->opponent->GetGUID())
        ClearComboPoints();
    else if (GetComboTarget() == duel->opponent->GetPetGUID())
        ClearComboPoints();

    if (duel->opponent->GetComboTarget() == GetGUID())
        duel->opponent->ClearComboPoints();
    else if (duel->opponent->GetComboTarget() == GetPetGUID())
        duel->opponent->ClearComboPoints();

    //cleanups
    SetUInt64Value(PLAYER_FIELD_DUEL_ARBITER, 0);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);
    duel->opponent->SetUInt64Value(PLAYER_FIELD_DUEL_ARBITER, 0);
    duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    delete duel->opponent->duel;
    duel->opponent->duel = NULL;
    delete duel;
    duel = NULL;
}

//---------------------------------------------------------//

void Player::UpdateAllowedItemLevel()
{
    uint32 minItemLevel = 0; // Not used currently
    uint32 maxItemLevel = 0;

    bool bgArena = GetMap()->IsBattlegroundOrArena();
    if (bgArena && sWorld->getBoolConfig(CONFIG_ENABLE_ILVL_SCALING_PVP))
        maxItemLevel = sWorld->getIntConfig(CONFIG_ILVL_SCALING_PVP);
    else if (sWorld->getBoolConfig(CONFIG_ENABLE_ILVL_SCALING_PVE) && GetMap()->IsDungeon() && GetMap()->IsChallengeDungeon())
        maxItemLevel = sWorld->getIntConfig(CONFIG_ILVL_SCALING_PVE);

    for (uint8 slot = 0; slot < EQUIPMENT_SLOT_END; slot++)
    {
        if (Item* item = m_items[slot])
        {
            // In client this code is in GetStatValue, but we can't do so, because we don't calculate summary stat on item changes
            uint32 itemItemLevel = item->GetBaseItemLevel();
            uint32 finalItemLevel = itemItemLevel;
            if (minItemLevel && minItemLevel > itemItemLevel)
                finalItemLevel = minItemLevel;
            if (maxItemLevel && maxItemLevel < itemItemLevel)
                finalItemLevel = maxItemLevel;

            // update stats for real itemlevel
            if (item->GetItemLevel() != itemItemLevel)
            {
                _ApplyItemBonuses(item, slot, false);
                item->OverrideItemLevel(itemItemLevel);
                _ApplyItemBonuses(item, slot, true);
            }

            // rescale items if it need
            if ((!bgArena || !item->IsPvPItem()) && item->GetItemLevel() != finalItemLevel)
            {
                _ApplyItemBonuses(item, slot, false);
                item->OverrideItemLevel(finalItemLevel); // Now GetItemLevel returns finalItemLevel
                _ApplyItemBonuses(item, slot, true);
            }
        }
    }

    SetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL, minItemLevel);
    SetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL, maxItemLevel);
}

void Player::ReapplyItemsBonuses()
{
    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
        {
            if (item->IsBroken())
                continue;

            ItemTemplate const* proto = item->GetTemplate();
            if (!proto)
                continue;

            ApplyItemEquipSpell(item, false);
            ApplyItemEquipSpell(item, true);

            if (proto->Socket[0].Color)
            {
                ApplyEnchantment(item, false);
                ApplyEnchantment(item, true);
            }

            if (proto->ItemSet)
            {
                RemoveItemsSetItem(this, proto);
                AddItemsSetItem(this, item);
            }
        }
    }
}

void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();

    if (!proto)
        return;

    // not apply/remove mods for broken item
    if (item->IsBroken())
        return;

    TC_LOG_INFO("entities.player.items", "applying mods for item %u ", item->GetGUIDLow());

    uint8 attacktype = Player::GetAttackBySlot(slot);

    if (proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
        CorrectMetaGemEnchants(slot, apply);

    if (attacktype < MAX_ATTACK)
        _ApplyWeaponDependentAuraMods(item, WeaponAttackType(attacktype), apply);

    _ApplyItemBonuses(item, slot, apply);
    ApplyItemEquipSpell(item, apply);
    ApplyEnchantment(item, apply);

    // Killer instinct
    if (AuraEffect* killerInstinct = GetAuraEffect(108300, EFFECT_0))
        killerInstinct->RecalculateAmount();

    TC_LOG_DEBUG("entities.player.items", "_ApplyItemMods complete.");
}

void Player::_ApplyItemBonuses(Item const* item, uint8 slot, bool apply, bool only_level_scale /*= false*/)
{
    if (slot >= INVENTORY_SLOT_BAG_END)
        return;

    ItemTemplate const* proto = item->GetTemplate();

    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
    if (only_level_scale && !ssd)
        return;

    // req. check at equip, but allow use for extended range if range limit max level, set proper level
    uint32 ssd_level = getLevel();
    if (ssd && ssd_level > ssd->MaxLevel)
        ssd_level = ssd->MaxLevel;

    ScalingStatValuesEntry const* ssv = ssd ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
    if (only_level_scale && !ssv)
        return;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
    {
        uint32 statType = 0;
        int32  val = 0;
        // If set ScalingStatDistribution need get stats and values from it
        if (ssd && ssv)
        {
            if (ssd->StatMod[i] < 0)
                continue;
            statType = ssd->StatMod[i];
            val = (ssv->GetStatMultiplier(proto->InventoryType) * ssd->Modifier[i]) / 10000;
        }
        else
        {
            statType = proto->ItemStat[i].ItemStatType;
            val = item->GetStatValue(i);
        }

        if (val == 0)
            continue;

        switch (statType)
        {
            case ITEM_MOD_MANA:
                HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_HEALTH:                           // modify HP
                HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_AGILITY:                          // modify agility
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_AGILITY, float(val), apply);
                break;
            case ITEM_MOD_STRENGTH:                         //modify strength
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_STRENGTH, float(val), apply);
                break;
            case ITEM_MOD_INTELLECT:                        //modify intellect
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_INTELLECT, float(val), apply);
                break;
            case ITEM_MOD_SPIRIT:                           //modify spirit
                HandleStatModifier(UNIT_MOD_STAT_SPIRIT, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_SPIRIT, float(val), apply);
                break;
            case ITEM_MOD_STAMINA:                          //modify stamina
                HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
                ApplyStatBuffMod(STAT_STAMINA, float(val), apply);
                break;
            case ITEM_MOD_DEFENSE_SKILL_RATING:
                ApplyRatingMod(CR_DEFENSE_SKILL, int32(val), apply);
                break;
            case ITEM_MOD_DODGE_RATING:
                ApplyRatingMod(CR_DODGE, int32(val), apply);
                break;
            case ITEM_MOD_PARRY_RATING:
                ApplyRatingMod(CR_PARRY, int32(val), apply);
                break;
            case ITEM_MOD_BLOCK_RATING:
                ApplyRatingMod(CR_BLOCK, int32(val), apply);
                break;
            case ITEM_MOD_HIT_MELEE_RATING:
                ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
                break;
            case ITEM_MOD_HIT_RANGED_RATING:
                ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
                break;
            case ITEM_MOD_HIT_SPELL_RATING:
                ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
                break;
            case ITEM_MOD_CRIT_MELEE_RATING:
                ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
                break;
            case ITEM_MOD_CRIT_RANGED_RATING:
                ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
                break;
            case ITEM_MOD_CRIT_SPELL_RATING:
                ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
                break;
            // case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
            //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
            //     break;
            // case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
            //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
            //     break;
            // case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
            //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
            //     break;
            // case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
            //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
            //     break;
            case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val), apply);
                break;
            // case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
            //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
            //     break;
            case ITEM_MOD_HASTE_MELEE_RATING:
                ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
                break;
            case ITEM_MOD_HASTE_RANGED_RATING:
                ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
                break;
            case ITEM_MOD_HASTE_SPELL_RATING:
                ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
                break;
            case ITEM_MOD_HIT_RATING:
                ApplyRatingMod(CR_HIT_MELEE, int32(val), apply);
                ApplyRatingMod(CR_HIT_RANGED, int32(val), apply);
                ApplyRatingMod(CR_HIT_SPELL, int32(val), apply);
                break;
            case ITEM_MOD_CRIT_RATING:
                ApplyRatingMod(CR_CRIT_MELEE, int32(val), apply);
                ApplyRatingMod(CR_CRIT_RANGED, int32(val), apply);
                ApplyRatingMod(CR_CRIT_SPELL, int32(val), apply);
                break;
            // case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
            //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, int32(val), apply);
            //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, int32(val), apply);
            //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, int32(val), apply);
            //     break;
            // case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
            //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
            //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, int32(val), apply);
            //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, int32(val), apply);
            //     break;
            case ITEM_MOD_RESILIENCE_RATING:
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(val), apply);
                break;
            case ITEM_MOD_HASTE_RATING:
                ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
                ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
                ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
                break;
            case ITEM_MOD_EXPERTISE_RATING:
                ApplyRatingMod(CR_EXPERTISE, int32(val), apply);
                break;
            case ITEM_MOD_ATTACK_POWER:
                HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
                break;
            case ITEM_MOD_RANGED_ATTACK_POWER:
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
                break;
            case ITEM_MOD_MANA_REGENERATION:
                ApplyManaRegenBonus(int32(val), apply);
                break;
            case ITEM_MOD_ARMOR_PENETRATION_RATING:
                ApplyRatingMod(CR_ARMOR_PENETRATION, int32(val), apply);
                break;
            case ITEM_MOD_SPELL_POWER:
                ApplySpellPowerBonus(int32(val), apply);
                break;
            case ITEM_MOD_HEALTH_REGEN:
                ApplyHealthRegenBonus(int32(val), apply);
                break;
            case ITEM_MOD_SPELL_PENETRATION:
                ApplySpellPenetrationBonus(val, apply);
                break;
            case ITEM_MOD_MASTERY_RATING:
                ApplyRatingMod(CR_MASTERY, int32(val), apply);
                break;
            case ITEM_MOD_FIRE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_FROST_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_HOLY_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_SHADOW_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_NATURE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_ARCANE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_PVP_POWER:
                ApplyRatingMod(CR_PVP_POWER, int32(val), apply);
                break;
        }
    }

    // Apply Spell Power from ScalingStatValue if set
    if (ssv && proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON)
        if (int32 spellbonus = int32(ssv->Spellpower))
            ApplySpellPowerBonus(spellbonus, apply);

    // If set ScalingStatValue armor get it or use item armor
    uint32 armor = proto->Armor;
    if (proto->Class == ITEM_CLASS_ARMOR)
    {
        if (ssv)
            armor = ssv->GetArmor(proto->InventoryType, proto->SubClass - 1);
        else
            armor = proto->CalculateArmor(item->GetItemLevel());
    }

    if (armor)
    {
        UnitModifierType modType = TOTAL_VALUE;
        if (proto->Class == ITEM_CLASS_ARMOR)
        {
            switch (proto->SubClass)
            {
                case ITEM_SUBCLASS_ARMOR_CLOTH:
                case ITEM_SUBCLASS_ARMOR_LEATHER:
                case ITEM_SUBCLASS_ARMOR_MAIL:
                case ITEM_SUBCLASS_ARMOR_PLATE:
                case ITEM_SUBCLASS_ARMOR_SHIELD:
                    modType = BASE_VALUE;
                break;
            }
        }
        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
    }

    // Add armor bonus from ArmorDamageModifier if > 0
    if (proto->ArmorDamageModifier > 0)
        HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->ArmorDamageModifier), apply);

    WeaponAttackType attType = BASE_ATTACK;

    if (slot == EQUIPMENT_SLOT_MAINHAND && proto->IsRangedInventoryType())
        attType = RANGED_ATTACK;
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = OFF_ATTACK;

    if (CanUseAttackType(attType))
        ApplyWeaponDamage(slot, item, apply);
}

// I didn't find this in the client yet.
void Player::GetItemDamage(float& minDamage, float& maxDamage, Item const* item) const
{
    minDamage = maxDamage = 0;

    ItemTemplate const* proto = item->GetTemplate();
    if (proto->Class != ITEM_CLASS_WEAPON)
        return;

    if (proto->ScalingStatDistribution)
    {
        if (ScalingStatDistributionEntry const* ssd = sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution))
        {
            uint32 ssdLevel = getLevel();
            if (ssdLevel > ssd->MaxLevel)
                ssdLevel = ssd->MaxLevel;

            if (ScalingStatValuesEntry const* ssv = sScalingStatValuesStore.LookupEntry(ssdLevel))
            {
                // If set dpsMod in ScalingStatValue use it for min (70% from average), max (130% from average) damage
                float damageMultiplier = 0.0f;
                if (int32 extraDPS = ssv->GetDPSAndDamageMultiplier(proto->SubClass, proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON, &damageMultiplier))
                {
                    float average = extraDPS * proto->Delay / 1000.0f;
                    minDamage = (1.0f - damageMultiplier) * average;
                    maxDamage = (1.0f + damageMultiplier) * average;
                    return;
                }
            }
        }
    }

    // Hirelooms must be calculated above
    if (proto->Quality > ITEM_QUALITY_ARTIFACT)
        return;

    DBCStorage<ItemDamageEntry>* store = NULL;

    switch (proto->InventoryType)
    {
        case INVTYPE_AMMO:
            store = &sItemDamageAmmoStore;
            break;
        case INVTYPE_2HWEAPON:
            if (proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON)
                store = &sItemDamageTwoHandCasterStore;
            else
                store = &sItemDamageTwoHandStore;
            break;
        case INVTYPE_RANGED:
        case INVTYPE_THROWN:
        case INVTYPE_RANGEDRIGHT:
            switch (proto->SubClass)
            {
                case ITEM_SUBCLASS_WEAPON_WAND:
                    store = &sItemDamageWandStore;
                    break;
                case ITEM_SUBCLASS_WEAPON_THROWN:
                    store = &sItemDamageThrownStore;
                    break;
                case ITEM_SUBCLASS_WEAPON_BOW:
                case ITEM_SUBCLASS_WEAPON_GUN:
                case ITEM_SUBCLASS_WEAPON_CROSSBOW:
                    store = &sItemDamageRangedStore;
                    break;
                default:
                    return;
            }
            break;
        case INVTYPE_WEAPON:
        case INVTYPE_WEAPONMAINHAND:
        case INVTYPE_WEAPONOFFHAND:
            if (proto->Flags2 & ITEM_FLAGS_EXTRA_CASTER_WEAPON)
                store = &sItemDamageOneHandCasterStore;
            else
                store = &sItemDamageOneHandStore;
            break;
        default:
            return;
    }

    if (!store)
        return;

    ItemDamageEntry const* damageInfo = store->LookupEntry(item->GetItemLevel());
    if (!damageInfo)
        return;

    float dps = damageInfo->DPS[proto->Quality];
    float avgDamage = dps * proto->Delay * 0.001f;
    minDamage = (proto->StatScalingFactor * -0.5f + 1.0f) * avgDamage;
    maxDamage = floor(float(avgDamage* (proto->StatScalingFactor * 0.5f + 1.0f) + 0.5f)); // Inaccurate formula, +/-1 from client
}

void Player::ApplyWeaponDamage(uint8 slot, Item const* item, bool apply)
{
    ItemTemplate const* proto = item->GetTemplate();

    WeaponAttackType attType = BASE_ATTACK;
    float damage = 0.0f;

    if (slot == EQUIPMENT_SLOT_MAINHAND && proto->IsRangedInventoryType())
        attType = RANGED_ATTACK;
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = OFF_ATTACK;

    float minDamage;
    float maxDamage;
    GetItemDamage(minDamage, maxDamage, item);

    if (minDamage > 0)
    {
        damage = apply ? minDamage : BASE_MINDAMAGE;
        SetBaseWeaponDamage(attType, MINDAMAGE, damage);
    }

    if (maxDamage  > 0)
    {
        damage = apply ? maxDamage : BASE_MAXDAMAGE;
        SetBaseWeaponDamage(attType, MAXDAMAGE, damage);
    }

    if (proto->Delay && !IsInFeralForm())
    {
        if (slot == EQUIPMENT_SLOT_MAINHAND && proto->IsRangedInventoryType())
            SetAttackTime(RANGED_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_MAINHAND)
            SetAttackTime(BASE_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
        else if (slot == EQUIPMENT_SLOT_OFFHAND)
            SetAttackTime(OFF_ATTACK, apply ? proto->Delay: BASE_ATTACK_TIME);
    }

    if (CanModifyStats() && (damage || proto->Delay))
        UpdateDamagePhysical(attType);
}

void Player::_ApplyWeaponDependentAuraMods(Item* item, WeaponAttackType attackType, bool apply)
{
    AuraEffectList const& auraDamageFlatList = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
    for (AuraEffectList::const_iterator itr = auraDamageFlatList.begin(); itr != auraDamageFlatList.end(); ++itr)
        _ApplyWeaponDependentAuraDamageMod(item, attackType, *itr, apply);

    // Monk Weapon Override Driver
    if (AuraEffect* driver = GetAuraEffect(108562, EFFECT_0))
        driver->RecalculateAmount();

    // Glyph of Bladed Judgment
    if (AuraEffect* driver = GetAuraEffect(203782, EFFECT_0))
        driver->RecalculateAmount();

    // We CAN'T do it right now, it causes bugs.
    m_Events.Schedule(1, [=]
    {
        for (auto&& type : AuraEffect::WeaponDependingEffects())
            for (auto&& it : GetAuraEffectsByType(type))
                it->RecalculateAmount();
    });
}

void Player::_ApplyWeaponDependentAuraDamageMod(Item* item, WeaponAttackType attackType, AuraEffect const* aura, bool apply)
{
    // don't apply mod if item is broken or cannot be used
    if (item->IsBroken() || !CanUseAttackType(attackType))
        return;

    // ignore spell mods for not wands
    if ((aura->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) == 0 && (getClassMask() & CLASSMASK_WAND_USERS) == 0)
        return;

    // generic not weapon specific case processes in aura code
    if (aura->GetSpellInfo()->EquippedItemClass == -1)
        return;

    UnitMods unitMod = UNIT_MOD_END;
    switch (attackType)
    {
        case BASE_ATTACK:   unitMod = UNIT_MOD_DAMAGE_MAINHAND; break;
        case OFF_ATTACK:    unitMod = UNIT_MOD_DAMAGE_OFFHAND;  break;
        case RANGED_ATTACK: unitMod = UNIT_MOD_DAMAGE_RANGED;   break;
        default: return;
    }

    UnitModifierType unitModType = TOTAL_VALUE;
    switch (aura->GetAuraType())
    {
        case SPELL_AURA_MOD_DAMAGE_DONE:         unitModType = TOTAL_VALUE; break;
        default: return;
    }

    if (item->IsFitToSpellRequirements(aura->GetSpellInfo()))
    {
        HandleStatModifier(unitMod, unitModType, float(aura->GetAmount()), apply);
        if (unitModType == TOTAL_VALUE)
            ApplyModUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS, aura->GetAmount(), apply);
    }
}

void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
{
    if (!item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = proto->Spells[i];

        // no spell
        if (!spellData.SpellId)
            continue;

        // wrong triggering type
        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
            continue;

        // check if it is valid spell
        SpellInfo const* spellproto = sSpellMgr->GetSpellInfo(spellData.SpellId);
        if (!spellproto)
            continue;

        ApplyEquipSpell(spellproto, item, apply, form_change);
    }
}

void Player::ApplyEquipSpell(SpellInfo const* spellInfo, Item* item, bool apply, bool formChange, bool itemSet)
{
    if (apply)
    {
        // Item set bonuses and legendary cloacks must not work on challenge difficulty
        if (GetMap()->IsChallengeDungeon() && (itemSet || (item && item->IsLegendaryCloak())))
            return;

        // Cannot be used in this stance/form
        if (spellInfo->CheckShapeshift(GetShapeshiftForm()) != SPELL_CAST_OK)
            return;

        if (formChange)                                    // check aura active state from other form
        {
            AuraApplicationMapBounds range = GetAppliedAuras().equal_range(spellInfo->Id);
            for (AuraApplicationMap::const_iterator itr = range.first; itr != range.second; ++itr)
                if (!item || itr->second->GetBase()->GetCastItemGUID() == item->GetGUID())
                    return;
        }

        TC_LOG_DEBUG("entities.player", "WORLD: cast %s Equip spellId - %i", (item ? "item" : "itemset"), spellInfo->Id);

        if (itemSet && spellInfo->HasAttribute(SPELL_ATTR0_HIDDEN_CLIENTSIDE)) // Dunno why not all of them has this
            LearnSpell(spellInfo->Id, true);
        else
            CastSpell(this, spellInfo, true, item);
    }
    else
    {
        if (formChange)                                     // check aura compatibility
        {
            // Cannot be used in this stance/form
            if (spellInfo->CheckShapeshift(GetShapeshiftForm()) == SPELL_CAST_OK)
                return;                                     // and remove only not compatible at form change
        }

        if (item)
            RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
        else
            RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)

        if (itemSet)
            RemoveSpell(spellInfo->Id);
    }
}

void Player::UpdateEquipSpellsAtFormChange()
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] && !m_items[i]->IsBroken() && CanUseAttackType(GetAttackBySlot(i)))
        {
            ApplyItemEquipSpell(m_items[i], false, true);     // remove spells that not fit to form
            ApplyItemEquipSpell(m_items[i], true, true);      // add spells that fit form but not active
        }
    }

    // item set bonuses not dependent from item broken state
    for (size_t setindex = 0; setindex < ItemSetEff.size(); ++setindex)
    {
        ItemSetEffect* eff = ItemSetEff[setindex];
        if (!eff)
            continue;

        for (uint32 y = 0; y < MAX_ITEM_SET_SPELLS; ++y)
        {
            SpellInfo const* spellInfo = eff->spells[y];
            if (!spellInfo)
                continue;

            ApplyEquipSpell(spellInfo, NULL, false, true);       // remove spells that not fit to form
            ApplyEquipSpell(spellInfo, NULL, true, true);        // add spells that fit form but not active
        }
    }
}
void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procAttacker, uint32 procVictim, uint32 procEx, SpellInfo const* procSpell)
{
    if (!target || !target->IsAlive() || target == this)
        return;

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // If usable, try to cast item spell
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (!item->IsBroken() && CanUseAttackType(attType))
                if (ItemTemplate const* proto = item->GetTemplate())
                {
                    // Additional check for weapons
                    if (proto->Class == ITEM_CLASS_WEAPON)
                    {
                        // offhand item cannot proc from main hand hit etc
                        EquipmentSlots slot;
                        switch (attType)
                        {
                            case RANGED_ATTACK:
                            case BASE_ATTACK:
                                slot = EQUIPMENT_SLOT_MAINHAND; break;
                            case OFF_ATTACK:
                                slot = EQUIPMENT_SLOT_OFFHAND;  break;

                            default: slot = EQUIPMENT_SLOT_END; break;
                        }
                        if (slot != i)
                            continue;
                        // Check if item is useable (forms or disarm)
                        if (attType == BASE_ATTACK)
                            if (!IsUseEquipedWeapon(true) && !IsInFeralForm())
                                continue;
                    }
                    CastItemCombatSpell(target, attType, procAttacker, procVictim, procEx, item, proto, procSpell);
                }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procAttacker, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto, SpellInfo const* procSpell)
{
    // Can do effect if any damage done to target
    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
    //if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
    {
        for (uint8 i = 0; i < MAX_ITEM_SPELLS; ++i)
        {
            _Spell const& spellData = proto->Spells[i];

            // no spell
            if (!spellData.SpellId)
                continue;

            // wrong triggering type
            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
            if (!spellInfo)
            {
                TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
                continue;
            }

            if (procSpell && procSpell->Id == spellInfo->Id)
                continue;

            // not allow proc extra attack spell at extra attack
            if (m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
                return;

            float chance = (float)spellInfo->ProcChance;

            if (proto->SpellPPMRate)
            {
                uint32 WeaponSpeed = GetAttackTime(attType);
                chance = GetPPMProcChance(WeaponSpeed, proto->SpellPPMRate, spellInfo);
            }
            else if (chance > 100.0f)
                chance = GetWeaponProcChance();

            if (roll_chance_f(chance))
                CastSpell(target, spellInfo->Id, true, item);
        }
    }

    // item combat enchantments
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        if (e_slot > PRISMATIC_ENCHANTMENT_SLOT && e_slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!enchant)
            continue;

        if (enchant->RequiredLevel && getLevel() < enchant->RequiredLevel)
            continue;

        if (enchant->RequiredSkill && GetSkillValue(enchant->RequiredSkill) < enchant->RequiredSkillValue)
            continue;

        for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            if (enchant->Type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
                continue;

            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);

            if (entry && entry->procEx)
            {
                // Check hit/crit/dodge/parry requirement
                if ((entry->procEx & procEx) == 0)
                    continue;
            }
            else
            {
                // Can do effect if any damage done to target
                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
                //if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
                    continue;
            }

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(enchant->SpellID[s]);
            if (!spellInfo)
            {
                TC_LOG_ERROR("entities.player.items", "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
                    GetGUIDLow(), GetName().c_str(), enchant->ID, enchant->SpellID[s]);
                continue;
            }

            if (procSpell && procSpell->Id == spellInfo->Id) // Don't proc from itself.
                continue;

            if (spellInfo->ProcFlags && !(spellInfo->ProcFlags & procAttacker))
                continue;

            float chance = enchant->Amount[s] != 0 ? float(enchant->Amount[s]) : GetWeaponProcChance();

            if (entry)
            {
                if (entry->PPMChance)
                    chance = GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
                else if (entry->customChance)
                    chance = (float)entry->customChance;
            }

            // Apply spell mods
            ApplySpellMod(enchant->SpellID[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);

            // Shiv has 100% chance to apply the poison
            if (FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
                chance = 100.0f;

            if (roll_chance_f(chance))
            {
                if (spellInfo->IsPositive())
                    CastSpell(this, spellInfo, true, item);
                else
                    CastSpell(target, spellInfo, true, item);

                if (uint32 charges = item->GetEnchantmentCharges(EnchantmentSlot(e_slot)))
                {
                    if (charges == 1)
                    {
                        ApplyEnchantment(item, EnchantmentSlot(e_slot), false);
                        item->ClearEnchantment(EnchantmentSlot(e_slot));
                    }
                    else
                        item->SetEnchantmentCharges(EnchantmentSlot(e_slot), charges - 1);
                }
            }
        }
    }
}

struct CastItemUseSpellEventFilter
{
    CastItemUseSpellEventFilter(uint64 itemGuid) : _itemGuid(itemGuid) { }
    uint64 _itemGuid;
    bool operator()(BasicEvent* Event) const
    {
        if (SpellEvent* e = dynamic_cast<SpellEvent*>(Event))
            return e->GetSpell() && e->GetSpell()->m_castItemGUID == _itemGuid && e->GetSpell()->getState() == SPELL_STATE_PREPARING && !e->GetSpell()->m_spellInfo->IsChanneled();
        return false;
    }
};

void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, uint8 cast_count, uint32 glyphIndex)
{
    ItemTemplate const* proto = item->GetTemplate();

    // special learning case
    if (proto->Spells[0].SpellId == 483 || proto->Spells[0].SpellId == 55884)
    {
        uint32 learn_spell_id = proto->Spells[0].SpellId;
        uint32 learning_spell_id = proto->Spells[1].SpellId;

        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(learn_spell_id);
        if (!spellInfo)
        {
            TC_LOG_ERROR("entities.player", "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring ", proto->ItemId, learn_spell_id);
            SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, item, NULL);
            return;
        }

        Spell* spell = new Spell(this, spellInfo, TRIGGERED_NONE);
        spell->m_CastItem = item;
        spell->m_cast_count = cast_count;                   //set count of casts
        spell->SetSpellValue(SPELLVALUE_BASE_POINT0, learning_spell_id);
        spell->prepare(&targets);
        return;
    }

    // use triggered flag only for items with many spell casts and for not first cast
    uint8 count = 0;

    // item spells casted at use
    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = proto->Spells[i];

        // no spell
        if (!spellData.SpellId)
            continue;

        // wrong triggering type
        if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
        if (!spellInfo)
        {
            TC_LOG_ERROR("entities.player", "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring", proto->ItemId, spellData.SpellId);
            continue;
        }

        Spell* spell = new Spell(this, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
        spell->m_CastItem = item;
        spell->m_cast_count = cast_count;                   // set count of casts
        spell->m_glyphIndex = glyphIndex;                   // glyph index
        spell->prepare(&targets);

        ++count;
    }

    // Item enchantments spells casted at use
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        if (e_slot > ENGINEERING_ENCHANTMENT_SLOT && e_slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!pEnchant)
            continue;
        for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            if (pEnchant->Type[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->SpellID[s]);
            if (!spellInfo)
            {
                TC_LOG_ERROR("entities.player", "Player::CastItemUseSpell Enchant %i, cast unknown spell %i", pEnchant->ID, pEnchant->SpellID[s]);
                continue;
            }

            Spell* spell = new Spell(this, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
            spell->m_CastItem = item;
            spell->m_cast_count = cast_count;               // set count of casts
            spell->m_glyphIndex = glyphIndex;               // glyph index
            spell->prepare(&targets);

            ++count;
        }
    }

    // Process all events added by the spell casts above.
    // In other words: cast all delayed item spells right now, instead of waiting until the next update cycle.
    // Because they shouldn't be delayed in the first place.
    m_Events.ProcessCustomEvents(CastItemUseSpellEventFilter{ item->GetGUID() });
}

void Player::_RemoveAllItemMods()
{
    TC_LOG_DEBUG("entities.player.items", "_RemoveAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                RemoveItemsSetItem(this, proto);

            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], false);
            ApplyEnchantment(m_items[i], false);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < MAX_ATTACK)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), false);

            _ApplyItemBonuses(m_items[i], i, false);
        }
    }

    TC_LOG_DEBUG("entities.player.items", "_RemoveAllItemMods complete.");
}

void Player::_ApplyAllItemMods()
{
    TC_LOG_DEBUG("entities.player.items", "_ApplyAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            uint32 attacktype = Player::GetAttackBySlot(i);
            if (attacktype < MAX_ATTACK)
                _ApplyWeaponDependentAuraMods(m_items[i], WeaponAttackType(attacktype), true);

            _ApplyItemBonuses(m_items[i], i, true);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->ItemSet)
                AddItemsSetItem(this, m_items[i]);

            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], true);
            ApplyEnchantment(m_items[i], true);
        }
    }

    TC_LOG_DEBUG("entities.player.items", "_ApplyAllItemMods complete.");

    for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE))
        itr->RecalculateAmount();
}

void Player::_ApplyAllLevelScaleItemMods(bool apply)
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->IsBroken() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            _ApplyItemBonuses(m_items[i], i, apply, true);
        }
    }
}

/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
    Called by remove insignia spell effect    */
void Player::RemovedInsignia(Player* looterPlr)
{
    if (!GetBattlegroundId())
        return;

    // If not released spirit, do it !
    if (m_deathTimer > 0)
    {
        m_deathTimer = 0;
        BuildPlayerRepop();
        RepopAtGraveyard();
    }

    // We have to convert player corpse to bones, not to be able to resurrect there
    // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
    Corpse* bones = sObjectAccessor->ConvertCorpseForPlayer(GetGUID(), true);
    if (!bones)
        return;

    // Now we must make bones lootable, and send player loot
    bones->SetFlag(CORPSE_FIELD_DYNAMIC_FLAGS, CORPSE_DYNFLAG_LOOTABLE);

    // We store the level of our player in the gold field
    // We retrieve this information at Player::SendLoot()
    bones->loot.gold = getLevel();
    bones->lootRecipient = looterPlr;
    looterPlr->SendLoot(bones->GetGUID(), LOOT_INSIGNIA);
}

void Player::SendLootRelease(ObjectGuid guid)
{
    ObjectGuid lootGuid = guid;
    for (auto&& it : m_lootView)
    {
        if (it.second == guid)
        {
            lootGuid = it.first;
            break;
        }
    }

    WorldPacket data(SMSG_LOOT_RELEASE_RESPONSE, 20);
    data.WriteBit(lootGuid[0]);
    data.WriteBit(lootGuid[7]);
    data.WriteBit(lootGuid[5]);
    data.WriteBit(guid[0]);
    data.WriteBit(lootGuid[4]);
    data.WriteBit(lootGuid[6]);
    data.WriteBit(guid[1]);
    data.WriteBit(lootGuid[2]);
    data.WriteBit(guid[5]);
    data.WriteBit(lootGuid[3]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[4]);
    data.WriteBit(lootGuid[1]);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[7]);

    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(lootGuid[1]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(lootGuid[5]);
    data.WriteByteSeq(lootGuid[7]);
    data.WriteByteSeq(lootGuid[3]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(lootGuid[2]);
    data.WriteByteSeq(lootGuid[0]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(lootGuid[6]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(lootGuid[4]);
    data.WriteByteSeq(guid[7]);
    SendDirectMessage(&data);
}

void Player::SendLootReleaseAll()
{
    WorldPacket data{ SMSG_LOOT_RELEASE_ALL };
    SendDirectMessage(&data);
}

void Player::RemoveLootedObject(uint64 guid)
{
    for (auto it = m_lootView.begin(); it != m_lootView.end(); ++it)
    {
        if (it->second == guid)
        {
            m_lootView.erase(it);
            return;
        }
    }
    TC_LOG_ERROR("server", "Player::RemoveLootedObject guid " UI64FMTD " not found in view of player (%u)", guid, GetGUIDLow());
}

static std::map<uint32, uint32> GatheringSkillDetail
{
    { 1731,   1   }, // Copper Vein (prevent log)
    { 1617,   1   }, // Silverleaf (prevent log)
    { 1618,   1   }, // Peacebloom (prevent log)
    { 209311, 500 }, // Ghost Iron Deposit
    { 221538, 500 }, // Ghost Iron Deposit
    { 215413, 500 }, // Ghost Iron Deposit
    { 209328, 550 }, // Rich Ghost Iron Deposit
    { 221539, 550 }, // Rich Ghost Iron Deposit
    { 209312, 550 }, // Kyparite Deposit
    { 209329, 575 }, // Kyparite Deposit
    { 209313, 600 }, // Trillium Vein
    { 221541, 600 }, // Trillium Vein
    { 209330, 600 }, // Rich Trillium Vein 
    { 221540, 600 }, // Rich Trillium Vein 
    { 209355, 600 }, // Fool's Cap
    { 221547, 600 }, // Fool's Cap
    { 209354, 550 }, // Golden Lotus
    { 221545, 550 }, // Golden Lotus
    { 209349, 525 }, // Green Tea Leaf
    { 221542, 525 }, // Green Tea Leaf
    { 215405, 525 }, // Green Tea Leaf
    { 209353, 525 }, // Rain poppy
    { 215408, 525 }, // Rain poppy
    { 221543, 525 }, // Rain poppy
    { 214510, 575 }, // Sha-Touched Herb
    { 215412, 575 }, // Sha-Touched Herb
    { 209350, 545 }, // Silkweed
    { 221544, 545 }, // Silkweed
    { 215406, 545 }, // Silkweed
    { 209351, 575 }, // Snow Lily
    { 215407, 575 }, // Snow Lily
};

void Player::SendLoot(uint64 guid, LootType lootType, bool isAoE)
{
    if (!isAoE)
        if (uint64 lguid = GetLootGUID())
            m_session->DoLootRelease(lguid);

    bool miningOrHerbalism = lootType == LOOT_MINING_OR_HERBALISM;
    if (lootType == LOOT_MINING_OR_HERBALISM)
        lootType = LOOT_SKINNING;

    Loot* loot = 0;
    PermissionTypes permission = ALL_PERMISSION;

    TC_LOG_DEBUG("loot", "Player::SendLoot");
    if (IS_GAMEOBJECT_GUID(guid))
    {
        TC_LOG_DEBUG("loot", "IS_GAMEOBJECT_GUID(guid)");
        GameObject* go = GetMap()->GetGameObject(guid);

        if (!go // Prevent if GO doesn't exist
            || go->HasFlag(GAMEOBJECT_FIELD_FLAGS, GO_FLAG_LOCKED | GO_FLAG_NOT_SELECTABLE) // Prevent if GO is locked or non-interactible
            || (lootType != LOOT_FISHINGHOLE && !go->IsAtInteractDistance(this)) // Prevent if players is outside of interaction range (except for fishing holes which have the standard 5 yards range, but players can't open them manually anyway)
            || (lootType == LOOT_FISHING && go->GetOwnerGUID() != GetGUID()) // Prevent if player doesn't own the fishing bobber
            || (lootType == LOOT_CORPSE && go->GetRespawnTime() && go->isSpawnedByDefault()) // Prevent if chest is despawned
            || (lootType == LOOT_CORPSE && go->GetGoType() == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.groupLootRules && !go->IsLootAllowedFor(this)) // Prevent if player doesn't have permission to loot the chest
            // Maybe check for GO_DYNFLAG_LO_ACTIVATE if GO_FLAG_INTERACT_COND
            )
        {
            SendLootRelease(guid);
            return;
        }

        loot = &go->loot;
        loot->SetGUID(guid);

        if (go->getLootState() == GO_READY)
        {
            uint32 lootid = go->GetGOInfo()->GetLootId();
            if (Battleground* bg = GetBattleground())
                if (!bg->CanActivateGO(go->GetEntry(), GetTeam()))
                {
                    SendLootRelease(guid);
                    return;
                }

            if (lootid)
            {
                loot->clear();

                if (miningOrHerbalism && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
                {
                    if (auto lockEntry = sLockStore.LookupEntry(go->GetGOInfo()->GetLockId()))
                    {
                        uint32 i = 0;
                        for (; i < MAX_LOCK_CASE; ++i)
                            if (lockEntry->Type[i] == LOCK_KEY_SKILL)
                                break;
                        if (i < MAX_LOCK_CASE && !lockEntry->Skill[i])
                        {
                            auto skillValue = GetSkillValue(SkillByLockType(LockType(lockEntry->Index[i])));
                            auto it = GatheringSkillDetail.find(go->GetEntry());
                            if (it == GatheringSkillDetail.end())
                                TC_LOG_ERROR("server", "Player::SendLoot %u not found", go->GetEntry());
                            else
                            {
                                if (it->second > skillValue)
                                    loot->gatheringCoefficient = float(skillValue) / float(it->second);
                            }
                        }
                    }
                }

                Group* group = GetGroup();
                bool groupRules = (group && go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.groupLootRules);

                // check current RR player and get next if necessary
                if (groupRules)
                    group->UpdateLooterGuid(go, true);

                if (miningOrHerbalism)
                    loot->guildPerkChance = GetTotalAuraModifier(SPELL_AURA_MOD_GATHERING_ITEMS_GAINED_PERCENT);
                loot->FillLoot(go, lootid, LootTemplates_Gameobject, this, !groupRules, false, go->GetMap()->GetDifficulty());

                // get next RR player (for next loot)
                if (groupRules)
                    group->UpdateLooterGuid(go);
            }
 
            if (GameObjectTemplateAddon const* addon = go->GetTemplateAddon())
                loot->generateMoneyLoot(addon->mingold, addon->maxgold);

            if (lootType == LOOT_FISHING)
                go->getFishLoot(loot, this);

            if (go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.groupLootRules)
            {
                if (Group* group = GetGroup())
                {
                    switch (group->GetLootMethod())
                    {
                        case GROUP_LOOT:
                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                            group->GroupLoot(loot, go);
                            break;
                        case NEED_BEFORE_GREED:
                            group->NeedBeforeGreed(loot, go);
                            break;
                        case MASTER_LOOT:
                            group->MasterLoot(loot, go);
                            break;
                        default:
                            break;
                    }
                }
            }

            go->SetLootState(GO_ACTIVATED, this);
        }

        if (go->getLootState() == GO_ACTIVATED)
        {
            if (Group* group = GetGroup())
            {
                switch (group->GetLootMethod())
                {
                    case MASTER_LOOT:
                        permission = MASTER_PERMISSION;
                        break;
                    case FREE_FOR_ALL:
                        permission = ALL_PERMISSION;
                        break;
                    case ROUND_ROBIN:
                        permission = ROUND_ROBIN_PERMISSION;
                        break;
                    default:
                        permission = GROUP_PERMISSION;
                        break;
                }
            }
            else
                permission = ALL_PERMISSION;
        }
    }
    else if (IS_ITEM_GUID(guid))
    {
        Item* item = GetItemByGuid(guid);

        if (!item)
        {
            SendLootRelease(guid);
            return;
        }

        permission = OWNER_PERMISSION;

        loot = &item->loot;
        loot->SetGUID(guid);

        bool checkDB = true;
        switch (lootType)
        {
            case LOOT_DISENCHANTING:
            case LOOT_PROSPECTING:
            case LOOT_MILLING:
                checkDB = false;
                break;
            default:
                break;
        }

        // If item doesn't already have loot, attempt to load it. If that
        //  fails then this is first time opening, generate loot
        if (!item->m_lootGenerated && (!checkDB || !item->ItemContainerLoadLootFromDB()))
        {
            item->m_lootGenerated = true;
            loot->clear();
            loot->containerItemTemplate = item->GetTemplate();
            loot->loot_type = lootType;

            switch (lootType)
            {
                case LOOT_DISENCHANTING:
                    loot->guildPerkChance = GetTotalAuraModifier(SPELL_AURA_MOD_GATHERING_ITEMS_GAINED_PERCENT);
                    loot->FillLoot(item, item->GetTemplate()->DisenchantID, LootTemplates_Disenchant, this, true);
                    break;
                case LOOT_PROSPECTING:
                    loot->FillLoot(item, item->GetEntry(), LootTemplates_Prospecting, this, true);
                    break;
                case LOOT_MILLING:
                    loot->FillLoot(item, item->GetEntry(), LootTemplates_Milling, this, true);
                    break;
                default:
                    loot->generateMoneyLoot(item->GetTemplate()->MinMoneyLoot, item->GetTemplate()->MaxMoneyLoot);
                    loot->FillLoot(item, item->GetEntry(), LootTemplates_Item, this, true, loot->gold != 0);

                    // Force save the loot and money items that were just rolled
                    //  Also saves the container item ID in Loot struct (not to DB)
                    if (loot->gold > 0 || loot->unlootedCount > 0)
                        item->ItemContainerSaveLootToDB();

                    break;
            }
        }
    }
    else if (IS_CORPSE_GUID(guid))                          // remove insignia
    {
        Corpse* bones = ObjectAccessor::GetCorpse(*this, guid);

        if (!bones || !(lootType == LOOT_CORPSE || lootType == LOOT_INSIGNIA) || bones->GetType() != CORPSE_BONES)
        {
            SendLootRelease(guid);
            return;
        }

        loot = &bones->loot;
        loot->SetGUID(guid);

        if (!bones->lootForBody)
        {
            bones->lootForBody = true;
            uint32 pLevel = bones->loot.gold;
            bones->loot.clear();
            if (Battleground* bg = GetBattleground())
                if (bg->GetTypeID(true) == BATTLEGROUND_AV)
                    loot->FillLoot(NULL, 1, LootTemplates_Creature, this, true);
            // It may need a better formula
            // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
            bones->loot.gold = uint32(urand(50, 150) * 0.016f * pow(float(pLevel)/5.76f, 2.5f) * sWorld->getRate(RATE_DROP_MONEY));
        }

        if (bones->lootRecipient != this)
            permission = NONE_PERMISSION;
        else
            permission = OWNER_PERMISSION;
    }
    else
    {
        Creature* creature = GetMap()->GetCreature(guid);

        // must be in range and creature must be alive for pickpocket and must be dead for another loot
        bool isInDistance = creature && creature->IsWithinDistInMap(this, INTERACTION_DISTANCE) || isAoE || HasAura(126746); // Glyph of Fetch
        if (!creature || creature->IsAlive() != (lootType == LOOT_PICKPOCKETING) || !isInDistance)
        {
            SendLootRelease(guid);
            return;
        }

        if (lootType == LOOT_PICKPOCKETING && (creature->GetEntry() != 56233 && IsFriendlyTo(creature))) // hack, but I dont know how it must work (failure on IsFriendlyTo for npc 56233 and faction 2393)
        {
            SendLootRelease(guid);
            return;
        }

        loot = &creature->loot;
        loot->SetGUID(guid);

        if (lootType == LOOT_PICKPOCKETING)
        {
            if (!creature->lootForPickPocketed)
            {
                creature->lootForPickPocketed = true;
                creature->StartPickPocketRefillTimer();
                loot->clear();

                if (uint32 lootid = creature->GetCreatureTemplate()->pickpocketLootId)
                    loot->FillLoot(creature, lootid, LootTemplates_Pickpocketing, this, true);

                // Generate extra money for pick pocket loot
                const uint32 a = urand(0, creature->getLevel()/2);
                const uint32 b = urand(0, getLevel()/2);
                loot->gold = creature->GetEntry() == 56233 ? 0 : uint32(10 * (a + b) * sWorld->getRate(RATE_DROP_MONEY));  // hack, but I dont know how it must work (money should not drop for pockpocketing from spell?)
                permission = OWNER_PERMISSION;
            }
        }
        else
        {
            // the player whose group may loot the corpse
            Player* recipient = creature->GetLootRecipient();
            if (!recipient)
                return;

            if (!creature->lootForBody)
            {
                creature->lootForBody = true;

                Group* group = recipient->GetGroup();
                // for creature, loot is filled when creature is killed.
                if (creature->HasNormalLootMode() && group)
                {
                    switch (group->GetLootMethod())
                    {
                        case GROUP_LOOT:
                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                            group->GroupLoot(loot, creature);
                            break;
                        case NEED_BEFORE_GREED:
                            group->NeedBeforeGreed(loot, creature);
                            break;
                        case MASTER_LOOT:
                            group->MasterLoot(loot, creature);
                            break;
                        default:
                            break;
                    }
                }
            }

            // possible only if creature->lootForBody && loot->empty() at spell cast check
            if (lootType == LOOT_SKINNING)
            {
                loot->clear();
                loot->guildPerkChance = GetTotalAuraModifier(SPELL_AURA_MOD_GATHERING_ITEMS_GAINED_PERCENT);
                loot->FillLoot(creature, creature->GetCreatureTemplate()->SkinLootId, LootTemplates_Skinning, this, true);
                permission = OWNER_PERMISSION;
            }
            else if (!creature->HasNormalLootMode())
            {
                // Special rules
                permission = OWNER_PERMISSION;
            }
            // set group rights only for loot_type != LOOT_SKINNING
            else
            {
                if (Group* group = GetGroup())
                {
                    if (group == recipient->GetGroup())
                    {
                        switch (group->GetLootMethod())
                        {
                            case MASTER_LOOT:
                                permission = MASTER_PERMISSION;
                                break;
                            case FREE_FOR_ALL:
                                permission = ALL_PERMISSION;
                                break;
                            case ROUND_ROBIN:
                                permission = ROUND_ROBIN_PERMISSION;
                                break;
                            default:
                                permission = GROUP_PERMISSION;
                                break;
                        }
                    }
                    else
                        permission = NONE_PERMISSION;
                }
                else if (recipient == this)
                    permission = OWNER_PERMISSION;
                else
                    permission = NONE_PERMISSION;
            }
        }
    }

    if (!isAoE)
        SetLootGUID(guid);

    // LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
    switch (lootType)
    {
        case LOOT_INSIGNIA:    lootType = LOOT_SKINNING; break;
        case LOOT_FISHINGHOLE: lootType = LOOT_FISHING; break;
        default: break;
    }

    // need know merged fishing/corpse loot type for achievements
    loot->loot_type = lootType;

    WorldPacket data(SMSG_LOOT_RESPONSE, 8 + 1 + 50 + 1 + 1);           // we guess size
    LootView(*loot, this, permission).WriteData(guid, lootType, &data, isAoE);
    SendDirectMessage(&data);

    // add 'this' player as one of the players that are looting 'loot'
    if (permission != NONE_PERMISSION)
    {
        loot->AddLooter(GetGUID());
        m_lootView.emplace(loot->GetGUID(), guid);
    }

    if (lootType == LOOT_CORPSE && !IS_ITEM_GUID(guid))
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
}

void Player::SendNotifyLootMoneyRemoved(ObjectGuid guid)
{
    WorldPacket data(SMSG_LOOT_CLEAR_MONEY, 9);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[4]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[7]);

    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[6]);

    GetSession()->SendPacket(&data);
}

void Player::SendNotifyLootItemRemoved(uint8 lootSlot, ObjectGuid lootGuid)
{
    auto it = m_lootView.find(lootGuid);
    if (it == m_lootView.end())
        return;

    ObjectGuid guid = it->second;

    // Guid could also be itemID

    WorldPacket data(SMSG_LOOT_REMOVED, 19);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[2]);
    data.WriteBit(lootGuid[0]);
    data.WriteBit(lootGuid[1]);
    data.WriteBit(lootGuid[2]);
    data.WriteBit(lootGuid[7]);
    data.WriteBit(lootGuid[6]);
    data.WriteBit(lootGuid[5]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[6]);
    data.WriteBit(lootGuid[3]);
    data.WriteBit(lootGuid[4]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[4]);

    data.WriteByteSeq(lootGuid[1]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(lootGuid[7]);
    data.WriteByteSeq(lootGuid[0]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(lootGuid[5]);
    data.WriteByteSeq(lootGuid[3]);
    data.WriteByteSeq(lootGuid[2]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[1]);
    data << uint8(lootSlot);
    data.WriteByteSeq(lootGuid[6]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(lootGuid[4]);

    GetSession()->SendPacket(&data);
}

void Player::SendDisplayToast(Item* item, uint32 entry, uint32 count, ToastTypes type, ToastDispalyTypes displayType, bool bonusRoll)
{
    if (type == TOAST_TYPE_ITEM && !item)
        return;

    WorldPacket data(SMSG_DISPLAY_TOAST);
    data.WriteBit(bonusRoll); // after using currency like 776
    data.WriteBits(type, 2);
    data.WriteBit(displayType == 0);

    if (type == TOAST_TYPE_ITEM)
    {
        data.WriteBit(type != TOAST_TYPE_ITEM); // reverse bit, always false when type TOAST_TYPE_ITEM
        data.FlushBits();

        data << uint32(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_UPGRADE));
        data << uint32(item->GetItemSuffixFactor());
        data << int32(item->GetItemRandomPropertyId());
        data << uint32(item->GetTemplate()->DisplayInfoID);
        data << uint32(item->GetEntry());
        data << uint32(GetLootSpecialization());
    }
    else
        data.FlushBits();

    data << uint32(count);
    if (displayType)
        data << uint8(displayType);
    if (type == TOAST_TYPE_CURRENCY)
        data << uint32(entry);

    GetSession()->SendPacket(&data);
}

void Player::SendUpdateWorldState(uint32 Field, uint32 Value)
{
    WorldPacket data(SMSG_UPDATE_WORLD_STATE, 4 + 4 + 1);
    data.WriteBit(0);
    data << uint32(Value);
    data << uint32(Field);
    GetSession()->SendPacket(&data);
}

void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
{
    // data depends on zoneid/mapid...
    Battleground* bg = GetBattleground();
    uint32 mapid = GetMapId();
    OutdoorPvP* pvp = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(zoneid);
    InstanceScript* instance = GetInstanceScript();
    Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(zoneid);

    TC_LOG_DEBUG("network", "Sending SMSG_INIT_WORLD_STATES to Map: %u, Zone: %u", mapid, zoneid);

    WorldStateBuilder builder(mapid, areaid, zoneid);

    builder.AppendState(0x8d8, 0x0);                   // 1
    builder.AppendState(0x8d7, 0x0);                   // 2
    builder.AppendState(0x8d6, 0x0);                   // 3
    builder.AppendState(0x8d5, 0x0);                   // 4
    builder.AppendState(0x8d4, 0x0);                   // 5
    builder.AppendState(0x8d3, 0x0);                   // 6

    sGameEventMgr->FillWorldStates(this, builder);

                                                            // 7 1 - Arena season in progress, 0 - end of season
    //builder.AppendState(0xC77, sWorld->getBoolConfig(CONFIG_ARENA_SEASON_IN_PROGRESS));
                                                            // 8 Arena season id
    //builder.AppendState(0xF3D, sWorld->getIntConfig(CONFIG_ARENA_SEASON_ID));

    if (mapid == 530)                                       // Outland
    {
        builder.AppendState(0x9bf, 0x0);               // 7
        builder.AppendState(0x9bd, 0xF);               // 8
        builder.AppendState(0x9bb, 0xF);               // 9
    }

    // Isle of Thunder
    uint32 stage = sWorld->getIntConfig(CONFIG_ISLE_OF_THUNDER_STAGE);
    builder.AppendState(7617, stage ? stage - 1 : 0); // stage horde (+1)
    builder.AppendState(7618, stage ? stage - 1 : 0); // stage alliance (+1)
    builder.AppendState(7796, sWorld->getIntConfig(CONFIG_ISLE_OF_THUNDER_PROGRESSION_HORDE));    // progression percents alliance
    builder.AppendState(7797, sWorld->getIntConfig(CONFIG_ISLE_OF_THUNDER_PROGRESSION_ALLIANCE)); // progression percents horde

    // insert <field> <value>
    switch (zoneid)
    {
        case 1:                                             // Dun Morogh
        case 11:                                            // Wetlands
        case 12:                                            // Elwynn Forest
        case 38:                                            // Loch Modan
        case 40:                                            // Westfall
        case 51:                                            // Searing Gorge
        case 1519:                                          // Stormwind City
        case 1537:                                          // Ironforge
        case 2257:                                          // Deeprun Tram
        case 3703:                                          // Shattrath City
            break;
        case 1377:                                          // Silithus
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_SI)
                pvp->FillInitialWorldStates(builder);
            else
            {
                // states are always shown
                builder.AppendState(2313, 0x0); // 7 ally silityst gathered
                builder.AppendState(2314, 0x0); // 8 horde silityst gathered
                builder.AppendState(2317, 0x0); // 9 max silithyst
            }
            // dunno about these... aq opening event maybe?
            builder.AppendState(2322, 0x0); // 10 sandworm N
            builder.AppendState(2323, 0x0); // 11 sandworm S
            builder.AppendState(2324, 0x0); // 12 sandworm SW
            builder.AppendState(2325, 0x0); // 13 sandworm E
            break;
        case 2597:                                          // Alterac Valley
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AV)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x7ae, 0x1);           // 7 snowfall n
                builder.AppendState(0x532, 0x1);           // 8 frostwolfhut hc
                builder.AppendState(0x531, 0x0);           // 9 frostwolfhut ac
                builder.AppendState(0x52e, 0x0);           // 10 stormpike firstaid a_a
                builder.AppendState(0x571, 0x0);           // 11 east frostwolf tower horde assaulted -unused
                builder.AppendState(0x570, 0x0);           // 12 west frostwolf tower horde assaulted - unused
                builder.AppendState(0x567, 0x1);           // 13 frostwolfe c
                builder.AppendState(0x566, 0x1);           // 14 frostwolfw c
                builder.AppendState(0x550, 0x1);           // 15 irondeep (N) ally
                builder.AppendState(0x544, 0x0);           // 16 ice grave a_a
                builder.AppendState(0x536, 0x0);           // 17 stormpike grave h_c
                builder.AppendState(0x535, 0x1);           // 18 stormpike grave a_c
                builder.AppendState(0x518, 0x0);           // 19 stoneheart grave a_a
                builder.AppendState(0x517, 0x0);           // 20 stoneheart grave h_a
                builder.AppendState(0x574, 0x0);           // 21 1396 unk
                builder.AppendState(0x573, 0x0);           // 22 iceblood tower horde assaulted -unused
                builder.AppendState(0x572, 0x0);           // 23 towerpoint horde assaulted - unused
                builder.AppendState(0x56f, 0x0);           // 24 1391 unk
                builder.AppendState(0x56e, 0x0);           // 25 iceblood a
                builder.AppendState(0x56d, 0x0);           // 26 towerp a
                builder.AppendState(0x56c, 0x0);           // 27 frostwolfe a
                builder.AppendState(0x56b, 0x0);           // 28 froswolfw a
                builder.AppendState(0x56a, 0x1);           // 29 1386 unk
                builder.AppendState(0x569, 0x1);           // 30 iceblood c
                builder.AppendState(0x568, 0x1);           // 31 towerp c
                builder.AppendState(0x565, 0x0);           // 32 stoneh tower a
                builder.AppendState(0x564, 0x0);           // 33 icewing tower a
                builder.AppendState(0x563, 0x0);           // 34 dunn a
                builder.AppendState(0x562, 0x0);           // 35 duns a
                builder.AppendState(0x561, 0x0);           // 36 stoneheart bunker alliance assaulted - unused
                builder.AppendState(0x560, 0x0);           // 37 icewing bunker alliance assaulted - unused
                builder.AppendState(0x55f, 0x0);           // 38 dunbaldar south alliance assaulted - unused
                builder.AppendState(0x55e, 0x0);           // 39 dunbaldar north alliance assaulted - unused
                builder.AppendState(0x55d, 0x0);           // 40 stone tower d
                builder.AppendState(0x3c6, 0x0);           // 41 966 unk
                builder.AppendState(0x3c4, 0x0);           // 42 964 unk
                builder.AppendState(0x3c2, 0x0);           // 43 962 unk
                builder.AppendState(0x516, 0x1);           // 44 stoneheart grave a_c
                builder.AppendState(0x515, 0x0);           // 45 stonheart grave h_c
                builder.AppendState(0x3b6, 0x0);           // 46 950 unk
                builder.AppendState(0x55c, 0x0);           // 47 icewing tower d
                builder.AppendState(0x55b, 0x0);           // 48 dunn d
                builder.AppendState(0x55a, 0x0);           // 49 duns d
                builder.AppendState(0x559, 0x0);           // 50 1369 unk
                builder.AppendState(0x558, 0x0);           // 51 iceblood d
                builder.AppendState(0x557, 0x0);           // 52 towerp d
                builder.AppendState(0x556, 0x0);           // 53 frostwolfe d
                builder.AppendState(0x555, 0x0);           // 54 frostwolfw d
                builder.AppendState(0x554, 0x1);           // 55 stoneh tower c
                builder.AppendState(0x553, 0x1);           // 56 icewing tower c
                builder.AppendState(0x552, 0x1);           // 57 dunn c
                builder.AppendState(0x551, 0x1);           // 58 duns c
                builder.AppendState(0x54f, 0x0);           // 59 irondeep (N) horde
                builder.AppendState(0x54e, 0x0);           // 60 irondeep (N) ally
                builder.AppendState(0x54d, 0x1);           // 61 mine (S) neutral
                builder.AppendState(0x54c, 0x0);           // 62 mine (S) horde
                builder.AppendState(0x54b, 0x0);           // 63 mine (S) ally
                builder.AppendState(0x545, 0x0);           // 64 iceblood h_a
                builder.AppendState(0x543, 0x1);           // 65 iceblod h_c
                builder.AppendState(0x542, 0x0);           // 66 iceblood a_c
                builder.AppendState(0x540, 0x0);           // 67 snowfall h_a
                builder.AppendState(0x53f, 0x0);           // 68 snowfall a_a
                builder.AppendState(0x53e, 0x0);           // 69 snowfall h_c
                builder.AppendState(0x53d, 0x0);           // 70 snowfall a_c
                builder.AppendState(0x53c, 0x0);           // 71 frostwolf g h_a
                builder.AppendState(0x53b, 0x0);           // 72 frostwolf g a_a
                builder.AppendState(0x53a, 0x1);           // 73 frostwolf g h_c
                builder.AppendState(0x539, 0x0);           // 74 frostwolf g a_c
                builder.AppendState(0x538, 0x0);           // 75 stormpike grave h_a
                builder.AppendState(0x537, 0x0);           // 76 stormpike grave a_a
                builder.AppendState(0x534, 0x0);           // 77 frostwolf hut h_a
                builder.AppendState(0x533, 0x0);           // 78 frostwolf hut a_a
                builder.AppendState(0x530, 0x0);           // 79 stormpike first aid h_a
                builder.AppendState(0x52f, 0x0);           // 80 stormpike first aid h_c
                builder.AppendState(0x52d, 0x1);           // 81 stormpike first aid a_c
            }
            break;
        case 3277:                                          // Warsong Gulch
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_WS)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x62d, 0x0);       // 7 1581 alliance flag captures
                builder.AppendState(0x62e, 0x0);       // 8 1582 horde flag captures
                builder.AppendState(0x609, 0x0);       // 9 1545 unk, set to 1 on alliance flag pickup...
                builder.AppendState(0x60a, 0x0);       // 10 1546 unk, set to 1 on horde flag pickup, after drop it's -1
                builder.AppendState(0x60b, 0x2);       // 11 1547 unk
                builder.AppendState(0x641, 0x3);       // 12 1601 unk (max flag captures?)
                builder.AppendState(0x922, 0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                builder.AppendState(0x923, 0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        case 3358:                                          // Arathi Basin
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_AB)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x6e7, 0x0);       // 7 1767 stables alliance
                builder.AppendState(0x6e8, 0x0);       // 8 1768 stables horde
                builder.AppendState(0x6e9, 0x0);       // 9 1769 unk, ST?
                builder.AppendState(0x6ea, 0x0);       // 10 1770 stables (show/hide)
                builder.AppendState(0x6ec, 0x0);       // 11 1772 farm (0 - horde controlled, 1 - alliance controlled)
                builder.AppendState(0x6ed, 0x0);       // 12 1773 farm (show/hide)
                builder.AppendState(0x6ee, 0x0);       // 13 1774 farm color
                builder.AppendState(0x6ef, 0x0);       // 14 1775 gold mine color, may be FM?
                builder.AppendState(0x6f0, 0x0);       // 15 1776 alliance resources
                builder.AppendState(0x6f1, 0x0);       // 16 1777 horde resources
                builder.AppendState(0x6f2, 0x0);       // 17 1778 horde bases
                builder.AppendState(0x6f3, 0x0);       // 18 1779 alliance bases
                builder.AppendState(0x6f4, 0x7d0);     // 19 1780 max resources (2000)
                builder.AppendState(0x6f6, 0x0);       // 20 1782 blacksmith color
                builder.AppendState(0x6f7, 0x0);       // 21 1783 blacksmith (show/hide)
                builder.AppendState(0x6f8, 0x0);       // 22 1784 unk, bs?
                builder.AppendState(0x6f9, 0x0);       // 23 1785 unk, bs?
                builder.AppendState(0x6fb, 0x0);       // 24 1787 gold mine (0 - horde contr, 1 - alliance contr)
                builder.AppendState(0x6fc, 0x0);       // 25 1788 gold mine (0 - conflict, 1 - horde)
                builder.AppendState(0x6fd, 0x0);       // 26 1789 gold mine (1 - show/0 - hide)
                builder.AppendState(0x6fe, 0x0);       // 27 1790 gold mine color
                builder.AppendState(0x700, 0x0);       // 28 1792 gold mine color, wtf?, may be LM?
                builder.AppendState(0x701, 0x0);       // 29 1793 lumber mill color (0 - conflict, 1 - horde contr)
                builder.AppendState(0x702, 0x0);       // 30 1794 lumber mill (show/hide)
                builder.AppendState(0x703, 0x0);       // 31 1795 lumber mill color color
                builder.AppendState(0x732, 0x1);       // 32 1842 stables (1 - uncontrolled)
                builder.AppendState(0x733, 0x1);       // 33 1843 gold mine (1 - uncontrolled)
                builder.AppendState(0x734, 0x1);       // 34 1844 lumber mill (1 - uncontrolled)
                builder.AppendState(0x735, 0x1);       // 35 1845 farm (1 - uncontrolled)
                builder.AppendState(0x736, 0x1);       // 36 1846 blacksmith (1 - uncontrolled)
                builder.AppendState(0x745, 0x2);       // 37 1861 unk
                builder.AppendState(0x7a3, 0x708);     // 38 1955 warning limit (1800)
            }
            break;
        case 3820:                                          // Eye of the Storm
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_EY)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0xac1, 0x0);       // 7  2753 Horde Bases
                builder.AppendState(0xac0, 0x0);       // 8  2752 Alliance Bases
                builder.AppendState(0xab6, 0x0);       // 9  2742 Mage Tower - Horde conflict
                builder.AppendState(0xab5, 0x0);       // 10 2741 Mage Tower - Alliance conflict
                builder.AppendState(0xab4, 0x0);       // 11 2740 Fel Reaver - Horde conflict
                builder.AppendState(0xab3, 0x0);       // 12 2739 Fel Reaver - Alliance conflict
                builder.AppendState(0xab2, 0x0);       // 13 2738 Draenei - Alliance conflict
                builder.AppendState(0xab1, 0x0);       // 14 2737 Draenei - Horde conflict
                builder.AppendState(0xab0, 0x0);       // 15 2736 unk // 0 at start
                builder.AppendState(0xaaf, 0x0);       // 16 2735 unk // 0 at start
                builder.AppendState(0xaad, 0x0);       // 17 2733 Draenei - Horde control
                builder.AppendState(0xaac, 0x0);       // 18 2732 Draenei - Alliance control
                builder.AppendState(0xaab, 0x1);       // 19 2731 Draenei uncontrolled (1 - yes, 0 - no)
                builder.AppendState(0xaaa, 0x0);       // 20 2730 Mage Tower - Alliance control
                builder.AppendState(0xaa9, 0x0);       // 21 2729 Mage Tower - Horde control
                builder.AppendState(0xaa8, 0x1);       // 22 2728 Mage Tower uncontrolled (1 - yes, 0 - no)
                builder.AppendState(0xaa7, 0x0);       // 23 2727 Fel Reaver - Horde control
                builder.AppendState(0xaa6, 0x0);       // 24 2726 Fel Reaver - Alliance control
                builder.AppendState(0xaa5, 0x1);       // 25 2725 Fel Reaver uncontrolled (1 - yes, 0 - no)
                builder.AppendState(0xaa4, 0x0);       // 26 2724 Boold Elf - Horde control
                builder.AppendState(0xaa3, 0x0);       // 27 2723 Boold Elf - Alliance control
                builder.AppendState(0xaa2, 0x1);       // 28 2722 Boold Elf uncontrolled (1 - yes, 0 - no)
                builder.AppendState(0xac5, 0x1);       // 29 2757 Flag (1 - show, 0 - hide) - doesn't work exactly this way!
                builder.AppendState(0xad2, 0x1);       // 30 2770 Horde top-stats (1 - show, 0 - hide) // 02 -> horde picked up the flag
                builder.AppendState(0xad1, 0x1);       // 31 2769 Alliance top-stats (1 - show, 0 - hide) // 02 -> alliance picked up the flag
                builder.AppendState(0xabe, 0x0);       // 32 2750 Horde resources
                builder.AppendState(0xabd, 0x0);       // 33 2749 Alliance resources
                builder.AppendState(0xa05, 0x8e);      // 34 2565 unk, constant?
                builder.AppendState(0xaa0, 0x0);       // 35 2720 Capturing progress-bar (100 -> empty (only grey), 0 -> blue|red (no grey), default 0)
                builder.AppendState(0xa9f, 0x0);       // 36 2719 Capturing progress-bar (0 - left, 100 - right)
                builder.AppendState(0xa9e, 0x0);       // 37 2718 Capturing progress-bar (1 - show, 0 - hide)
                builder.AppendState(0xc0d, 0x17b);     // 38 3085 unk
                // and some more ... unknown
            }
            break;
        // any of these needs change! the client remembers the prev setting!
        // ON EVERY ZONE LEAVE, RESET THE OLD ZONE'S WORLD STATE, BUT AT LEAST THE UI STUFF!
        case 3483:                                          // Hellfire Peninsula
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_HP)
                pvp->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x9ba, 0x1);           // 10 // add ally tower main gui icon       // maybe should be sent only on login?
                builder.AppendState(0x9b9, 0x1);           // 11 // add horde tower main gui icon      // maybe should be sent only on login?
                builder.AppendState(0x9b5, 0x0);           // 12 // show neutral broken hill icon      // 2485
                builder.AppendState(0x9b4, 0x1);           // 13 // show icon above broken hill        // 2484
                builder.AppendState(0x9b3, 0x0);           // 14 // show ally broken hill icon         // 2483
                builder.AppendState(0x9b2, 0x0);           // 15 // show neutral overlook icon         // 2482
                builder.AppendState(0x9b1, 0x1);           // 16 // show the overlook arrow            // 2481
                builder.AppendState(0x9b0, 0x0);           // 17 // show ally overlook icon            // 2480
                builder.AppendState(0x9ae, 0x0);           // 18 // horde pvp objectives captured      // 2478
                builder.AppendState(0x9ac, 0x0);           // 19 // ally pvp objectives captured       // 2476
                builder.AppendState(2475,  100);           //: ally / horde slider grey area                              // show only in direct vicinity!
                builder.AppendState(2474,  50);            //: ally / horde slider percentage, 100 for ally, 0 for horde  // show only in direct vicinity!
                builder.AppendState(2473,  0);             //: ally / horde slider display                                // show only in direct vicinity!
                builder.AppendState(0x9a8, 0x0);           // 20 // show the neutral stadium icon      // 2472
                builder.AppendState(0x9a7, 0x0);           // 21 // show the ally stadium icon         // 2471
                builder.AppendState(0x9a6, 0x1);           // 22 // show the horde stadium icon        // 2470
            }
            break;
        case 3518:                                          // Nagrand
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_NA)
                pvp->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(2503, 0x0);    // 10
                builder.AppendState(2502, 0x0);    // 11
                builder.AppendState(2493, 0x0);    // 12
                builder.AppendState(2491, 0x0);    // 13

                builder.AppendState(2495, 0x0);    // 14
                builder.AppendState(2494, 0x0);    // 15
                builder.AppendState(2497, 0x0);    // 16

                builder.AppendState(2762, 0x0);    // 17
                builder.AppendState(2662, 0x0);    // 18
                builder.AppendState(2663, 0x0);    // 19
                builder.AppendState(2664, 0x0);    // 20

                builder.AppendState(2760, 0x0);    // 21
                builder.AppendState(2670, 0x0);    // 22
                builder.AppendState(2668, 0x0);    // 23
                builder.AppendState(2669, 0x0);    // 24

                builder.AppendState(2761, 0x0);    // 25
                builder.AppendState(2667, 0x0);    // 26
                builder.AppendState(2665, 0x0);    // 27
                builder.AppendState(2666, 0x0);    // 28

                builder.AppendState(2763, 0x0);    // 29
                builder.AppendState(2659, 0x0);    // 30
                builder.AppendState(2660, 0x0);    // 31
                builder.AppendState(2661, 0x0);    // 32

                builder.AppendState(2671, 0x0);    // 33
                builder.AppendState(2676, 0x0);    // 34
                builder.AppendState(2677, 0x0);    // 35
                builder.AppendState(2672, 0x0);    // 36
                builder.AppendState(2673, 0x0);    // 37
            }
            break;
        case 3519:                                          // Terokkar Forest
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_TF)
                pvp->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0xa41, 0x0);           // 10 // 2625 capture bar pos
                builder.AppendState(0xa40, 0x14);          // 11 // 2624 capture bar neutral
                builder.AppendState(0xa3f, 0x0);           // 12 // 2623 show capture bar
                builder.AppendState(0xa3e, 0x0);           // 13 // 2622 horde towers controlled
                builder.AppendState(0xa3d, 0x5);           // 14 // 2621 ally towers controlled
                builder.AppendState(0xa3c, 0x0);           // 15 // 2620 show towers controlled
                builder.AppendState(0xa88, 0x0);           // 16 // 2696 SE Neu
                builder.AppendState(0xa87, 0x0);           // 17 // SE Horde
                builder.AppendState(0xa86, 0x0);           // 18 // SE Ally
                builder.AppendState(0xa85, 0x0);           // 19 //S Neu
                builder.AppendState(0xa84, 0x0);           // 20 S Horde
                builder.AppendState(0xa83, 0x0);           // 21 S Ally
                builder.AppendState(0xa82, 0x0);           // 22 NE Neu
                builder.AppendState(0xa81, 0x0);           // 23 NE Horde
                builder.AppendState(0xa80, 0x0);           // 24 NE Ally
                builder.AppendState(0xa7e, 0x0);           // 25 // 2686 N Neu
                builder.AppendState(0xa7d, 0x0);           // 26 N Horde
                builder.AppendState(0xa7c, 0x0);           // 27 N Ally
                builder.AppendState(0xa7b, 0x0);           // 28 NW Ally
                builder.AppendState(0xa7a, 0x0);           // 29 NW Horde
                builder.AppendState(0xa79, 0x0);           // 30 NW Neutral
                builder.AppendState(0x9d0, 0x5);           // 31 // 2512 locked time remaining seconds first digit
                builder.AppendState(0x9ce, 0x0);           // 32 // 2510 locked time remaining seconds second digit
                builder.AppendState(0x9cd, 0x0);           // 33 // 2509 locked time remaining minutes
                builder.AppendState(0x9cc, 0x0);           // 34 // 2508 neutral locked time show
                builder.AppendState(0xad0, 0x0);           // 35 // 2768 horde locked time show
                builder.AppendState(0xacf, 0x1);           // 36 // 2767 ally locked time show
            }
            break;
        case 3521:                                          // Zangarmarsh
            if (pvp && pvp->GetTypeId() == OUTDOOR_PVP_ZM)
                pvp->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x9e1, 0x0);           // 10 //2529
                builder.AppendState(0x9e0, 0x0);           // 11
                builder.AppendState(0x9df, 0x0);           // 12
                builder.AppendState(0xa5d, 0x1);           // 13 //2653
                builder.AppendState(0xa5c, 0x0);           // 14 //2652 east beacon neutral
                builder.AppendState(0xa5b, 0x1);           // 15 horde
                builder.AppendState(0xa5a, 0x0);           // 16 ally
                builder.AppendState(0xa59, 0x1);           // 17 // 2649 Twin spire graveyard horde  12???
                builder.AppendState(0xa58, 0x0);           // 18 ally     14 ???
                builder.AppendState(0xa57, 0x0);           // 19 neutral  7???
                builder.AppendState(0xa56, 0x0);           // 20 // 2646 west beacon neutral
                builder.AppendState(0xa55, 0x1);           // 21 horde
                builder.AppendState(0xa54, 0x0);           // 22 ally
                builder.AppendState(0x9e7, 0x0);           // 23 // 2535
                builder.AppendState(0x9e6, 0x0);           // 24
                builder.AppendState(0x9e5, 0x0);           // 25
                builder.AppendState(0xa00, 0x0);           // 26 // 2560
                builder.AppendState(0x9ff, 0x1);           // 27
                builder.AppendState(0x9fe, 0x0);           // 28
                builder.AppendState(0x9fd, 0x0);           // 29
                builder.AppendState(0x9fc, 0x1);           // 30
                builder.AppendState(0x9fb, 0x0);           // 31
                builder.AppendState(0xa62, 0x0);           // 32 // 2658
                builder.AppendState(0xa61, 0x1);           // 33
                builder.AppendState(0xa60, 0x1);           // 34
                builder.AppendState(0xa5f, 0x0);           // 35
            }
            break;
        case 3698:                                          // Nagrand Arena
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_NA)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0xa0f, 0x0);           // 7
                builder.AppendState(0xa10, 0x0);           // 8
                builder.AppendState(0xa11, 0x0);           // 9 show
            }
            break;
        case 3702:                                          // Blade's Edge Arena
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BE)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x9f0, 0x0);           // 7 gold
                builder.AppendState(0x9f1, 0x0);           // 8 green
                builder.AppendState(0x9f3, 0x0);           // 9 show
            }
            break;
        case 3968:                                          // Ruins of Lordaeron
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RL)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0xbb8, 0x0);           // 7 gold
                builder.AppendState(0xbb9, 0x0);           // 8 green
                builder.AppendState(0xbba, 0x0);           // 9 show
            }
            break;
        case 4378:                                          // Dalaran Sewers
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DS)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(3601, 0x0);           // 7 gold
                builder.AppendState(3600, 0x0);           // 8 green
                builder.AppendState(3610, 0x0);           // 9 show
            }
            break;
        case 4384:                                          // Strand of the Ancients
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SA)
                bg->FillInitialWorldStates(builder);
            else
            {
                // 1-3 A defend, 4-6 H defend, 7-9 unk defend, 1 - ok, 2 - half destroyed, 3 - destroyed
                builder.AppendState(0xf09, 0x0);       // 7  3849 Gate of Temple
                builder.AppendState(0xe36, 0x0);       // 8  3638 Gate of Yellow Moon
                builder.AppendState(0xe27, 0x0);       // 9  3623 Gate of Green Emerald
                builder.AppendState(0xe24, 0x0);       // 10 3620 Gate of Blue Sapphire
                builder.AppendState(0xe21, 0x0);       // 11 3617 Gate of Red Sun
                builder.AppendState(0xe1e, 0x0);       // 12 3614 Gate of Purple Ametyst

                builder.AppendState(0xdf3, 0x0);       // 13 3571 bonus timer (1 - on, 0 - off)
                builder.AppendState(0xded, 0x0);       // 14 3565 Horde Attacker
                builder.AppendState(0xdec, 0x0);       // 15 3564 Alliance Attacker
                // End Round (timer), better explain this by example, eg. ends in 19:59 -> A:BC
                builder.AppendState(0xde9, 0x0);       // 16 3561 C
                builder.AppendState(0xde8, 0x0);       // 17 3560 B
                builder.AppendState(0xde7, 0x0);       // 18 3559 A
                builder.AppendState(0xe35, 0x0);       // 19 3637 East g - Horde control
                builder.AppendState(0xe34, 0x0);       // 20 3636 West g - Horde control
                builder.AppendState(0xe33, 0x0);       // 21 3635 South g - Horde control
                builder.AppendState(0xe32, 0x0);       // 22 3634 East g - Alliance control
                builder.AppendState(0xe31, 0x0);       // 23 3633 West g - Alliance control
                builder.AppendState(0xe30, 0x0);       // 24 3632 South g - Alliance control
                builder.AppendState(0xe2f, 0x0);       // 25 3631 Chamber of Ancients - Horde control
                builder.AppendState(0xe2e, 0x0);       // 26 3630 Chamber of Ancients - Alliance control
                builder.AppendState(0xe2d, 0x0);       // 27 3629 Beach1 - Horde control
                builder.AppendState(0xe2c, 0x0);       // 28 3628 Beach2 - Horde control
                builder.AppendState(0xe2b, 0x0);       // 29 3627 Beach1 - Alliance control
                builder.AppendState(0xe2a, 0x0);       // 30 3626 Beach2 - Alliance control
                // and many unks...
            }
            break;
        case 4406:                                          // Ring of Valor
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_RV)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0xe10, 0x0);           // 7 gold
                builder.AppendState(0xe11, 0x0);           // 8 green
                builder.AppendState(0xe1a, 0x0);           // 9 show
            }
            break;
        case 4710:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_IC)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(4221, 1); // 7 BG_IC_ALLIANCE_RENFORT_SET
                builder.AppendState(4222, 1); // 8 BG_IC_HORDE_RENFORT_SET
                builder.AppendState(4226, 300); // 9 BG_IC_ALLIANCE_RENFORT
                builder.AppendState(4227, 300); // 10 BG_IC_HORDE_RENFORT
                builder.AppendState(4322, 1); // 11 BG_IC_GATE_FRONT_H_WS_OPEN
                builder.AppendState(4321, 1); // 12 BG_IC_GATE_WEST_H_WS_OPEN
                builder.AppendState(4320, 1); // 13 BG_IC_GATE_EAST_H_WS_OPEN
                builder.AppendState(4323, 1); // 14 BG_IC_GATE_FRONT_A_WS_OPEN
                builder.AppendState(4324, 1); // 15 BG_IC_GATE_WEST_A_WS_OPEN
                builder.AppendState(4325, 1); // 16 BG_IC_GATE_EAST_A_WS_OPEN
                builder.AppendState(4317, 1); // 17 unknown

                builder.AppendState(4301, 1); // 18 BG_IC_DOCKS_UNCONTROLLED
                builder.AppendState(4296, 1); // 19 BG_IC_HANGAR_UNCONTROLLED
                builder.AppendState(4306, 1); // 20 BG_IC_QUARRY_UNCONTROLLED
                builder.AppendState(4311, 1); // 21 BG_IC_REFINERY_UNCONTROLLED
                builder.AppendState(4294, 1); // 22 BG_IC_WORKSHOP_UNCONTROLLED
                builder.AppendState(4243, 1); // 23 unknown
                builder.AppendState(4345, 1); // 24 unknown
            }
            break;
        // The Ruby Sanctum
        case 4987:
            if (instance && mapid == 724)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(5049, 50);             // 9  WORLDSTATE_CORPOREALITY_MATERIAL
                builder.AppendState(5050, 50);             // 10 WORLDSTATE_CORPOREALITY_TWILIGHT
                builder.AppendState(5051, 0);              // 11 WORLDSTATE_CORPOREALITY_TOGGLE
            }
            break;
        // Icecrown Citadel
        case 4812:
            if (instance && mapid == 631)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(4903, 0);              // 9  WORLDSTATE_SHOW_TIMER (Blood Quickening weekly)
                builder.AppendState(4904, 30);             // 10 WORLDSTATE_EXECUTION_TIME
                builder.AppendState(4940, 0);              // 11 WORLDSTATE_SHOW_ATTEMPTS
                builder.AppendState(4941, 50);             // 12 WORLDSTATE_ATTEMPTS_REMAINING
                builder.AppendState(4942, 50);             // 13 WORLDSTATE_ATTEMPTS_MAX
            }
            break;
        // The Culling of Stratholme
        case 4100:
            if (instance && mapid == 595)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(3479, 0);              // 9  WORLDSTATE_SHOW_CRATES
                builder.AppendState(3480, 0);              // 10 WORLDSTATE_CRATES_REVEALED
                builder.AppendState(3504, 0);              // 11 WORLDSTATE_WAVE_COUNT
                builder.AppendState(3931, 25);             // 12 WORLDSTATE_TIME_GUARDIAN
                builder.AppendState(3932, 0);              // 13 WORLDSTATE_TIME_GUARDIAN_SHOW
            }
            break;
        // The Oculus
        case 4228:
            if (instance && mapid == 578)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(3524, 0);              // 9  WORLD_STATE_CENTRIFUGE_CONSTRUCT_SHOW
                builder.AppendState(3486, 0);              // 10 WORLD_STATE_CENTRIFUGE_CONSTRUCT_AMOUNT
            }
            break;
        // Ulduar
        case 4273:
            if (instance && mapid == 603)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(4132, 0);              // 9  WORLDSTATE_ALGALON_TIMER_ENABLED
                builder.AppendState(4131, 0);              // 10 WORLDSTATE_ALGALON_DESPAWN_TIMER
            }
            break;
        // Zul Aman
        case 3805:
            if (instance && mapid == 568)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(3104, 0);              // 9  WORLD_STATE_ZULAMAN_TIMER_ENABLED
                builder.AppendState(3106, 0);              // 10 WORLD_STATE_ZULAMAN_TIMER
            }
            break;
        // End Time, Echo of Jaina
        case 5789:
            if (instance && mapid == 938)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(6046, 0);              // WORLDSTATE_FRAGMENTS_COLLECTED 
                builder.AppendState(6025, 0);              // WORLDSTATE_SHOW_FRAGMENTS
            }
            break;
        // Twin Peaks
        case 5031:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TP)
                bg->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(0x62d, 0x0);       //  7 1581 alliance flag captures
                builder.AppendState(0x62e, 0x0);       //  8 1582 horde flag captures
                builder.AppendState(0x609, 0x0);       //  9 1545 unk
                builder.AppendState(0x60a, 0x0);       // 10 1546 unk
                builder.AppendState(0x60b, 0x2);       // 11 1547 unk
                builder.AppendState(0x641, 0x3);       // 12 1601 unk
                builder.AppendState(0x922, 0x1);       // 13 2338 horde (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
                builder.AppendState(0x923, 0x1);       // 14 2339 alliance (0 - hide, 1 - flag ok, 2 - flag picked up (flashing), 3 - flag picked up (not flashing)
            }
            break;
        // Battle for Gilneas
        case 5449:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_BFG)
                bg->FillInitialWorldStates(builder);
            break;
        // Wintergrasp
        case 4197:
            if (bf && bf->GetTypeId() == BATTLEFIELD_WG)
            {
                bf->FillInitialWorldStates(builder);
                break;
            }
        case 4820:
            if (instance && mapid == 668)
                instance->FillInitialWorldStates(builder);
            else
            {
                builder.AppendState(4884, 0);              // 9  WORLD_STATE_HOR_WAVES_ENABLED
                builder.AppendState(4882, 0);              // 10 WORLD_STATE_HOR_WAVE_COUNT
            }
            break;
        // Deepwind Gorge
        case 6665:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_DG)
                bg->FillInitialWorldStates(builder);
            break;
        // Silvershard Mines
        case 6126:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_SM)
                bg->FillInitialWorldStates(builder);
            break;
        // Temple of Kotmogu
        case 6051:
            if (bg && bg->GetTypeID(true) == BATTLEGROUND_TOK)
                bg->FillInitialWorldStates(builder);
            break;
        // No break here, intended.
        default:
            builder.AppendState(0x914, 0x0);           // 7
            builder.AppendState(0x913, 0x0);           // 8
            builder.AppendState(0x912, 0x0);           // 9
            builder.AppendState(0x915, 0x0);           // 10
            break;
    }

    builder.SendPacket(GetSession());
    SendBGWeekendWorldStates();
    SendBattlefieldWorldStates();
}

void Player::SendBGWeekendWorldStates()
{
    for (uint32 i = 1; i < sBattlemasterListStore.GetNumRows(); ++i)
    {
        BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(i);
        if (bl && bl->HolidayWorldStateId)
        {
            if (BattlegroundMgr::IsBGWeekend((BattlegroundTypeId)bl->id))
                SendUpdateWorldState(bl->HolidayWorldStateId, 1);
            else
                SendUpdateWorldState(bl->HolidayWorldStateId, 0);
        }
    }
}

void Player::SendBattlefieldWorldStates()
{
    /// Send misc stuff that needs to be sent on every login, like the battle timers.
    if (sWorld->getBoolConfig(CONFIG_WINTERGRASP_ENABLE))
    {
        if (BattlefieldWG* wg = (BattlefieldWG*)sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))
        {
            if (wg->IsWarTime())
                SendUpdateWorldState(ClockWorldState[1], uint32(time(NULL)));
            else // Time to next battle
            {
                uint32 timer = wg->GetTimer() / 1000;
                SendUpdateWorldState(ClockWorldState[1], time(NULL) + timer);
            }
        }
    }
}

uint32 Player::GetXPRestBonus(uint32 xp)
{
    uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus

    if (rested_bonus > xp)                                   // max rested_bonus == xp or (r+x) = 200% xp
        rested_bonus = xp;

    SetRestBonus(GetRestBonus() - rested_bonus);

    TC_LOG_INFO("entities.player", "Player gain %u xp (+ %u Rested Bonus). Rested points=%f", xp+rested_bonus, rested_bonus, GetRestBonus());
    return rested_bonus;
}

void Player::SetBindPoint(uint64 guid)
{
    ObjectGuid ikGuid = guid;

    WorldPacket data(SMSG_BINDER_CONFIRM, 9);
    data.WriteBit(ikGuid[4]);
    data.WriteBit(ikGuid[6]);
    data.WriteBit(ikGuid[2]);
    data.WriteBit(ikGuid[1]);
    data.WriteBit(ikGuid[5]);
    data.WriteBit(ikGuid[3]);
    data.WriteBit(ikGuid[0]);
    data.WriteBit(ikGuid[7]);
    data.FlushBits();

    data.WriteByteSeq(ikGuid[6]);
    data.WriteByteSeq(ikGuid[2]);
    data.WriteByteSeq(ikGuid[5]);
    data.WriteByteSeq(ikGuid[0]);
    data.WriteByteSeq(ikGuid[4]);
    data.WriteByteSeq(ikGuid[7]);
    data.WriteByteSeq(ikGuid[1]);
    data.WriteByteSeq(ikGuid[3]);
    GetSession()->SendPacket(&data);
}

void Player::SendTalentWipeConfirm(ObjectGuid guid, bool resetType)
{
    uint32 Cost = 0;

    if (!resetType)
        Cost = sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) ? 0 : GetNextResetTalentsCost();
    else
        Cost = sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST) ? 0 : GetNextResetSpecializationCost();

    WorldPacket data(SMSG_RESPEC_WIPE_CONFIRM, 8 + 1 + 4);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[4]);
    data.WriteBit(guid[6]);

    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[0]);
    data << uint8(resetType);  // 0 = talent, 1 = specialization
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[4]);
    data << uint32(Cost);

    GetSession()->SendPacket(&data);
}

void Player::ResetPetTalents()
{
    // This needs another gossip option + NPC text as a confirmation.
    // The confirmation gossip listid has the text: "Yes, please do."
    Pet* pet = GetPet();

    if (!pet || pet->getPetType() != HUNTER_PET)
        return;

    CharmInfo* charmInfo = pet->GetCharmInfo();
    if (!charmInfo)
    {
        TC_LOG_ERROR("entities.player", "Object (GUID: %u TypeId: %u) is considered pet-like but doesn't have a charminfo!", pet->GetGUIDLow(), pet->GetTypeId());
        return;
    }
    pet->SetSpecialization(0);
}

/*********************************************************/
/***                    STORAGE SYSTEM                 ***/
/*********************************************************/

void Player::SetVirtualItemSlot(uint8 i, Item* item)
{
}

void Player::SetSheath(SheathState sheathed)
{
    switch (sheathed)
    {
        case SHEATH_STATE_UNARMED:                          // no prepared weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_MELEE:                            // prepared melee weapon
            SetVirtualItemSlot(0, GetWeaponForAttack(BASE_ATTACK, true));
            SetVirtualItemSlot(1, GetWeaponForAttack(OFF_ATTACK, true));
            SetVirtualItemSlot(2, NULL);
            break;
        case SHEATH_STATE_RANGED:                           // prepared ranged weapon
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, GetWeaponForAttack(RANGED_ATTACK, true));
            break;
        default:
            SetVirtualItemSlot(0, NULL);
            SetVirtualItemSlot(1, NULL);
            SetVirtualItemSlot(2, NULL);
            break;
    }
    Unit::SetSheath(sheathed);                              // this must visualize Sheath changing for other players...
}

uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) const
{
    uint8 playerClass = getClass();

    uint8 slots[4];
    slots[0] = NULL_SLOT;
    slots[1] = NULL_SLOT;
    slots[2] = NULL_SLOT;
    slots[3] = NULL_SLOT;
    switch (proto->InventoryType)
    {
        case INVTYPE_HEAD:
            slots[0] = EQUIPMENT_SLOT_HEAD;
            break;
        case INVTYPE_NECK:
            slots[0] = EQUIPMENT_SLOT_NECK;
            break;
        case INVTYPE_SHOULDERS:
            slots[0] = EQUIPMENT_SLOT_SHOULDERS;
            break;
        case INVTYPE_BODY:
            slots[0] = EQUIPMENT_SLOT_BODY;
            break;
        case INVTYPE_CHEST:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_ROBE:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_WAIST:
            slots[0] = EQUIPMENT_SLOT_WAIST;
            break;
        case INVTYPE_LEGS:
            slots[0] = EQUIPMENT_SLOT_LEGS;
            break;
        case INVTYPE_FEET:
            slots[0] = EQUIPMENT_SLOT_FEET;
            break;
        case INVTYPE_WRISTS:
            slots[0] = EQUIPMENT_SLOT_WRISTS;
            break;
        case INVTYPE_HANDS:
            slots[0] = EQUIPMENT_SLOT_HANDS;
            break;
        case INVTYPE_FINGER:
            slots[0] = EQUIPMENT_SLOT_FINGER1;
            slots[1] = EQUIPMENT_SLOT_FINGER2;
            break;
        case INVTYPE_TRINKET:
            slots[0] = EQUIPMENT_SLOT_TRINKET1;
            slots[1] = EQUIPMENT_SLOT_TRINKET2;
            break;
        case INVTYPE_CLOAK:
            slots[0] = EQUIPMENT_SLOT_BACK;
            break;
        case INVTYPE_WEAPON:
        {
            slots[0] = EQUIPMENT_SLOT_MAINHAND;

            // suggest offhand slot only if know dual wielding
            // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
            if (CanDualWield())
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        }
        case INVTYPE_SHIELD:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_RANGED:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_2HWEAPON:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            if (CanDualWield() && CanTitanGrip() && proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_TABARD:
            slots[0] = EQUIPMENT_SLOT_TABARD;
            break;
        case INVTYPE_WEAPONMAINHAND:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            break;
        case INVTYPE_WEAPONOFFHAND:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_HOLDABLE:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_THROWN:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_RANGEDRIGHT:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_BAG:
            slots[0] = INVENTORY_SLOT_BAG_START + 0;
            slots[1] = INVENTORY_SLOT_BAG_START + 1;
            slots[2] = INVENTORY_SLOT_BAG_START + 2;
            slots[3] = INVENTORY_SLOT_BAG_START + 3;
            break;
        case INVTYPE_RELIC:
        {
           if (playerClass == CLASS_PALADIN || playerClass == CLASS_DRUID ||
               playerClass == CLASS_SHAMAN || playerClass == CLASS_DEATH_KNIGHT)
           {
               slots[0] = EQUIPMENT_SLOT_MAINHAND;
               if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
               {
                   if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                   {
                       if (mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                       {
                           const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                           break;
                       }
                   }
               }

               if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
               {
                   if (proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
                   {
                       const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                       break;
                   }
               }
           }
           break;
        }
        default:
            return NULL_SLOT;
    }

    if (slot != NULL_SLOT)
    {
        if (swap || !GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
            for (uint8 i = 0; i < 4; ++i)
                if (slots[i] == slot)
                    return slot;
    }
    else
    {
        // search free slot at first
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && !GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]))
                // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
                if (slots[i] != EQUIPMENT_SLOT_OFFHAND || !IsTwoHandUsed())
                    return slots[i];

        // if not found free and can swap return first appropriate from used
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && swap)
                return slots[i];
    }

    // no free position
    return NULL_SLOT;
}

InventoryResult Player::CanUnequipItems(uint32 item, uint32 count) const
{
    uint32 tempcount = 0;

    InventoryResult res = EQUIP_ERR_OK;

    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                InventoryResult ires = CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false);
                if (ires == EQUIP_ERR_OK)
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return EQUIP_ERR_OK;
                }
                else
                    res = ires;
            }

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }


    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = GetItemByPos(i, j))
                    if (pItem->GetEntry() == item)
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return EQUIP_ERR_OK;
                    }

    // not found req. item count and have unequippable items
    return res;
}

uint32 Player::GetItemCount(uint32 item, bool inBankAlso, Item* skipItem) const
{
    uint32 count = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCount(item, skipItem);

    if (skipItem && skipItem->GetTemplate()->GemProperties)
        for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                    count += pItem->GetGemCountWithID(item);

    if (inBankAlso)
    {
        // checking every item from 39 to 74 (including bank bags)
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                count += pBag->GetItemCount(item, skipItem);

        if (skipItem && skipItem->GetTemplate()->GemProperties)
            for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
                if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (pItem != skipItem && pItem->GetTemplate()->Socket[0].Color)
                        count += pItem->GetGemCountWithID(item);
    }

    return count;
}

uint32 Player::GetItemCountWithLimitCategory(uint32 limitCategory, Item* skipItem) const
{
    uint32 count = 0;
    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->ItemLimitCategory == limitCategory)
                        count += pItem->GetCount();

    for (int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    return count;
}

Item* Player::GetItemByGuid(uint64 guid) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    return NULL;
}

Item* Player::GetItemByPos(uint16 pos) const
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    return GetItemByPos(bag, slot);
}

Item* Player::GetItemByPos(uint8 bag, uint8 slot) const
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot < BANK_SLOT_BAG_END)
        return m_items[slot];
    else if (Bag* pBag = GetBagByPos(bag))
        return pBag->GetItemByPos(slot);
    return NULL;
}

//Does additional check for disarmed weapons
Item* Player::GetUseableItemByPos(uint8 bag, uint8 slot) const
{
    if (!CanUseAttackType(GetAttackBySlot(slot)))
        return NULL;
    return GetItemByPos(bag, slot);
}

Bag* Player::GetBagByPos(uint8 bag) const
{
    if ((bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        || (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END))
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
            return item->ToBag();
    return NULL;
}

Item* Player::GetWeaponForAttack(WeaponAttackType attackType, bool useable /*= false*/) const
{
    uint8 slot;
    switch (attackType)
    {
        case RANGED_ATTACK:
        case BASE_ATTACK:
            slot = EQUIPMENT_SLOT_MAINHAND;
            break;
        case OFF_ATTACK:
            slot = EQUIPMENT_SLOT_OFFHAND;
            break;

        default: return NULL;
    }

    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_WEAPON)
        return NULL;

    if (!useable)
        return item;

    if (item->IsBroken() || IsInFeralForm())
        return NULL;

    return item;
}

Item* Player::GetShield(bool useable) const
{
    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!item || item->GetTemplate()->Class != ITEM_CLASS_ARMOR)
        return NULL;

    if (!useable)
        return item;

    if (item->IsBroken())
        return NULL;

    return item;
}

uint8 Player::GetAttackBySlot(uint8 slot)
{
    switch (slot)
    {
        case EQUIPMENT_SLOT_MAINHAND: return BASE_ATTACK;
        case EQUIPMENT_SLOT_OFFHAND:  return OFF_ATTACK;
        default:                      return MAX_ATTACK;
    }
}

bool Player::IsInventoryPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot == NULL_SLOT)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END))
        return true;
    if (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsEquipmentPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot < EQUIPMENT_SLOT_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    if (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsBagPos(uint16 pos)
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsValidPos(uint8 bag, uint8 slot, bool explicit_pos)
{
    // post selected
    if (bag == NULL_BAG && !explicit_pos)
        return true;

    if (bag == INVENTORY_SLOT_BAG_0)
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        // equipment
        if (slot < EQUIPMENT_SLOT_END)
            return true;

        // bag equip slots
        if (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END)
            return true;

        // backpack slots
        if (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END)
            return true;

        // bank main slots
        if (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END)
            return true;

        // bank bag slots
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
            return true;

        return false;
    }

    // bag content slots
    // bank bag content slots
    if (Bag* pBag = GetBagByPos(bag))
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        return slot < pBag->GetBagSize();
    }

    // where this?
    return false;
}

uint64 Player::GetDonateTokens() const
{
	PreparedStatement* stmt = FusionCMSDatabase.GetPreparedStatement(FUSION_SEL_BATTLEPAY_COINS);
	stmt->setUInt32(0, GetSession()->GetAccountId());

	PreparedQueryResult result_don = FusionCMSDatabase.Query(stmt);

	if (!result_don)
		return 0;

	Field* fields = result_don->Fetch();
	uint64 balans = fields[0].GetUInt32();

	return balans;
}

void Player::DestroyDonateTokenCount(uint64 count)
{
    PreparedStatement* stmt = FusionCMSDatabase.GetPreparedStatement(FUSION_UPD_BATTLEPAY_DECREMENT_COINS);
    stmt->setUInt32(0, count);
    stmt->setUInt32(1, GetSession()->GetAccountId());    
    FusionCMSDatabase.Query(stmt);
}

void Player::AddDonateTokenCount(uint64 count)
{
    // add coins
	PreparedStatement* stmt = FusionCMSDatabase.GetPreparedStatement(FUSION_UPD_BATTLEPAY_INCREMENT_COINS);
    stmt->setUInt32(0, count);
    stmt->setUInt32(1, GetSession()->GetAccountId());    
    FusionCMSDatabase.Query(stmt);
    
    // Register the wow token
    PreparedStatement* stmt2 = LoginDatabase.GetPreparedStatement(LOGIN_INS_WOW_TOKEN);
    stmt2->setUInt32(0, GetSession()->GetAccountId());
    stmt2->setUInt32(1, GetGUID());
    stmt2->setUInt32(2, realmID);
    stmt2->setUInt32(3, (count / 10000));
    LoginDatabase.Query(stmt2);
}

void Player::SendBattlePayMessage(std::string const& n)
{
    std::ostringstream msg;
    msg << n;
    ChatHandler(this).SendSysMessage(msg.str().c_str());
}

void Player::SendBattlePayMessage(std::string const& n, std::ostringstream const& data)
{
	std::ostringstream msg;
	msg << n << " | " << data.str() << " | ";
	ChatHandler(this).SendSysMessage(msg.str().c_str());
}

bool Player::HasItemCount(uint32 item, uint32 count, bool inBankAlso) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* pItem = GetItemByPos(i, j);
                if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return true;
                }
            }
        }
    }

    if (inBankAlso)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return true;
            }
        }
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            if (Bag* pBag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                {
                    Item* pItem = GetItemByPos(i, j);
                    if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return true;
                    }
                }
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithIdEquipped(uint32 item, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (pProto && pProto->GemProperties)
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (i == except_slot)
                continue;

            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetTemplate()->Socket[0].Color)
            {
                tempcount += pItem->GetGemCountWithID(item);
                if (tempcount >= count)
                    return true;
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithLimitCategoryEquipped(uint32 limitCategory, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (!pItem)
            continue;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (!pProto)
            continue;

        if (pProto->ItemLimitCategory == limitCategory)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }

        if (pProto->Socket[0].Color || pItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
        {
            tempcount += pItem->GetGemCountWithLimitCategory(limitCategory);
            if (tempcount >= count)
                return true;
        }
    }

    return false;
}

InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count) const
{
    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    if (pItem && pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // no maximum
    if ((pProto->MaxCount <= 0 && pProto->ItemLimitCategory == 0) || pProto->MaxCount == 2147483647)
        return EQUIP_ERR_OK;

    if (pProto->MaxCount > 0)
    {
        uint32 curcount = GetItemCount(pProto->ItemId, true, pItem);
        if (curcount + count > uint32(pProto->MaxCount))
        {
            if (no_space_count)
                *no_space_count = count + curcount - pProto->MaxCount;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // check unique-equipped limit
    if (pProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(pProto->ItemLimitCategory);
        if (!limitEntry)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_EQUIPPABLE;
        }

        if (limitEntry->mode == ITEM_LIMIT_CATEGORY_MODE_HAVE)
        {
            uint32 curcount = GetItemCountWithLimitCategory(pProto->ItemLimitCategory, pItem);
            if (curcount + count > uint32(limitEntry->maxCount))
            {
                if (no_space_count)
                    *no_space_count = count + curcount - limitEntry->maxCount;
                return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS;
            }
        }
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreNewItem(uint8 bag, uint8 slot, ItemPosCountVec& dest, uint32 item, uint32 count, uint32* no_space_count /*= NULL*/) const
{
    return CanStoreItem(bag, slot, dest, item, count, NULL, false, no_space_count);
}

InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec& dest, Item* pItem, bool swap /*= false*/) const
{
    if (!pItem)
        return EQUIP_ERR_ITEM_NOT_FOUND;
    uint32 count = pItem->GetCount();
    return CanStoreItem(bag, slot, dest, pItem->GetEntry(), count, pItem, swap, NULL);
}

InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const
{
    Item* pItem2 = GetItemByPos(bag, slot);

    // ignore move item (this slot will be empty at move)
    if (pItem2 == pSrcItem)
        pItem2 = NULL;

    uint32 need_space;

    if (pSrcItem && pSrcItem->IsNotEmptyBag() && !IsBagPos(uint16(bag) << 8 | slot))
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    // empty specific slot - check item fit to slot
    if (!pItem2 || swap)
    {
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            // prevent cheating
            if ((slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END) || slot >= PLAYER_SLOT_END)
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }
        else
        {
            Bag* pBag = GetBagByPos(bag);
            if (!pBag)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            ItemTemplate const* pBagProto = pBag->GetTemplate();
            if (!pBagProto)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (slot >= pBagProto->ContainerSlots)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (!ItemCanGoIntoBag(pProto, pBagProto))
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }

        // non empty stack with space
        need_space = pProto->GetMaxStackSize();
    }
    // non empty slot, check item type
    else
    {
        // can be merged at least partly
        InventoryResult res  = pItem2->CanBeMergedPartlyWith(pProto);
        if (res != EQUIP_ERR_OK)
            return res;

        // free stack space or infinity
        need_space = pProto->GetMaxStackSize() - pItem2->GetCount();
    }

    if (need_space > count)
        need_space = count;

    ItemPosCount newPosition = ItemPosCount((bag << 8) | slot, need_space);
    if (!newPosition.isContainedIn(dest))
    {
        dest.push_back(newPosition);
        count -= need_space;
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InBag(uint8 bag, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    // skip specific bag already processed in first called CanStoreItem_InBag
    if (bag == skip_bag)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // skip not existed bag or self targeted bag
    Bag* pBag = GetBagByPos(bag);
    if (!pBag || pBag == pSrcItem)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    ItemTemplate const* pBagProto = pBag->GetTemplate();
    if (!pBagProto)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // specialized bag mode or non-specilized
    if (non_specialized != (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (!ItemCanGoIntoBag(pProto, pBagProto))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    for (uint32 j = 0; j < pBag->GetBagSize(); j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(bag, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((bag << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 slot_end, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    //this is never called for non-bag slots so we can do this
    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    for (uint32 j = slot_begin; j < slot_end; j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (INVENTORY_SLOT_BAG_0 == skip_bag && j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((INVENTORY_SLOT_BAG_0 << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count) const
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: CanStoreItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, entry, count);

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;
    }

    if (pItem)
    {
        // item used
        if (pItem->m_lootGenerated)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_LOOT_GONE;
        }

        if (pItem->IsBindedNotWith(this))
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_OWNER;
        }
    }

    // check count of items (skip for auto move for same player from bank)
    uint32 no_similar_count = 0;                            // can't store this amount similar items
    InventoryResult res = CanTakeMoreSimilarItems(entry, count, pItem, &no_similar_count);
    if (res != EQUIP_ERR_OK)
    {
        if (count == no_similar_count)
        {
            if (no_space_count)
                *no_space_count = no_similar_count;
            return res;
        }
        count -= no_similar_count;
    }

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)               // inventory
            {
                res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            else                                            // equipped bag
            {
                // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        // search free slot in bag for place to
        if (bag == INVENTORY_SLOT_BAG_0)                     // inventory
        {
            res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
        else                                                // equipped bag
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        if (pProto->BagFamily)
        {
            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // search free slot - special bag case
    if (pProto->BagFamily)
    {
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    if (pItem && pItem->IsNotEmptyBag())
        return EQUIP_ERR_BAG_IN_BAG;

    // search free slot
    res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, INVENTORY_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
    {
        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return res;
    }

    if (count == 0)
    {
        if (no_similar_count == 0)
            return EQUIP_ERR_OK;

        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    if (no_space_count)
        *no_space_count = count + no_similar_count;

    return EQUIP_ERR_INV_FULL;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanStoreItems(Item** pItems, int count) const
{
    Item* pItem2;

    // fill space table
    int inv_slot_items[INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START];
    int inv_bags[INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START][MAX_BAG_SIZE];

    memset(inv_slot_items, 0, sizeof(int) * (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));
    memset(inv_bags, 0, sizeof(int) * (INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START) * MAX_BAG_SIZE);

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
    {
        pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->IsInTrade())
            inv_slot_items[i - INVENTORY_SLOT_ITEM_START] = pItem2->GetCount();
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                pItem2 = GetItemByPos(i, j);
                if (pItem2 && !pItem2->IsInTrade())
                    inv_bags[i - INVENTORY_SLOT_BAG_START][j] = pItem2->GetCount();
            }

    // check free space for all items
    for (int k = 0; k < count; ++k)
    {
        Item* pItem = pItems[k];

        // no item
        if (!pItem)
            continue;

        TC_LOG_DEBUG("entities.player.items", "STORAGE: CanStoreItems %i. item = %u, count = %u", k + 1, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();

        // strange item
        if (!pProto)
            return EQUIP_ERR_ITEM_NOT_FOUND;

        // item used
        if (pItem->m_lootGenerated)
            return EQUIP_ERR_LOOT_GONE;

        // item it 'bind'
        if (pItem->IsBindedNotWith(this))
            return EQUIP_ERR_NOT_OWNER;

        ItemTemplate const* pBagProto;

        // item is 'one item only'
        InventoryResult res = CanTakeMoreSimilarItems(pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        // search stack for merge to
        if (pProto->Stackable != 1)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
            {
                pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, t);
                if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_slot_items[t-INVENTORY_SLOT_ITEM_START] + pItem->GetCount() <= pProto->GetMaxStackSize())
                {
                    inv_slot_items[t-INVENTORY_SLOT_ITEM_START] += pItem->GetCount();
                    b_found = true;
                    break;
                }
            }
            if (b_found)
                continue;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    if (ItemCanGoIntoBag(pItem->GetTemplate(), bag->GetTemplate()))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            pItem2 = GetItemByPos(t, j);
                            if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_bags[t-INVENTORY_SLOT_BAG_START][j] + pItem->GetCount() <= pProto->GetMaxStackSize())
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] += pItem->GetCount();
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // special bag case
        if (pProto->BagFamily)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    pBagProto = bag->GetTemplate();

                    // not plain container check
                    if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER) &&
                        ItemCanGoIntoBag(pProto, pBagProto))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // search free slot
        bool b_found = false;
        for (int t = INVENTORY_SLOT_ITEM_START; t < INVENTORY_SLOT_ITEM_END; ++t)
        {
            if (inv_slot_items[t-INVENTORY_SLOT_ITEM_START] == 0)
            {
                inv_slot_items[t-INVENTORY_SLOT_ITEM_START] = 1;
                b_found = true;
                break;
            }
        }
        if (b_found)
            continue;

        // search free slot in bags
        for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
        {
            if (Bag* bag = GetBagByPos(t))
            {
                pBagProto = bag->GetTemplate();

                // special bag already checked
                if (pBagProto && (pBagProto->Class != ITEM_CLASS_CONTAINER || pBagProto->SubClass != ITEM_SUBCLASS_CONTAINER))
                    continue;

                for (uint32 j = 0; j < bag->GetBagSize(); j++)
                {
                    if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                    {
                        inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                        b_found = true;
                        break;
                    }
                }
            }
        }

        // no free slot found?
        if (!b_found)
            return EQUIP_ERR_INV_FULL;
    }

    return EQUIP_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanEquipNewItem(uint8 slot, uint16 &dest, uint32 item, bool swap) const
{
    dest = 0;
    Item* pItem = Item::CreateItem(item, 1, this);
    if (pItem)
    {
        InventoryResult result = CanEquipItem(slot, dest, pItem, swap);
        delete pItem;
        return result;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool swap, bool not_loading) const
{
    dest = 0;
    if (pItem)
    {
        TC_LOG_DEBUG("entities.player.items", "STORAGE: CanEquipItem slot = %u, item = %u, count = %u", slot, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            // item used
            if (pItem->m_lootGenerated)
                return EQUIP_ERR_LOOT_GONE;

            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            // check count of items (skip for auto move for same player from bank)
            InventoryResult res = CanTakeMoreSimilarItems(pItem);
            if (res != EQUIP_ERR_OK)
                return res;

            // check this only in game
            if (not_loading)
            {
                // May be here should be more stronger checks; STUNNED checked
                // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
                if (HasUnitState(UNIT_STATE_STUNNED))
                    return EQUIP_ERR_GENERIC_STUNNED;

                // do not allow equipping gear except weapons, offhands, projectiles, relics in
                // - combat
                // - in-progress arenas
                if (!pProto->CanChangeEquipStateInCombat())
                {
                    if (IsInCombat())
                        return EQUIP_ERR_NOT_IN_COMBAT;

                    if (Battleground* bg = GetBattleground())
                        if (bg->IsArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                            return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
                }

                if (IsInCombat()&& (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer != 0)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;         // maybe exist better err

                if (IsNonMeleeSpellCasted(false))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }

            // ScalingStatDistributionEntry const* ssd = pProto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(pProto->ScalingStatDistribution) : 0;
            // check allowed level (extend range to upper values if MaxLevel more or equal max player level, this let GM set high level with 1...max range items)
            // if (ssd && ssd->MaxLevel < DEFAULT_MAX_LEVEL && ssd->MaxLevel < getLevel())
            //     return EQUIP_ERR_NOT_EQUIPPABLE;

            uint8 eslot = FindEquipSlot(pProto, slot, swap);
            if (eslot == NULL_SLOT)
                return EQUIP_ERR_NOT_EQUIPPABLE;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;

            if (!swap && GetItemByPos(INVENTORY_SLOT_BAG_0, eslot))
                return EQUIP_ERR_NO_SLOT_AVAILABLE;

            // if we are swapping 2 equiped items, CanEquipUniqueItem check
            // should ignore the item we are trying to swap, and not the
            // destination item. CanEquipUniqueItem should ignore destination
            // item only when we are swapping weapon from bag
            uint8 ignore = uint8(NULL_SLOT);
            switch (eslot)
            {
                case EQUIPMENT_SLOT_MAINHAND:
                    ignore = EQUIPMENT_SLOT_OFFHAND;
                    break;
                case EQUIPMENT_SLOT_OFFHAND:
                    ignore = EQUIPMENT_SLOT_MAINHAND;
                    break;
                case EQUIPMENT_SLOT_FINGER1:
                    ignore = EQUIPMENT_SLOT_FINGER2;
                    break;
                case EQUIPMENT_SLOT_FINGER2:
                    ignore = EQUIPMENT_SLOT_FINGER1;
                    break;
                case EQUIPMENT_SLOT_TRINKET1:
                    ignore = EQUIPMENT_SLOT_TRINKET2;
                    break;
                case EQUIPMENT_SLOT_TRINKET2:
                    ignore = EQUIPMENT_SLOT_TRINKET1;
                    break;
            }

            if (ignore == uint8(NULL_SLOT) || pItem != GetItemByPos(INVENTORY_SLOT_BAG_0, ignore))
                ignore = eslot;

            InventoryResult res2 = CanEquipUniqueItem(pItem, swap ? ignore : uint8(NULL_SLOT));
            if (res2 != EQUIP_ERR_OK)
                return res2;

            // check unique-equipped special item classes
            if (pProto->Class == ITEM_CLASS_QUIVER)
                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
                    if (Item* pBag = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                        if (pBag != pItem)
                            if (ItemTemplate const* pBagProto = pBag->GetTemplate())
                                if (pBagProto->Class == pProto->Class && (!swap || pBag->GetSlot() != eslot))
                                    return (pBagProto->SubClass == ITEM_SUBCLASS_AMMO_POUCH)
                                        ? EQUIP_ERR_ONLY_ONE_AMMO
                                        : EQUIP_ERR_ONLY_ONE_QUIVER;

            uint32 type = pProto->InventoryType;

            if (eslot == EQUIPMENT_SLOT_OFFHAND)
            {
                // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
                if (type == INVTYPE_WEAPON && pProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
                    return EQUIP_ERR_2HSKILLNOTFOUND;
                else if (type == INVTYPE_WEAPON || type == INVTYPE_WEAPONOFFHAND)
                {
                    if (!CanDualWield())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_2HWEAPON)
                {
                    if (!CanDualWield() || !CanTitanGrip())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }

                if (IsTwoHandUsed())
                    return EQUIP_ERR_2HANDED_EQUIPPED;

                if (Item* mh = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
                    if (mh->IsRangedWeapon())
                        return EQUIP_ERR_2HANDED_EQUIPPED;
            }

            // equip two-hand weapon case (with possible unequip 2 items)
            if (type == INVTYPE_2HWEAPON)
            {
                if (eslot == EQUIPMENT_SLOT_OFFHAND)
                {
                    if (!CanTitanGrip())
                        return EQUIP_ERR_NOT_EQUIPPABLE;
                }
                else if (eslot != EQUIPMENT_SLOT_MAINHAND)
                    return EQUIP_ERR_NOT_EQUIPPABLE;

                if (!CanTitanGrip())
                {
                    // offhand item must can be stored in inventory for offhand item and it also must be unequipped
                    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                    ItemPosCountVec off_dest;
                    if (offItem && (!not_loading ||
                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
                        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_INV_FULL;
                }
            }
            dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
            return EQUIP_ERR_OK;
        }
    }

    return !swap ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_CANT_SWAP;
}

InventoryResult Player::CanUnequipItem(uint16 pos, bool swap) const
{
    // Applied only to equipped items and bank bags
    if (!IsEquipmentPos(pos) && !IsBagPos(pos))
        return EQUIP_ERR_OK;

    Item* pItem = GetItemByPos(pos);

    // Applied only to existed equipped item
    if (!pItem)
        return EQUIP_ERR_OK;

    TC_LOG_DEBUG("entities.player.items", "STORAGE: CanUnequipItem slot = %u, item = %u, count = %u", pos, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // do not allow unequipping gear except weapons, offhands, projectiles, relics in
    // - combat
    // - in-progress arenas
    if (!pProto->CanChangeEquipStateInCombat())
    {
        if (IsInCombat())
            return EQUIP_ERR_NOT_IN_COMBAT;

        if (Battleground* bg = GetBattleground())
            if (bg->IsArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
    }

    if (!swap && pItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    TC_LOG_DEBUG("entities.player.items", "STORAGE: CanBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());
    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // Currency Tokenizer are not supposed to be swapped out of their hidden bag
    if (pItem->IsCurrencyToken())
    {
        TC_LOG_ERROR("entities.player", "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
                GetName().c_str(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->ItemId);
        return EQUIP_ERR_CANT_SWAP;
    }

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);
    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
        {
            if (!pItem->IsBag())
                return EQUIP_ERR_WRONG_SLOT;

            if (slot - BANK_SLOT_BAG_START >= GetBankBagSlotCount())
                return EQUIP_ERR_NO_BANK_SLOT;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;
        }

        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        if (pItem->IsNotEmptyBag())
            return EQUIP_ERR_BAG_IN_BAG;

        // search stack in bag for merge to
        if (pProto->Stackable != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)
            {
                res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
            else
            {
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        // search free slot in bag
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
        else
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->Stackable != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;

        // in special bags
        if (pProto->BagFamily)
        {
            for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free place in special bag
    if (pProto->BagFamily)
    {
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free space
    res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
            return EQUIP_ERR_OK;
    }
    return EQUIP_ERR_BANK_FULL;
}

InventoryResult Player::CanUseItem(Item* pItem, bool not_loading) const
{
    if (pItem)
    {
        TC_LOG_DEBUG("entities.player.items", "STORAGE: CanUseItem item = %u", pItem->GetEntry());

        if (!IsAlive() && not_loading)
            return EQUIP_ERR_PLAYER_DEAD;

        //if (isStunned())
        //    return EQUIP_ERR_GENERIC_STUNNED;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            InventoryResult res = CanUseItem(pProto);
            if (res != EQUIP_ERR_OK)
                return res;

            if (pItem->GetSkill() != 0)
            {
                bool allowEquip = false;
                uint32 itemSkill = pItem->GetSkill();
                // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
                if (pProto->Quality == ITEM_QUALITY_HEIRLOOM && pProto->Class == ITEM_CLASS_ARMOR && !HasSkill(itemSkill))
                {
                    /// @todo when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.
                    // In fact it's a visual bug, everything works properly... I need sniffs of operations with
                    // binded to account items from off server.

                    switch (getClass())
                    {
                        case CLASS_HUNTER:
                        case CLASS_SHAMAN:
                            allowEquip = (itemSkill == SKILL_MAIL);
                            break;
                        case CLASS_PALADIN:
                        case CLASS_WARRIOR:
                            allowEquip = (itemSkill == SKILL_PLATE_MAIL);
                            break;
                    }
                }
                if (!allowEquip && GetSkillValue(itemSkill) == 0)
                    return EQUIP_ERR_PROFICIENCY_NEEDED;
            }

            if (pProto->RequiredReputationFaction && uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank)
                return EQUIP_ERR_CANT_EQUIP_REPUTATION;

            return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
{
    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player

    if (proto)
    {
        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if (proto->RequiredSkill != 0)
        {
            if (GetSkillValue(proto->RequiredSkill) == 0)
                return EQUIP_ERR_PROFICIENCY_NEEDED;
            else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
                return EQUIP_ERR_CANT_EQUIP_SKILL;
        }

        if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
            return EQUIP_ERR_PROFICIENCY_NEEDED;

        if (getLevel() < proto->RequiredLevel)
            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;

        // If World Event is not active, prevent using event dependant items
        if (proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
            return EQUIP_ERR_CLIENT_LOCKED_OUT;

        if (proto->FlagsCu & ITEM_FLAGS_CU_EQUIP_DISABLE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        return EQUIP_ERR_OK;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanRollForItemInLFG(ItemTemplate const* proto, WorldObject const* lootedObject) const
{
    if (!GetGroup())
        return EQUIP_ERR_OK;

    // check if looted object is inside the lfg dungeon
    Map const* map = lootedObject->GetMap();

    if (!proto)
        return EQUIP_ERR_ITEM_NOT_FOUND;
   // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player

    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
    {
        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
        SKILL_STAVES,   0,              0,                   SKILL_FIST_WEAPONS,   0,
        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
        SKILL_FISHING
    }; //Copy from function Item::GetSkill()

    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
        return EQUIP_ERR_CANT_EQUIP_EVER;

    if (proto->RequiredSpell != 0 && !HasSpell(proto->RequiredSpell))
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->RequiredSkill != 0)
    {
        if (!GetSkillValue(proto->RequiredSkill))
            return EQUIP_ERR_PROFICIENCY_NEEDED;
        else if (GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
            return EQUIP_ERR_CANT_EQUIP_SKILL;
    }

    uint8 _class = getClass();

    if (proto->Class == ITEM_CLASS_WEAPON && GetSkillValue(item_weapon_skills[proto->SubClass]) == 0)
        return EQUIP_ERR_PROFICIENCY_NEEDED;

    if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass > ITEM_SUBCLASS_ARMOR_MISCELLANEOUS && proto->SubClass < ITEM_SUBCLASS_ARMOR_COSMETIC && proto->InventoryType != INVTYPE_CLOAK)
    {
        if (_class == CLASS_WARRIOR || _class == CLASS_PALADIN || _class == CLASS_DEATH_KNIGHT)
        {
            if (getLevel() < 50)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }
        else if (_class == CLASS_HUNTER || _class == CLASS_SHAMAN)
        {
            if (getLevel() < 50)
            {
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }
            else if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
        }

        if (_class == CLASS_ROGUE || _class == CLASS_DRUID || _class == CLASS_MONK)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;

        if (_class == CLASS_MAGE || _class == CLASS_PRIEST || _class == CLASS_WARLOCK)
            if (proto->SubClass != ITEM_SUBCLASS_ARMOR_CLOTH)
                return EQUIP_ERR_CLIENT_LOCKED_OUT;
    }

    uint32 _spec = GetTalentSpecialization();

    if (proto->Flags2 & ITEM_FLAGS_EXTRA_LFR_ITEM)
    {
        bool canRoll = false;
        if (auto group = GetGroup())
        {
            if (group->isLFGGroup())
            {
                if ((proto->Flags2 & ITEM_FLAGS_EXTRA_TANK_ITEM) && (const_cast<Group*>(group)->GetLfgRoles(GetGUID()) & lfg::PLAYER_ROLE_TANK))
                    canRoll = true;
                else if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HEALER_ITEM) && (const_cast<Group*>(group)->GetLfgRoles(GetGUID()) & lfg::PLAYER_ROLE_HEALER))
                    canRoll = true;
                else if ((proto->Flags2 & ITEM_FLAGS_EXTRA_DAMAGE_ITEM) && (const_cast<Group*>(group)->GetLfgRoles(GetGUID()) & lfg::PLAYER_ROLE_DAMAGE))
                    canRoll = true;
            }
            else
            {
                if ((proto->Flags2 & ITEM_FLAGS_EXTRA_TANK_ITEM) &&
                   ((_class == CLASS_WARRIOR && _spec == SPEC_WARRIOR_PROTECTION) ||
                    (_class == CLASS_PALADIN && _spec == SPEC_PALADIN_PROTECTION) ||
                    (_class == CLASS_DEATH_KNIGHT && _spec == SPEC_DEATH_KNIGHT_BLOOD) ||
                    (_class == CLASS_MONK && _spec == SPEC_MONK_BREWMASTER) ||
                    (_class == CLASS_DRUID && _spec == SPEC_DRUID_GUARDIAN)))
                    canRoll = true;
                else if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HEALER_ITEM) &&
                   ((_class == CLASS_PALADIN && _spec == SPEC_PALADIN_HOLY) ||
                    (_class == CLASS_PRIEST && (_spec == SPEC_PRIEST_DISCIPLINE || _spec == SPEC_PRIEST_HOLY)) ||
                    (_class == CLASS_SHAMAN && _spec == SPEC_SHAMAN_RESTORATION) ||
                    (_class == CLASS_MONK && _spec == SPEC_MONK_MISTWEAVER) ||
                    (_class == CLASS_DRUID && _spec == SPEC_DRUID_RESTORATION)))
                        canRoll = true;
                else if ((proto->Flags2 & ITEM_FLAGS_EXTRA_DAMAGE_ITEM) &&
                    ((_class == CLASS_WARRIOR && (_spec == SPEC_WARRIOR_ARMS || _spec == SPEC_WARRIOR_FURY)) ||
                     (_class == CLASS_PALADIN && _spec == SPEC_PALADIN_RETRIBUTION) ||
                     (_class == CLASS_HUNTER && _spec != SPEC_NONE) ||
                     (_class == CLASS_ROGUE && _spec != SPEC_NONE) ||
                     (_class == CLASS_PRIEST && _spec == SPEC_PRIEST_SHADOW) ||
                     (_class == CLASS_DEATH_KNIGHT && (_spec == SPEC_DEATH_KNIGHT_FROST || _spec == SPEC_DEATH_KNIGHT_UNHOLY)) ||
                     (_class == CLASS_SHAMAN && (_spec == SPEC_SHAMAN_ELEMENTAL || _spec == SPEC_SHAMAN_ENHANCEMENT)) ||
                     (_class == CLASS_MAGE && _spec != SPEC_NONE) ||
                     (_class == CLASS_WARLOCK && _spec != SPEC_NONE) ||
                     (_class == CLASS_MONK && _spec == SPEC_MONK_WINDWALKER) ||
                     (_class == CLASS_DRUID && (_spec == SPEC_DRUID_BALANCE || _spec == SPEC_DRUID_FERAL))))
                        canRoll = true;
            }
        }

        if (!canRoll)
            return EQUIP_ERR_CLIENT_LOCKED_OUT;
    }

    return EQUIP_ERR_OK;
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 item, bool update, int32 randomPropertyId, AllowedLooterSet const& allowedLooters)
{
    uint32 count = 0;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end(); ++itr)
        count += itr->count;

    Item* pItem = Item::CreateItem(item, count, this);
    if (pItem)
    {
        ItemAddedQuestCheck(item, count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, count);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, item, 1);
        if (randomPropertyId)
            pItem->SetItemRandomProperties(randomPropertyId);
        pItem = StoreItem(dest, pItem, update);

        pItem->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());

        if (allowedLooters.size() > 1 && pItem->GetTemplate()->GetMaxStackSize() == 1 && pItem->IsSoulBound())
        {
            pItem->SetSoulboundTradeable(allowedLooters);

            // save data
            std::ostringstream ss;
            AllowedLooterSet::const_iterator itr = allowedLooters.begin();
            ss << *itr;
            for (++itr; itr != allowedLooters.end(); ++itr)
                ss << ' ' << *itr;

            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ITEM_BOP_TRADE);
            stmt->setUInt32(0, pItem->GetGUIDLow());
            stmt->setString(1, ss.str());
            CharacterDatabase.Execute(stmt);
        }

        sScriptMgr->OnPlayerEquipChanged(this, pItem->GetEntry());
        SetSaveTimer(1);

        uint8 bag = pItem->GetBagSlot();
        ItemTemplate const* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if ((proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE || proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_PICKUP) && proto->Spells[i].SpellId > 0) // On obtain trigger
                if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                    if (!HasAura(proto->Spells[i].SpellId))
                        CastSpell(this, proto->Spells[i].SpellId, true, pItem);
    }
    return pItem;
}

void Player::StoreNewItem(Item* item)
{
    uint32 entry = item->GetEntry();
    uint32 count = item->GetCount();
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, entry, count);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_OWN_ITEM, entry, 1);
    if (uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(entry))
        item->SetItemRandomProperties(randomPropertyId);

    item->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());

    ItemPosCountVec dest;
    uint8 err = CanStoreItem(NULL_BAG, NULL_SLOT, dest, item);
    if (err == EQUIP_ERR_OK)
    {
        Item* storedItem = StoreItem(dest, item, true);
        SendNewItem(storedItem, count, true, false);
        ItemAddedQuestCheck(entry, count);
        sScriptMgr->OnItemPickup(this, storedItem, ItemPickupSourceType::ItemLoot, 0);
    }
    else
    {
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        LostItemsMailDraft draft{};
        item->SaveToDB(trans);
        draft.AddItem(item);
        draft.SendMailTo(trans, this);
        CharacterDatabase.CommitTransaction(trans);
    }
}

Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
{
    if (!pItem)
        return NULL;

    Item* lastItem = pItem;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end();)
    {
        uint16 pos = itr->pos;
        uint32 count = itr->count;

        ++itr;

        if (itr == dest.end())
        {
            lastItem = _StoreItem(pos, pItem, count, false, update);
            break;
        }

        lastItem = _StoreItem(pos, pItem, count, true, update);
    }
    return lastItem;
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::_StoreItem(uint16 pos, Item* pItem, uint32 count, bool clone, bool update)
{
    if (!pItem)
        return NULL;

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    TC_LOG_DEBUG("entities.player.items", "STORAGE: StoreItem bag = %u, slot = %u, item = %u, count = %u, guid = %u", bag, slot, pItem->GetEntry(), count, pItem->GetGUIDLow());

    Item* pItem2 = GetItemByPos(bag, slot);

    if (!pItem2)
    {
        if (clone)
            pItem = pItem->CloneItem(count, this);
        else
            pItem->SetCount(count);

        if (!pItem)
            return NULL;

        if (pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)) ||
            pItem->GetTemplate()->FlagsCu & ITEM_FLAGS_CU_EQUIP_DISABLE)
            pItem->SetBinding(true);

        Bag* pBag = (bag == INVENTORY_SLOT_BAG_0) ? NULL : GetBagByPos(bag);
        if (!pBag)
        {
            m_items[slot] = pItem;
            SetUInt64Value(PLAYER_FIELD_INV_SLOTS + (slot * 2), pItem->GetGUID());
            pItem->SetUInt64Value(ITEM_FIELD_CONTAINED_IN, GetGUID());
            pItem->SetUInt64Value(ITEM_FIELD_OWNER, GetGUID());

            pItem->SetSlot(slot);
            pItem->SetContainer(NULL);
        }
        else
            pBag->StoreItem(slot, pItem, update);

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        // For Item Upgrade
        if (!pItem->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_UPGRADE))
            if (uint32 upgradeId = GetUpgradeId(pItem->GetEntry()))
                pItem->SetDynamicModifier(ITEM_MODIFIER_INDEX_UPGRADE, upgradeId, this);

        pItem->SetState(ITEM_CHANGED, this);
        if (pBag)
            pBag->SetState(ITEM_CHANGED, this);

        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        return pItem;
    }
    else
    {
        if (pItem2->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP ||
            pItem2->GetTemplate()->Bonding == BIND_QUEST_ITEM ||
            (pItem2->GetTemplate()->Bonding == BIND_WHEN_EQUIPED && IsBagPos(pos)) ||
            pItem->GetTemplate()->FlagsCu & ITEM_FLAGS_CU_EQUIP_DISABLE)
            pItem2->SetBinding(true);

        pItem2->SetCount(pItem2->GetCount() + count);
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        if (!clone)
        {
            // delete item (it not in any slot currently)
            if (IsInWorld() && update)
            {
                pItem->RemoveFromWorld();
                pItem->DestroyForPlayer(this);
            }

            RemoveEnchantmentDurations(pItem);
            RemoveItemDurations(pItem);

            pItem->SetOwnerGUID(GetGUID());                 // prevent error at next SetState in case trade/mail/buy from vendor
            pItem->SetNotRefundable(this);
            pItem->ClearSoulboundTradeable(this);
            pItem->SetState(ITEM_REMOVED, this);
        }

        AddEnchantmentDurations(pItem2);

        pItem2->SetState(ITEM_CHANGED, this);

        return pItem2;
    }
}

Item* Player::EquipNewItem(uint16 pos, uint32 item, bool update)
{
    if (Item* pItem = Item::CreateItem(item, 1, this))
    {
        ItemAddedQuestCheck(item, 1);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, 1);
        return EquipItem(pos, pItem, update);
    }

    return NULL;
}

Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
{
    AddEnchantmentDurations(pItem);
    AddItemDurations(pItem);

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    Item* pItem2 = GetItemByPos(bag, slot);

    if (!pItem2)
    {
        VisualizeItem(slot, pItem);

        for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE))
            itr->RecalculateAmount();

        if (IsAlive())
        {
            ItemTemplate const* pProto = pItem->GetTemplate();

            // item set bonuses applied only at equip and removed at unequip, and still active for broken items
            if (pProto && pProto->ItemSet)
                AddItemsSetItem(this, pItem);

            pItem->OverrideItemLevel(GetItemLevel(pItem));
            _ApplyItemMods(pItem, slot, true);

            if (pProto && IsInCombat() && (pProto->Class == ITEM_CLASS_WEAPON || pProto->InventoryType == INVTYPE_RELIC) && m_weaponChangeTimer == 0)
            {
                uint32 cooldownSpell = getClass() == CLASS_ROGUE ? 6123 : 6119;
                SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(cooldownSpell);

                if (!spellProto)
                    TC_LOG_ERROR("entities.player", "Weapon switch cooldown spell %u couldn't be found in Spell.dbc", cooldownSpell);
                else
                {
                    m_weaponChangeTimer = spellProto->StartRecoveryTime;

                    GetGlobalCooldownMgr().AddGlobalCooldown(spellProto, m_weaponChangeTimer);
                    ObjectGuid guid = GetGUID();

                    WorldPacket data(SMSG_SPELL_COOLDOWN, 9 + 3 + 8);
                    data.WriteBit(guid[0]);
                    data.WriteBit(guid[6]);
                    data.WriteBit(1); // Missing flags
                    data.WriteBit(guid[7]);
                    data.WriteBit(guid[3]);
                    data.WriteBit(guid[1]);
                    data.WriteBit(guid[5]);
                    size_t bitpos = data.bitwpos();
                    data.WriteBits(1, 21);
                    data.WriteBit(guid[2]);
                    data.WriteBit(guid[4]);

                    data << uint32(cooldownSpell);
                    data << uint32(0);
                    data.WriteByteSeq(guid[5]);
                    data.WriteByteSeq(guid[3]);
                    data.WriteByteSeq(guid[7]);
                    data.WriteByteSeq(guid[4]);
                    data.WriteByteSeq(guid[1]);
                    data.WriteByteSeq(guid[0]);
                    data.WriteByteSeq(guid[2]);
                    data.WriteByteSeq(guid[6]);
                    GetSession()->SendPacket(&data);
                }
            }
        }

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        ApplyEquipCooldown(pItem);

         // update expertise and armor penetration - passive auras may need it

        if (slot == EQUIPMENT_SLOT_MAINHAND)
            UpdateExpertise(BASE_ATTACK);

        else if (slot == EQUIPMENT_SLOT_OFFHAND)
            UpdateExpertise(OFF_ATTACK);

        switch (slot)
        {
            case EQUIPMENT_SLOT_MAINHAND:
            case EQUIPMENT_SLOT_OFFHAND:
                RecalculateRating(CR_ARMOR_PENETRATION);
            default:
                break;
        }
    }
    else
    {
        pItem2->SetCount(pItem2->GetCount() + pItem->GetCount());
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        // delete item (it not in any slot currently)
        //pItem->DeleteFromDB();
        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetOwnerGUID(GetGUID());                     // prevent error at next SetState in case trade/mail/buy from vendor
        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        pItem->SetState(ITEM_REMOVED, this);
        pItem2->SetState(ITEM_CHANGED, this);

        ApplyEquipCooldown(pItem2);

        return pItem2;
    }

    // only for full equip instead adding to stack
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);

    sLFGMgr->InitializeLockedDungeons(this);

    return pItem;
}

uint32 Player::GetItemLevel(Item* item) const
{
    uint32 itemItemLevel = item->GetBaseItemLevel();
    uint32 finalItemLevel = itemItemLevel;

    if ((GetMap()->IsBattlegroundOrArena() && !item->IsPvPItem()) || (GetMap()->IsDungeon() && GetMap()->IsChallengeDungeon()))
    {
        uint32 minItemLevel = GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL); // Not used currently
        uint32 maxItemLevel = GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL);

        if (minItemLevel && minItemLevel > itemItemLevel)
            finalItemLevel = minItemLevel;
        if (maxItemLevel && maxItemLevel < itemItemLevel)
            finalItemLevel = maxItemLevel;
    }
    return finalItemLevel;
}

void Player::UpdateItemLevel(Item* item)
{
    uint32 itemItemLevel = item->GetBaseItemLevel();
    uint32 finalItemLevel = itemItemLevel;

    if ((GetMap()->IsBattlegroundOrArena() && !item->IsPvPItem()) || (GetMap()->IsDungeon() && GetMap()->IsChallengeDungeon()))
    {
        uint32 minItemLevel = GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL); // Not used currently
        uint32 maxItemLevel = GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL);

        if (minItemLevel && minItemLevel > itemItemLevel)
            finalItemLevel = minItemLevel;
        if (maxItemLevel && maxItemLevel < itemItemLevel)
            finalItemLevel = maxItemLevel;
    }
    item->OverrideItemLevel(finalItemLevel);
}

void Player::QuickEquipItem(uint16 pos, Item* pItem)
{
    if (pItem)
    {
        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        uint8 slot = pos & 255;
        VisualizeItem(slot, pItem);

        if (IsInWorld())
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
    }
}

void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
{
    if (pItem)
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2), pItem->GetVisibleEntry());
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + 1 + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + 1 + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
    }
    else
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (slot * 2), 0);
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + 1 + (slot * 2), 0);
    }
}

void Player::VisualizeItem(uint8 slot, Item* pItem)
{
    if (!pItem)
        return;

    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
    if (pItem->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || pItem->GetTemplate()->Bonding == BIND_WHEN_PICKED_UP || pItem->GetTemplate()->Bonding == BIND_QUEST_ITEM)
        pItem->SetBinding(true);

    TC_LOG_DEBUG("entities.player.items", "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());

    m_items[slot] = pItem;
    SetUInt64Value(PLAYER_FIELD_INV_SLOTS + (slot * 2), pItem->GetGUID());
    pItem->SetUInt64Value(ITEM_FIELD_CONTAINED_IN, GetGUID());
    pItem->SetUInt64Value(ITEM_FIELD_OWNER, GetGUID());
    pItem->SetSlot(slot);
    pItem->SetContainer(NULL);

    if (slot < EQUIPMENT_SLOT_END)
        SetVisibleItemSlot(slot, pItem);

    pItem->SetState(ITEM_CHANGED, this);
}

Item* Player::BankItem(ItemPosCountVec const& dest, Item* pItem, bool update)
{
    return StoreItem(dest, pItem, update);
}

void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
{
    // note: removeitem does not actually change the item
    // it only takes the item out of storage temporarily
    // note2: if removeitem is to be used for delinking
    // the item must be removed from the player's updatequeue

    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        TC_LOG_DEBUG("entities.player.items", "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            m_items[slot] = NULL;

            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();
                // item set bonuses applied only at equip and removed at unequip, and still active for broken items

                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);
                pItem->OverrideItemLevel(0);

                // remove item dependent auras and casts (only weapon and armor slots)
                if (slot < EQUIPMENT_SLOT_END)
                {
                    RemoveItemDependentAurasAndCasts(pItem);

                    // remove held enchantments, update expertise
                    if (slot == EQUIPMENT_SLOT_MAINHAND)
                    {
                        if (pItem->GetItemSuffixFactor())
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
                        }
                        else
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
                        }

                        UpdateExpertise(BASE_ATTACK);
                    }
                    else if (slot == EQUIPMENT_SLOT_OFFHAND)
                        UpdateExpertise(OFF_ATTACK);
                    // update armor penetration - passive auras may need it
                    switch (slot)
                    {
                        case EQUIPMENT_SLOT_MAINHAND:
                        case EQUIPMENT_SLOT_OFFHAND:
                            RecalculateRating(CR_ARMOR_PENETRATION);
                        default:
                            break;
                    }

                    for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE))
                        itr->RecalculateAmount();

                    if (slot < EQUIPMENT_SLOT_END)
                        sLFGMgr->InitializeLockedDungeons(this);
                }
            }

            SetUInt64Value(PLAYER_FIELD_INV_SLOTS + (slot * 2), 0);

            if (slot < EQUIPMENT_SLOT_END)
                SetVisibleItemSlot(slot, NULL);
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        pItem->SetUInt64Value(ITEM_FIELD_CONTAINED_IN, 0);
        // pItem->SetUInt64Value(ITEM_FIELD_OWNER, 0); not clear owner at remove (it will be set at store). This used in mail and auction code
        pItem->SetSlot(NULL_SLOT);
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
    }
}

// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
{
    if (Item* it = GetItemByPos(bag, slot))
    {
        ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
        RemoveItem(bag, slot, update);
        it->SetNotRefundable(this, false);
        it->RemoveFromUpdateQueueOf(this);
        if (it->IsInWorld())
        {
            it->RemoveFromWorld();
            it->DestroyForPlayer(this);
        }
    }
}

// Common operation need to add item from inventory without delete in trade, guild bank, mail....
void Player::MoveItemToInventory(ItemPosCountVec const& dest, Item* pItem, bool update, bool in_characterInventoryDB)
{
    // update quest counters
    ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());

    // store item
    Item* pLastItem = StoreItem(dest, pItem, update);

    // only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
    if (pLastItem == pItem)
    {
        // update owner for last item (this can be original item with wrong owner
        if (pLastItem->GetOwnerGUID() != GetGUID())
            pLastItem->SetOwnerGUID(GetGUID());

        // if this original item then it need create record in inventory
        // in case trade we already have item in other player inventory
        pLastItem->SetState(in_characterInventoryDB ? ITEM_CHANGED : ITEM_NEW, this);
    }
}

void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
{
    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        TC_LOG_DEBUG("entities.player.items", "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
        // Also remove all contained items if the item is a bag.
        // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
        if (pItem->IsNotEmptyBag())
            for (uint8 i = 0; i < MAX_BAG_SIZE; ++i)
                DestroyItem(slot, i, update);

        if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_WRAPPED))
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GIFT);

            stmt->setUInt32(0, pItem->GetGUIDLow());

            CharacterDatabase.Execute(stmt);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);

        const ItemTemplate* proto = pItem->GetTemplate();
        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
            if (proto->Spells[i].SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && proto->Spells[i].SpellId > 0) // On obtain trigger
                RemoveAurasDueToSpell(proto->Spells[i].SpellId);

        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            SetUInt64Value(PLAYER_FIELD_INV_SLOTS + (slot * 2), 0);

            // equipment and equipped bags can have applied bonuses
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();

                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                if (pProto && pProto->ItemSet)
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);
                pItem->OverrideItemLevel(0);
            }

            if (slot < EQUIPMENT_SLOT_END)
            {
                // remove item dependent auras and casts (only weapon and armor slots)
                RemoveItemDependentAurasAndCasts(pItem);

                // update expertise and armor penetration - passive auras may need it
                switch (slot)
                {
                    case EQUIPMENT_SLOT_MAINHAND:
                    case EQUIPMENT_SLOT_OFFHAND:
                        RecalculateRating(CR_ARMOR_PENETRATION);
                    default:
                        break;
                }

                if (slot == EQUIPMENT_SLOT_MAINHAND)
                    UpdateExpertise(BASE_ATTACK);
                else if (slot == EQUIPMENT_SLOT_OFFHAND)
                    UpdateExpertise(OFF_ATTACK);

                // equipment visual show
                SetVisibleItemSlot(slot, NULL);
            }

            m_items[slot] = NULL; // TODO: Whe the fuck this is here?

            if (slot < EQUIPMENT_SLOT_END)
                for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE))
                    itr->RecalculateAmount();
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        // Delete rolled money / loot from db.
        // MUST be done before RemoveFromWorld() or GetTemplate() fails
        if (ItemTemplate const* pTmp = pItem->GetTemplate())
            if (pTmp->Flags & ITEM_PROTO_FLAG_OPENABLE)
                pItem->ItemContainerDeleteLootMoneyAndLootItemsFromDB();

        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        //pItem->SetOwnerGUID(0);
        pItem->SetUInt64Value(ITEM_FIELD_CONTAINED_IN, 0);
        pItem->SetSlot(NULL_SLOT);
        pItem->SetState(ITEM_REMOVED, this);
    }
}

void Player::DestroyItemCount(uint32 itemEntry, uint32 count, bool update, bool unequip_check)
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: DestroyItemCount item = %u, count = %u", itemEntry, count);
    uint32 remcount = 0;

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (item->GetEntry() == itemEntry && !item->IsInTrade())
            {
                if (item->GetCount() + remcount <= count)
                {
                    // all items in inventory can unequipped
                    remcount += item->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
                    item->SetCount(item->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        item->SendUpdateToPlayer(this);
                    item->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* bag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < bag->GetBagSize(); j++)
            {
                if (Item* item = bag->GetItemByPos(j))
                {
                    if (item->GetEntry() == itemEntry && !item->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (item->GetCount() + remcount <= count)
                        {
                            remcount += item->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
                            item->SetCount(item->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                item->SendUpdateToPlayer(this);
                            item->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (item && item->GetEntry() == itemEntry && !item->IsInTrade())
            {
                if (item->GetCount() + remcount <= count)
                {
                    if (!unequip_check || CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false) == EQUIP_ERR_OK)
                    {
                        remcount += item->GetCount();
                        DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                        if (remcount >= count)
                            return;
                    }
                }
                else
                {
                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
                    item->SetCount(item->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        item->SendUpdateToPlayer(this);
                    item->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank
    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (item->GetEntry() == itemEntry && !item->IsInTrade())
            {
                if (item->GetCount() + remcount <= count)
                {
                    remcount += item->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
                    item->SetCount(item->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        item->SendUpdateToPlayer(this);
                    item->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank bags
    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        if (Bag* bag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < bag->GetBagSize(); j++)
            {
                if (Item* item = bag->GetItemByPos(j))
                {
                    if (item->GetEntry() == itemEntry && !item->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (item->GetCount() + remcount <= count)
                        {
                            remcount += item->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(item->GetEntry(), count - remcount);
                            item->SetCount(item->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                item->SendUpdateToPlayer(this);
                            item->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }
}

void Player::DestroyZoneLimitedItem(bool update, uint32 new_zone)
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: DestroyZoneLimitedItem in map %u and area %u", GetMapId(), new_zone);

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

void Player::DestroyConjuredItems(bool update)
{
    // used when entering arena
    // destroys all conjured items
    TC_LOG_DEBUG("entities.player.items", "STORAGE: DestroyConjuredItems");

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsConjuredConsumable())
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

Item* Player::GetItemByEntry(uint32 entry) const
{
    // in inventory
    for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEntry() == entry)
                        return pItem;

    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    return NULL;
}

void Player::DestroyItemCount(Item* pItem, uint32 &count, bool update)
{
    if (!pItem)
        return;

    TC_LOG_DEBUG("entities.player.items", "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(), pItem->GetEntry(), count);

    if (pItem->GetCount() <= count)
    {
        count -= pItem->GetCount();

        DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), update);
    }
    else
    {
        ItemRemovedQuestCheck(pItem->GetEntry(), count);
        pItem->SetCount(pItem->GetCount() - count);
        count = 0;
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
        pItem->SetState(ITEM_CHANGED, this);
    }
}

void Player::SplitItem(uint16 src, uint16 dst, uint32 count)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    if (pSrcItem->m_lootGenerated)                           // prevent split looting item (item
    {
        //best error message found for attempting to split while looting
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split all items (can be only at cheating)
    if (pSrcItem->GetCount() == count)
    {
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem, NULL);
        return;
    }

    // not let split more existed items (can be only at cheating)
    if (pSrcItem->GetCount() < count)
    {
        SendEquipError(EQUIP_ERR_TOO_FEW_TO_SPLIT, pSrcItem, NULL);
        return;
    }

    //! If trading
    if (TradeData* tradeData = GetTradeData())
    {
        //! If current item is in trade window (only possible with packet spoofing - silent return)
        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
            return;
    }

    TC_LOG_DEBUG("entities.player.items", "STORAGE: SplitItem bag = %u, slot = %u, item = %u, count = %u", dstbag, dstslot, pSrcItem->GetEntry(), count);
    Item* pNewItem = pSrcItem->CloneItem(count, this);
    if (!pNewItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem, NULL);
        return;
    }

    bool needLog = GetSession()->HasFlag(ACC_FLAG_ITEM_LOG);
    bool logFromBank = needLog && IsBankPos(src);
    bool logToBank = needLog && !IsBankPos(src);

    if (IsInventoryPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (logFromBank)
            logs::ItemLog(this, pNewItem, pNewItem->GetCount(), "Take from bank");
        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        StoreItem(dest, pNewItem, true);
    }
    else if (IsBankPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (logToBank)
            logs::ItemLog(this, pNewItem, pNewItem->GetCount(), "Put to bank");
        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        BankItem(dest, pNewItem, true);
    }
    else if (IsEquipmentPos(dst))
    {
        // change item amount before check (for unique max count check), provide space for splitted items
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        uint16 dest;
        InventoryResult msg = CanEquipItem(dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem, NULL);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        EquipItem(dest, pNewItem, true);
        AutoUnequipOffhandIfNeed();
    }
}

void Player::SwapItem(uint16 src, uint16 dst)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    Item* pDstItem = GetItemByPos(dstbag, dstslot);

    if (!pSrcItem)
        return;

    TC_LOG_DEBUG("entities.player.items", "STORAGE: SwapItem bag = %u, slot = %u, item = %u", dstbag, dstslot, pSrcItem->GetEntry());

    if (!IsAlive())
    {
        SendEquipError(EQUIP_ERR_PLAYER_DEAD, pSrcItem, pDstItem);
        return;
    }

    // SRC checks

    if (pSrcItem->m_lootGenerated)                           // prevent swap looting item
    {
        //best error message found for attempting to swap while looting
        SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pSrcItem, NULL);
        return;
    }

    // check unequip potability for equipped items and bank bags
    if (IsEquipmentPos(src) || IsBagPos(src))
    {
        // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
        InventoryResult msg = CanUnequipItem(src, !IsBagPos(src) || IsBagPos(dst) || (pDstItem && pDstItem->ToBag() && pDstItem->ToBag()->IsEmpty()));
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, pSrcItem, pDstItem);
            return;
        }
    }

    // prevent put equipped/bank bag in self
    if (IsBagPos(src) && srcslot == dstbag)
    {
        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
        return;
    }

    // prevent equipping bag in the same slot from its inside
    if (IsBagPos(dst) && srcbag == dstslot)
    {
        SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
        return;
    }

    // DST checks

    if (pDstItem)
    {
        if (pDstItem->m_lootGenerated)                       // prevent swap looting item
        {
            //best error message found for attempting to swap while looting
            SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pDstItem, NULL);
            return;
        }

        // check unequip potability for equipped items and bank bags
        if (IsEquipmentPos(dst) || IsBagPos(dst))
        {
            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
            InventoryResult msg = CanUnequipItem(dst, !IsBagPos(dst) || IsBagPos(src) || (pSrcItem->ToBag() && pSrcItem->ToBag()->IsEmpty()));
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, pDstItem);
                return;
            }
        }
    }

    bool needLog = GetSession()->HasFlag(ACC_FLAG_ITEM_LOG);
    bool logFromBank = needLog && IsBankPos(src);
    bool logToBank = needLog && !IsBankPos(src);

    // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
    // or swap empty bag with another empty or not empty bag (with items exchange)

    // Move case
    if (!pDstItem)
    {
        if (IsInventoryPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }

            if (logFromBank)
                logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Take from bank");
            RemoveItem(srcbag, srcslot, true);
            StoreItem(dest, pSrcItem, true);
            if (IsBankPos(src))
                ItemAddedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsBankPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }

            if (logToBank)
                logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Put to bank");
            RemoveItem(srcbag, srcslot, true);
            BankItem(dest, pSrcItem, true);
            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsEquipmentPos(dst))
        {
            uint16 dest;
            InventoryResult msg = CanEquipItem(dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, NULL);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            EquipItem(dest, pSrcItem, true);
            AutoUnequipOffhandIfNeed();
        }

        return;
    }

    // attempt merge to / fill target item
    if (!pSrcItem->IsBag() && !pDstItem->IsBag())
    {
        InventoryResult msg;
        ItemPosCountVec sDest;
        uint16 eDest = 0;
        if (IsInventoryPos(dst))
            msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsBankPos(dst))
            msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsEquipmentPos(dst))
            msg = CanEquipItem(dstslot, eDest, pSrcItem, false);
        else
            return;

        // can be merge/fill
        if (msg == EQUIP_ERR_OK)
        {
            if (pSrcItem->GetCount() + pDstItem->GetCount() <= pSrcItem->GetTemplate()->GetMaxStackSize())
            {
                RemoveItem(srcbag, srcslot, true);

                if (IsInventoryPos(dst))
                {
                    if (logFromBank)
                        logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Take from bank");
                    StoreItem(sDest, pSrcItem, true);
                }
                else if (IsBankPos(dst))
                {
                    if (logToBank)
                        logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Put to bank");
                    BankItem(sDest, pSrcItem, true);
                }
                else if (IsEquipmentPos(dst))
                {
                    EquipItem(eDest, pSrcItem, true);
                    AutoUnequipOffhandIfNeed();
                }
            }
            else
            {
                pSrcItem->SetCount(pSrcItem->GetCount() + pDstItem->GetCount() - pSrcItem->GetTemplate()->GetMaxStackSize());
                pDstItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
                pSrcItem->SetState(ITEM_CHANGED, this);
                pDstItem->SetState(ITEM_CHANGED, this);
                if (IsInWorld())
                {
                    pSrcItem->SendUpdateToPlayer(this);
                    pDstItem->SendUpdateToPlayer(this);
                }
            }
            SendRefundInfo(pDstItem);
            return;
        }
    }

    // impossible merge/fill, do real swap
    InventoryResult msg = EQUIP_ERR_OK;

    // check src->dest move possibility
    ItemPosCountVec sDest;
    uint16 eDest = 0;
    if (IsInventoryPos(dst))
        msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        msg = CanEquipItem(dstslot, eDest, pSrcItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pSrcItem, pDstItem);
        return;
    }

    // check dest->src move possibility
    ItemPosCountVec sDest2;
    uint16 eDest2 = 0;
    if (IsInventoryPos(src))
        msg = CanStoreItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsBankPos(src))
        msg = CanBankItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsEquipmentPos(src))
    {
        msg = CanEquipItem(srcslot, eDest2, pDstItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest2, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pDstItem, pSrcItem);
        return;
    }

    // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
    if (Bag* srcBag = pSrcItem->ToBag())
    {
        if (Bag* dstBag = pDstItem->ToBag())
        {
            Bag* emptyBag = NULL;
            Bag* fullBag = NULL;
            if (srcBag->IsEmpty() && !IsBagPos(src))
            {
                emptyBag = srcBag;
                fullBag  = dstBag;
            }
            else if (dstBag->IsEmpty() && !IsBagPos(dst))
            {
                emptyBag = dstBag;
                fullBag  = srcBag;
            }

            // bag swap (with items exchange) case
            if (emptyBag && fullBag)
            {
                ItemTemplate const* emptyProto = emptyBag->GetTemplate();

                uint32 count = 0;

                for (uint32 i=0; i < fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    ItemTemplate const* bagItemProto = bagItem->GetTemplate();
                    if (!bagItemProto || !ItemCanGoIntoBag(bagItemProto, emptyProto))
                    {
                        // one from items not go to empty target bag
                        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
                        return;
                    }

                    ++count;
                }

                if (count > emptyBag->GetBagSize())
                {
                    // too small targeted bag
                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                    return;
                }

                // Items swap
                count = 0;                                      // will pos in new bag
                for (uint32 i = 0; i< fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    fullBag->RemoveItem(i, true);
                    emptyBag->StoreItem(count, bagItem, true);
                    bagItem->SetState(ITEM_CHANGED, this);

                    ++count;
                }
            }
        }
    }

    // now do moves, remove...
    RemoveItem(dstbag, dstslot, false);
    RemoveItem(srcbag, srcslot, false);

    // add to dest
    if (IsInventoryPos(dst))
    {
        if (logFromBank)
            logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Take from bank");
        StoreItem(sDest, pSrcItem, true);
    }
    else if (IsBankPos(dst))
    {
        if (logToBank)
            logs::ItemLog(this, pSrcItem, pSrcItem->GetCount(), "Put to bank");
        BankItem(sDest, pSrcItem, true);
    }
    else if (IsEquipmentPos(dst))
        EquipItem(eDest, pSrcItem, true);

    // add to src
    if (IsInventoryPos(src))
    {
        if (logFromBank)
            logs::ItemLog(this, pDstItem, pSrcItem->GetCount(), "Take from bank");
        StoreItem(sDest2, pDstItem, true);
    }
    else if (IsBankPos(src))
    {
        if (logToBank)
            logs::ItemLog(this, pDstItem, pSrcItem->GetCount(), "Put to bank");
        BankItem(sDest2, pDstItem, true);
    }
    else if (IsEquipmentPos(src))
        EquipItem(eDest2, pDstItem, true);

    // if player is moving bags and is looting an item inside this bag
    // release the loot
    if (GetLootGUID())
    {
        bool released = false;
        if (IsBagPos(src))
        {
            Bag* bag = pSrcItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // so we don't need to look at dstBag
                        break;
                    }
                }
            }
        }

        if (!released && IsBagPos(dst) && pDstItem)
        {
            Bag* bag = pDstItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // not realy needed here
                        break;
                    }
                }
            }
        }
    }

    AutoUnequipOffhandIfNeed();
}

void Player::AddItemToBuyBackSlot(Item* pItem)
{
    if (pItem)
    {
        uint32 slot = m_currentBuybackSlot;
        // if current back slot non-empty search oldest or free
        if (m_items[slot])
        {
            uint32 oldest_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP);
            uint32 oldest_slot = BUYBACK_SLOT_START;

            for (uint32 i = BUYBACK_SLOT_START+1; i < BUYBACK_SLOT_END; ++i)
            {
                // found empty
                if (!m_items[i])
                {
                    slot = i;
                    break;
                }

                uint32 i_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + i - BUYBACK_SLOT_START);

                if (oldest_time > i_time)
                {
                    oldest_time = i_time;
                    oldest_slot = i;
                }
            }

            // find oldest
            slot = oldest_slot;
        }

        RemoveItemFromBuyBackSlot(slot, true);
        TC_LOG_DEBUG("entities.player.items", "STORAGE: AddItemToBuyBackSlot item = %u, slot = %u", pItem->GetEntry(), slot);

        m_items[slot] = pItem;
        time_t base = time(NULL);
        uint32 etime = uint32(base - m_logintime + (30 * 3600));
        uint32 eslot = slot - BUYBACK_SLOT_START;

        SetUInt64Value(PLAYER_FIELD_VENDORBUYBACK_SLOTS + (eslot * 2), pItem->GetGUID());
        if (ItemTemplate const* proto = pItem->GetTemplate())
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, proto->SellPrice * pItem->GetCount());
        else
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, (uint32)etime);

        // move to next (for non filled list is move most optimized choice)
        if (m_currentBuybackSlot < BUYBACK_SLOT_END - 1)
            ++m_currentBuybackSlot;
    }
}

Item* Player::GetItemFromBuyBackSlot(uint32 slot)
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: GetItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
        return m_items[slot];
    return NULL;
}

void Player::RemoveItemFromBuyBackSlot(uint32 slot, bool del)
{
    TC_LOG_DEBUG("entities.player.items", "STORAGE: RemoveItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
    {
        Item* pItem = m_items[slot];
        if (pItem)
        {
            pItem->RemoveFromWorld();
            if (del)
                pItem->SetState(ITEM_REMOVED, this);
        }

        m_items[slot] = NULL;

        uint32 eslot = slot - BUYBACK_SLOT_START;
        SetUInt64Value(PLAYER_FIELD_VENDORBUYBACK_SLOTS + (eslot * 2), 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, 0);

        // if current backslot is filled set to now free slot
        if (m_items[m_currentBuybackSlot])
            m_currentBuybackSlot = slot;
    }
}

void Player::SendEquipError(InventoryResult msg, Item* pItem, Item* pItem2, uint32 itemid)
{
    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_INVENTORY_CHANGE_FAILURE (%u)", msg);

    ObjectGuid pItemGuid = pItem ? pItem->GetGUID() : 0;
    ObjectGuid pItemGuid2 = pItem2 ? pItem2->GetGUID() : 0;

    WorldPacket data(SMSG_INVENTORY_CHANGE_FAILURE, (msg == EQUIP_ERR_CANT_EQUIP_LEVEL_I ? 22 : 18));

    if (msg != EQUIP_ERR_OK)
    {
        data.WriteBit(pItemGuid2[4]);
        data.WriteBit(pItemGuid[3]);
        data.WriteBit(pItemGuid2[6]);
        data.WriteBit(pItemGuid2[2]);
        data.WriteBit(pItemGuid[4]);
        data.WriteBit(pItemGuid2[5]);
        data.WriteBit(pItemGuid[1]);
        data.WriteBit(pItemGuid[6]);
        data.WriteBit(pItemGuid2[0]);
        data.WriteBit(pItemGuid2[3]);
        data.WriteBit(pItemGuid2[1]);
        data.WriteBit(pItemGuid[2]);
        data.WriteBit(pItemGuid[0]);
        data.WriteBit(pItemGuid[5]);
        data.WriteBit(pItemGuid[7]);
        data.WriteBit(pItemGuid2[7]);

        data.WriteByteSeq(pItemGuid2[0]);
        data << uint8(0);                       // bag type subclass, used with EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM and EQUIP_ERR_ITEM_DOESNT_GO_INTO_BAG2
        data.WriteByteSeq(pItemGuid2[6]);
        data.WriteByteSeq(pItemGuid[4]);
        data.WriteByteSeq(pItemGuid[0]);
        data.WriteByteSeq(pItemGuid[7]);
        data.WriteByteSeq(pItemGuid[3]);
        data.WriteByteSeq(pItemGuid2[1]);
        data.WriteByteSeq(pItemGuid2[5]);
        data.WriteByteSeq(pItemGuid[5]);
        data.WriteByteSeq(pItemGuid2[7]);
        data.WriteByteSeq(pItemGuid2[2]);
        data.WriteByteSeq(pItemGuid[1]);
        data.WriteByteSeq(pItemGuid[6]);
        data.WriteByteSeq(pItemGuid[2]);
        data.WriteByteSeq(pItemGuid2[3]);
        data.WriteByteSeq(pItemGuid2[4]);
        data << uint8(msg);

        if (msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS
            || msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED_IS
            || msg == EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS)
        {
            ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
            data << uint32(proto ? proto->ItemLimitCategory : 0);
        }

        if (msg == EQUIP_ERR_NO_OUTPUT)         // no idea about this one...
            data << uint32(0);                  // slot

        if (msg == EQUIP_ERR_CANT_EQUIP_LEVEL_I || msg == EQUIP_ERR_PURCHASE_LEVEL_TOO_LOW)
        {
            ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid);
            data << uint32(proto ? proto->RequiredLevel : 0);
        }

        if (msg == EQUIP_ERR_NO_OUTPUT)
        {
            data.WriteBits(0, 8);               // container
            data.WriteBits(0, 8);               // item guid
        }
    }

    GetSession()->SendPacket(&data);
}

void Player::SendBuyError(BuyResult msg, Creature* creature, uint32 item, uint32 /*param*/)
{
    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_BUY_FAILED");

    ObjectGuid guid = creature ? creature->GetGUID() : 0;

    WorldPacket data(SMSG_BUY_FAILED, 1 + 8 + 1 + 4);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[4]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[7]);

    data << uint8(msg);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[7]);
    data << uint32(item);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[0]);

    GetSession()->SendPacket(&data);
}

void Player::SendSellError(SellResult msg, Creature* creature, uint64 guid)
{
    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_SELL_ITEM");

    ObjectGuid npcGuid = creature ? creature->GetGUID() : 0;
    ObjectGuid itemGuid = guid;

    WorldPacket data(SMSG_SELL_ITEM, 1 + 8 + 1 + 8 + 1);
    data.WriteBit(itemGuid[2]);
    data.WriteBit(npcGuid[4]);
    data.WriteBit(itemGuid[5]);
    data.WriteBit(itemGuid[4]);
    data.WriteBit(npcGuid[3]);
    data.WriteBit(npcGuid[5]);
    data.WriteBit(itemGuid[3]);
    data.WriteBit(npcGuid[6]);
    data.WriteBit(npcGuid[0]);
    data.WriteBit(npcGuid[2]);
    data.WriteBit(itemGuid[1]);
    data.WriteBit(itemGuid[7]);
    data.WriteBit(npcGuid[1]);
    data.WriteBit(itemGuid[0]);
    data.WriteBit(itemGuid[6]);
    data.WriteBit(npcGuid[7]);

    data.WriteByteSeq(itemGuid[4]);
    data.WriteByteSeq(itemGuid[1]);
    data << uint8(msg);
    data.WriteByteSeq(itemGuid[2]);
    data.WriteByteSeq(npcGuid[4]);
    data.WriteByteSeq(npcGuid[0]);
    data.WriteByteSeq(npcGuid[5]);
    data.WriteByteSeq(npcGuid[2]);
    data.WriteByteSeq(itemGuid[0]);
    data.WriteByteSeq(npcGuid[3]);
    data.WriteByteSeq(itemGuid[5]);
    data.WriteByteSeq(itemGuid[6]);
    data.WriteByteSeq(itemGuid[7]);
    data.WriteByteSeq(npcGuid[6]);
    data.WriteByteSeq(npcGuid[1]);
    data.WriteByteSeq(itemGuid[3]);
    data.WriteByteSeq(npcGuid[7]);

    GetSession()->SendPacket(&data);
}

bool Player::IsUseEquipedWeapon(bool mainhand) const
{
    // disarm applied only to mainhand weapon
    return !IsInFeralForm() && (!mainhand || !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED));
}

bool Player::IsTwoHandUsed() const
{
    Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
    return mainItem && mainItem->GetTemplate()->InventoryType == INVTYPE_2HWEAPON && !CanTitanGrip();
}

void Player::TradeCancel(bool sendback)
{
    if (m_trade)
    {
        Player* trader = m_trade->GetTrader();

        // send yellow "Trade canceled" message to both traders
        if (sendback)
            GetSession()->SendCancelTrade();

        trader->GetSession()->SendCancelTrade();

        // cleanup
        delete m_trade;
        m_trade = NULL;
        delete trader->m_trade;
        trader->m_trade = NULL;
    }
}

void Player::UpdateSoulboundTradeItems()
{
    DoForEachItem([](Item* item)
    {
        if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
            item->CheckSoulboundTradeExpire();
        return false;
    });
}

void Player::UpdateItemDuration(uint32 time, bool realtimeonly)
{
    if (m_itemDuration.empty())
        return;

    TC_LOG_DEBUG("entities.player.items", "Player::UpdateItemDuration(%u, %u)", time, realtimeonly);

    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end();)
    {
        Item* item = *itr;
        ++itr;                                              // current element can be erased in UpdateDuration

        if (!realtimeonly || item->GetTemplate()->FlagsCu & ITEM_FLAGS_CU_DURATION_REAL_TIME)
            item->UpdateDuration(this, time);
    }
}

void Player::UpdateEnchantTime(uint32 time)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr=next)
    {
        ASSERT(itr->item);
        next = itr;
        if (!itr->item->GetEnchantmentId(itr->slot))
        {
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration <= time)
        {
            ApplyEnchantment(itr->item, itr->slot, false, false);
            itr->item->ClearEnchantment(itr->slot);
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration > time)
        {
            itr->leftduration -= time;
            ++next;
        }
    }
}

void Player::AddEnchantmentDurations(Item* item)
{
    for (int x = 0; x < MAX_ENCHANTMENT_SLOT; ++x)
    {
        if (x > PRISMATIC_ENCHANTMENT_SLOT && x < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
            continue;

        if (!item->GetEnchantmentId(EnchantmentSlot(x)))
            continue;

        uint32 duration = item->GetEnchantmentDuration(EnchantmentSlot(x));
        if (duration > 0)
            AddEnchantmentDuration(item, EnchantmentSlot(x), duration);
    }
}

void Player::RemoveEnchantmentDurations(Item* item)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end();)
    {
        if (itr->item == item)
        {
            // save duration in item
            item->SetEnchantmentDuration(EnchantmentSlot(itr->slot), itr->leftduration, this);
            itr = m_enchantDuration.erase(itr);
        }
        else
            ++itr;
    }
}

void Player::RemoveArenaEnchantments(EnchantmentSlot slot)
{
    // remove enchantments from equipped items first to clean up the m_enchantDuration list
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr = next)
    {
        next = itr;
        if (itr->slot == slot)
        {
            if (itr->item && itr->item->GetEnchantmentId(slot))
            {
                // Poisons and DK runes are enchants which are allowed on arenas
                if (sSpellMgr->IsArenaAllowedEnchancment(itr->item->GetEnchantmentId(slot)))
                {
                    ++next;
                    continue;
                }
                // remove from stats
                ApplyEnchantment(itr->item, slot, false, false);
                // remove visual
                itr->item->ClearEnchantment(slot);
            }
            // remove from update list
            next = m_enchantDuration.erase(itr);
        }
        else
            ++next;
    }

    // remove enchants from inventory items
    // NOTE: no need to remove these from stats, since these aren't equipped
    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEnchantmentId(slot))
                pItem->ClearEnchantment(slot);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEnchantmentId(slot))
                        pItem->ClearEnchantment(slot);
}

// duration == 0 will remove item enchant
void Player::AddEnchantmentDuration(Item* item, EnchantmentSlot slot, uint32 duration)
{
    if (!item)
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
    {
        if (itr->item == item && itr->slot == slot)
        {
            itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
            m_enchantDuration.erase(itr);
            break;
        }
    }
    if (item && duration > 0)
    {
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), item->GetGUID(), slot, uint32(duration/1000));
        m_enchantDuration.push_back(EnchantDuration(item, slot, duration));
    }
}

void Player::ApplyReforgeEnchantment(Item* item, bool apply, uint32 ilvl)
{
    if (!item)
        return;

    ItemReforgeEntry const* reforge = sItemReforgeStore.LookupEntry(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_REFORGE));
    if (!reforge)
        return;

    float removeValue = std::floor(item->GetReforgableStat(ItemModType(reforge->SourceStat)) * reforge->SourceMultiplier);
    float addValue = std::floor(removeValue * reforge->FinalMultiplier);

    switch (reforge->SourceStat)
    {
        case ITEM_MOD_MANA:
            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, -removeValue, apply);
            break;
        case ITEM_MOD_HEALTH:
            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, -removeValue, apply);
            break;
        case ITEM_MOD_AGILITY:
            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, -removeValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_AGILITY, -removeValue, apply);
            break;
        case ITEM_MOD_STRENGTH:
            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, -removeValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_STRENGTH, -removeValue, apply);
            break;
        case ITEM_MOD_INTELLECT:
            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, -removeValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_INTELLECT, -removeValue, apply);
            break;
        case ITEM_MOD_SPIRIT:
            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, -removeValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_SPIRIT, -removeValue, apply);
            break;
        case ITEM_MOD_STAMINA:
            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, -removeValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_STAMINA, -removeValue, apply);
            break;
        case ITEM_MOD_DEFENSE_SKILL_RATING:
            ApplyRatingMod(CR_DEFENSE_SKILL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_DODGE_RATING:
            ApplyRatingMod(CR_DODGE, -int32(removeValue), apply);
            break;
        case ITEM_MOD_PARRY_RATING:
            ApplyRatingMod(CR_PARRY, -int32(removeValue), apply);
            break;
        case ITEM_MOD_BLOCK_RATING:
            ApplyRatingMod(CR_BLOCK, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HIT_MELEE_RATING:
            ApplyRatingMod(CR_HIT_MELEE, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HIT_RANGED_RATING:
            ApplyRatingMod(CR_HIT_RANGED, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HIT_SPELL_RATING:
            ApplyRatingMod(CR_HIT_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_CRIT_MELEE_RATING:
            ApplyRatingMod(CR_CRIT_MELEE, -int32(removeValue), apply);
            break;
        case ITEM_MOD_CRIT_RANGED_RATING:
            ApplyRatingMod(CR_CRIT_RANGED, -int32(removeValue), apply);
            break;
        case ITEM_MOD_CRIT_SPELL_RATING:
            ApplyRatingMod(CR_CRIT_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HASTE_SPELL_RATING:
            ApplyRatingMod(CR_HASTE_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HIT_RATING:
            ApplyRatingMod(CR_HIT_MELEE, -int32(removeValue), apply);
            ApplyRatingMod(CR_HIT_RANGED, -int32(removeValue), apply);
            ApplyRatingMod(CR_HIT_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_CRIT_RATING:
            ApplyRatingMod(CR_CRIT_MELEE, -int32(removeValue), apply);
            ApplyRatingMod(CR_CRIT_RANGED, -int32(removeValue), apply);
            ApplyRatingMod(CR_CRIT_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_RESILIENCE_RATING:
            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, -int32(removeValue), apply);
            break;
        case ITEM_MOD_HASTE_RATING:
            ApplyRatingMod(CR_HASTE_MELEE, -int32(removeValue), apply);
            ApplyRatingMod(CR_HASTE_RANGED, -int32(removeValue), apply);
            ApplyRatingMod(CR_HASTE_SPELL, -int32(removeValue), apply);
            break;
        case ITEM_MOD_EXPERTISE_RATING:
            ApplyRatingMod(CR_EXPERTISE, -int32(removeValue), apply);
            break;
        case ITEM_MOD_ATTACK_POWER:
            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, -removeValue, apply);
            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, -removeValue, apply);
            break;
        case ITEM_MOD_RANGED_ATTACK_POWER:
            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, -removeValue, apply);
            break;
        case ITEM_MOD_MANA_REGENERATION:
            ApplyManaRegenBonus(-int32(removeValue), apply);
            break;
        case ITEM_MOD_ARMOR_PENETRATION_RATING:
            ApplyRatingMod(CR_ARMOR_PENETRATION, -int32(removeValue), apply);
            break;
        case ITEM_MOD_SPELL_POWER:
            ApplySpellPowerBonus(-int32(removeValue), apply);
            break;
        case ITEM_MOD_HEALTH_REGEN:
            ApplyHealthRegenBonus(-int32(removeValue), apply);
            break;
        case ITEM_MOD_SPELL_PENETRATION:
            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, -int32(removeValue), apply);
            m_spellPenetrationItemMod += apply ? -int32(removeValue) : int32(removeValue);
            break;
        case ITEM_MOD_BLOCK_VALUE:  // obsolete
            break;
        case ITEM_MOD_MASTERY_RATING:
            ApplyRatingMod(CR_MASTERY, -int32(removeValue), apply);
            break;
    }

    switch (reforge->FinalStat)
    {
        case ITEM_MOD_MANA:
            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, addValue, apply);
            break;
        case ITEM_MOD_HEALTH:
            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, addValue, apply);
            break;
        case ITEM_MOD_AGILITY:
            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, addValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_AGILITY, addValue, apply);
            break;
        case ITEM_MOD_STRENGTH:
            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, addValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_STRENGTH, addValue, apply);
            break;
        case ITEM_MOD_INTELLECT:
            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, addValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_INTELLECT, addValue, apply);
            break;
        case ITEM_MOD_SPIRIT:
            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, addValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_SPIRIT, addValue, apply);
            break;
        case ITEM_MOD_STAMINA:
            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, addValue, apply);
            ApplyModSignedFloatValue(UNIT_FIELD_STAT_POS_BUFF + STAT_STAMINA, addValue, apply);
            break;
        case ITEM_MOD_DEFENSE_SKILL_RATING:
            ApplyRatingMod(CR_DEFENSE_SKILL, int32(addValue), apply);
            break;
        case ITEM_MOD_DODGE_RATING:
            ApplyRatingMod(CR_DODGE, int32(addValue), apply);
            break;
        case ITEM_MOD_PARRY_RATING:
            ApplyRatingMod(CR_PARRY, int32(addValue), apply);
            break;
        case ITEM_MOD_BLOCK_RATING:
            ApplyRatingMod(CR_BLOCK, int32(addValue), apply);
            break;
        case ITEM_MOD_HIT_MELEE_RATING:
            ApplyRatingMod(CR_HIT_MELEE, int32(addValue), apply);
            break;
        case ITEM_MOD_HIT_RANGED_RATING:
            ApplyRatingMod(CR_HIT_RANGED, int32(addValue), apply);
            break;
        case ITEM_MOD_HIT_SPELL_RATING:
            ApplyRatingMod(CR_HIT_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_CRIT_MELEE_RATING:
            ApplyRatingMod(CR_CRIT_MELEE, int32(addValue), apply);
            break;
        case ITEM_MOD_CRIT_RANGED_RATING:
            ApplyRatingMod(CR_CRIT_RANGED, int32(addValue), apply);
            break;
        case ITEM_MOD_CRIT_SPELL_RATING:
            ApplyRatingMod(CR_CRIT_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_HASTE_SPELL_RATING:
            ApplyRatingMod(CR_HASTE_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_HIT_RATING:
            ApplyRatingMod(CR_HIT_MELEE, int32(addValue), apply);
            ApplyRatingMod(CR_HIT_RANGED, int32(addValue), apply);
            ApplyRatingMod(CR_HIT_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_CRIT_RATING:
            ApplyRatingMod(CR_CRIT_MELEE, int32(addValue), apply);
            ApplyRatingMod(CR_CRIT_RANGED, int32(addValue), apply);
            ApplyRatingMod(CR_CRIT_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_RESILIENCE_RATING:
            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, int32(addValue), apply);
            break;
        case ITEM_MOD_HASTE_RATING:
            ApplyRatingMod(CR_HASTE_MELEE, int32(addValue), apply);
            ApplyRatingMod(CR_HASTE_RANGED, int32(addValue), apply);
            ApplyRatingMod(CR_HASTE_SPELL, int32(addValue), apply);
            break;
        case ITEM_MOD_EXPERTISE_RATING:
            ApplyRatingMod(CR_EXPERTISE, int32(addValue), apply);
            break;
        case ITEM_MOD_ATTACK_POWER:
            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, addValue, apply);
            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, addValue, apply);
            break;
        case ITEM_MOD_RANGED_ATTACK_POWER:
            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, addValue, apply);
            break;
        case ITEM_MOD_MANA_REGENERATION:
            ApplyManaRegenBonus(int32(addValue), apply);
            break;
        case ITEM_MOD_ARMOR_PENETRATION_RATING:
            ApplyRatingMod(CR_ARMOR_PENETRATION, int32(addValue), apply);
            break;
        case ITEM_MOD_SPELL_POWER:
            ApplySpellPowerBonus(int32(addValue), apply);
            break;
        case ITEM_MOD_HEALTH_REGEN:
            ApplyHealthRegenBonus(int32(addValue), apply);
            break;
        case ITEM_MOD_SPELL_PENETRATION:
            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, int32(addValue), apply);
            m_spellPenetrationItemMod += apply ? int32(addValue) : -int32(addValue);
            break;
        case ITEM_MOD_BLOCK_VALUE:  // obsolete
            break;
        case ITEM_MOD_MASTERY_RATING:
            ApplyRatingMod(CR_MASTERY, int32(addValue), apply);
            break;
    }
}

void Player::ApplyEnchantment(Item* item, bool apply)
{
    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
    {
        ApplyEnchantment(item, EnchantmentSlot(slot), apply);
    }

    ApplyReforgeEnchantment(item, apply);
}

static int32 CalcEnchantAmount(SpellItemEnchantmentEntry const* enchant, uint32 level, uint32 index)
{
    uint32 minLevel = enchant->Flags & ENCHANTMENT_FLAG_ANY_LEVEL_SCALING ? 1 : 60;
    if (level < minLevel)
        level = minLevel;
    int32 scalingClass = enchant->ScalingLevel;
    /* TODO
    if (false)
    {
        if (pEnchant->Unk22)                // Only one enchantment (5147) has Unk22 != 0
            scalingClass = pEnchant->Unk22;
    }
    */
    // Taken from spell effect
    int32  gtKeyBase = (scalingClass <= -1) ? MAX_CLASSES - 2 - scalingClass : scalingClass - 1;
    uint32 levelForKey = enchant->MaxLevel != 0 ? std::min(level, enchant->MaxLevel) : level;

    if (auto const* gtScaling = sGtSpellScalingStore.LookupEntry(gtKeyBase * 100 + levelForKey - 1))
        return gtScaling->value * enchant->ScalingPoints[index];
    return int32(enchant->Amount[index]);
}

void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
{
    if (!item || !item->IsEquipped())
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    uint32 enchant_id = item->GetEnchantmentId(slot);
    if (!enchant_id)
        return;

    // Legendary gems must not work on challenge difficulty
    if (apply && GetMap()->IsChallengeDungeon() && (enchant_id == 4996 || enchant_id == 4997 || enchant_id == 4998))
        return;

    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
    if (!pEnchant)
        return;

    if (!ignore_condition && pEnchant->EnchantmentCondition && !EnchantmentFitsRequirements(pEnchant->EnchantmentCondition, -1))
        return;

    if (pEnchant->RequiredLevel > getLevel())
        return;

    if (pEnchant->RequiredSkill > 0 && pEnchant->RequiredSkillValue > GetSkillValue(pEnchant->RequiredSkill))
        return;

    // Cogwheel gems dont have requirement data set in SpellItemEnchantment.dbc, but they do have it in Item-sparse.db2
    if (ItemTemplate const* gem = sObjectMgr->GetItemTemplate(pEnchant->GemID))
        if (gem->RequiredSkill && GetSkillValue(gem->RequiredSkill) < gem->RequiredSkillRank)
            return;

    // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
    // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
        && !item->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
    {
        // Check if the requirements for the prismatic socket are met before applying the gem stats
         SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
         if (!pPrismaticEnchant || (pPrismaticEnchant->RequiredSkill > 0 && pPrismaticEnchant->RequiredSkillValue > GetSkillValue(pPrismaticEnchant->RequiredSkill)))
             return;
    }

    if (!item->IsBroken())
    {
        for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            uint32 enchant_display_type = pEnchant->Type[s];
            uint32 enchant_amount = pEnchant->Amount[s];
            uint32 enchant_spell_id = pEnchant->SpellID[s];

            switch (enchant_display_type)
            {
                case ITEM_ENCHANTMENT_TYPE_NONE:
                    break;
                case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
                    // processed in Player::CastItemCombatSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
                    if (enchant_spell_id)
                    {
                        if (apply)
                        {
                            int32 basepoints = 0;
                            // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
                            if (item->GetItemRandomPropertyId() < 0)
                            {
                                ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                                if (item_rand)
                                {
                                    // Search enchant_amount
                                    for (int k = 0; k < 5; ++k)
                                    {
                                        if (item_rand->enchant_id[k] == enchant_id)
                                        {
                                            basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
                                            break;
                                        }
                                    }
                                }
                            }
                            // Cast custom spell vs all equal basepoints got from enchant_amount
                            if (basepoints)
                                CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
                            else
                                CastSpell(this, enchant_spell_id, true, item);

                            if (auto const* spellInfo = sSpellMgr->GetSpellInfo(enchant_spell_id))
                            {
                                // Wrong, client parse description and check litterals =/
                                if (pEnchant->ScalingLevel && pEnchant->Amount[s])
                                {
                                    if (AuraEffect* ench = GetAuraEffect(enchant_spell_id, EFFECT_0))
                                        ench->ChangeAmount(CalcEnchantAmount(pEnchant, getLevel(), s));
                                }
                                else if (spellInfo->HasAttribute(SPELL_ATTR11_SCALING_FROM_ITEM))
                                {
                                    if (AuraEffect* ench = GetAuraEffect(enchant_spell_id, EFFECT_0))
                                        ench->ChangeAmount(spellInfo->Effects[EFFECT_0].BasePoints);
                                }
                            }
                        }
                        else
                            RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
                    }
                    break;
                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
                    if (pEnchant->ScalingLevel)
                        enchant_amount = CalcEnchantAmount(pEnchant, getLevel(), s);
                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand)
                        {
                            for (int k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
                            {
                                if (item_rand->enchant_id[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_STAT:
                {
                    if (pEnchant->ScalingLevel)
                        enchant_amount = CalcEnchantAmount(pEnchant, getLevel(), s);
                    if (!enchant_amount)
                    {
                        ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                        if (item_rand_suffix)
                        {
                            for (int k = 0; k < 5; ++k)
                            {
                                if (item_rand_suffix->enchant_id[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetTemplate()->CalculateScalingStatValue(item->GetItemLevel())) / 10000);
                                    break;
                                }
                            }
                        }
                    }

                    TC_LOG_DEBUG("entities.player.items", "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
                    switch (enchant_spell_id)
                    {
                        case ITEM_MOD_MANA:
                            TC_LOG_DEBUG("entities.player.items", "+ %u MANA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_HEALTH:
                            TC_LOG_DEBUG("entities.player.items", "+ %u HEALTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_AGILITY:
                            TC_LOG_DEBUG("entities.player.items", "+ %u AGILITY", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_AGILITY, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_AGILITY, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_STRENGTH:
                            TC_LOG_DEBUG("entities.player.items", "+ %u STRENGTH", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STRENGTH, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_INTELLECT:
                            TC_LOG_DEBUG("entities.player.items", "+ %u INTELLECT", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_INTELLECT, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_SPIRIT:
                            TC_LOG_DEBUG("entities.player.items", "+ %u SPIRIT", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_SPIRIT, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_STAMINA:
                            TC_LOG_DEBUG("entities.player.items", "+ %u STAMINA", enchant_amount);
                            HandleStatModifier(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE, float(enchant_amount), apply);
                            ApplyStatBuffMod(STAT_STAMINA, (float)enchant_amount, apply);
                            break;
                        case ITEM_MOD_DEFENSE_SKILL_RATING:
                            ApplyRatingMod(CR_DEFENSE_SKILL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u DEFENCE", enchant_amount);
                            break;
                        case ITEM_MOD_DODGE_RATING:
                            ApplyRatingMod(CR_DODGE, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u DODGE", enchant_amount);
                            break;
                        case ITEM_MOD_PARRY_RATING:
                            ApplyRatingMod(CR_PARRY, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u PARRY", enchant_amount);
                            break;
                        case ITEM_MOD_BLOCK_RATING:
                            ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u SHIELD_BLOCK", enchant_amount);
                            break;
                        case ITEM_MOD_HIT_MELEE_RATING:
                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u MELEE_HIT", enchant_amount);
                            break;
                        case ITEM_MOD_HIT_RANGED_RATING:
                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_HIT", enchant_amount);
                            break;
                        case ITEM_MOD_HIT_SPELL_RATING:
                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_HIT", enchant_amount);
                            break;
                        case ITEM_MOD_CRIT_MELEE_RATING:
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u MELEE_CRIT", enchant_amount);
                            break;
                        case ITEM_MOD_CRIT_RANGED_RATING:
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_CRIT", enchant_amount);
                            break;
                        case ITEM_MOD_CRIT_SPELL_RATING:
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_CRIT", enchant_amount);
                            break;
                        // Values from ITEM_STAT_MELEE_HA_RATING to ITEM_MOD_HASTE_RANGED_RATING are never used
                        // in Enchantments
                        // case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
                        //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
                        //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
                        //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
                        //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
                        //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
                        //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_HASTE_MELEE_RATING:
                        //     ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_HASTE_RANGED_RATING:
                        //     ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
                        //     break;
                        case ITEM_MOD_HASTE_SPELL_RATING:
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HIT_RATING:
                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u HIT", enchant_amount);
                            break;
                        case ITEM_MOD_CRIT_RATING:
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u CRITICAL", enchant_amount);
                            break;
                        // case ITEM_MOD_HIT_TAKEN_RATING: // Unused since 3.3.5
                        //     ApplyRatingMod(CR_HIT_TAKEN_MELEE, enchant_amount, apply);
                        //     ApplyRatingMod(CR_HIT_TAKEN_RANGED, enchant_amount, apply);
                        //     ApplyRatingMod(CR_HIT_TAKEN_SPELL, enchant_amount, apply);
                        //     break;
                        // case ITEM_MOD_CRIT_TAKEN_RATING: // Unused since 3.3.5
                        //     ApplyRatingMod(CR_CRIT_TAKEN_MELEE, enchant_amount, apply);
                        //     ApplyRatingMod(CR_CRIT_TAKEN_RANGED, enchant_amount, apply);
                        //     ApplyRatingMod(CR_CRIT_TAKEN_SPELL, enchant_amount, apply);
                        //     break;
                        case ITEM_MOD_RESILIENCE_RATING:
                            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE_TAKEN, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u RESILIENCE", enchant_amount);
                            break;
                        case ITEM_MOD_HASTE_RATING:
                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u HASTE", enchant_amount);
                            break;
                        case ITEM_MOD_EXPERTISE_RATING:
                            ApplyRatingMod(CR_EXPERTISE, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u EXPERTISE", enchant_amount);
                            break;
                        case ITEM_MOD_ATTACK_POWER:
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u ATTACK_POWER", enchant_amount);
                            break;
                        case ITEM_MOD_RANGED_ATTACK_POWER:
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u RANGED_ATTACK_POWER", enchant_amount);
                            break;
                        case ITEM_MOD_MANA_REGENERATION:
                            ApplyManaRegenBonus(enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u MANA_REGENERATION", enchant_amount);
                            break;
                        case ITEM_MOD_ARMOR_PENETRATION_RATING:
                            ApplyRatingMod(CR_ARMOR_PENETRATION, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u ARMOR PENETRATION", enchant_amount);
                            break;
                        case ITEM_MOD_SPELL_POWER:
                            ApplySpellPowerBonus(enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_POWER", enchant_amount);
                            break;
                        case ITEM_MOD_HEALTH_REGEN:
                            ApplyHealthRegenBonus(enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u HEALTH_REGENERATION", enchant_amount);
                            break;
                        case ITEM_MOD_SPELL_PENETRATION:
                            ApplySpellPenetrationBonus(enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u SPELL_PENETRATION", enchant_amount);
                            break;
                        case ITEM_MOD_BLOCK_VALUE:  // obsolete
                            break;
                        case ITEM_MOD_MASTERY_RATING:
                            ApplyRatingMod(CR_MASTERY, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u MASTERY", enchant_amount);
                            break;
                        case ITEM_MOD_PVP_POWER:
                            ApplyRatingMod(CR_PVP_POWER, enchant_amount, apply);
                            TC_LOG_DEBUG("entities.player.items", "+ %u PVP_POWER", enchant_amount);
                            break;
                        default:
                            break;
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
                {
                    if (getClass() == CLASS_SHAMAN)
                    {
                        float addValue = 0.0f;
                        if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
                        }
                        else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->Delay / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
                        }
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
                    // processed in Player::CastItemUseSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
                    // nothing do..
                    break;
                default:
                    TC_LOG_ERROR("entities.player", "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
                    break;
            }                                               /*switch (enchant_display_type)*/
        }                                                   /*for*/
    }

    // visualize enchantment at player and equipped items
    if (slot == PERM_ENCHANTMENT_SLOT)
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + 1 + (item->GetSlot() * 2), 0, apply ? item->GetEnchantmentId(slot) : 0);

    if (slot == TEMP_ENCHANTMENT_SLOT)
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + 1 + (item->GetSlot() * 2), 1, apply ? item->GetEnchantmentId(slot) : 0);

    if (apply_dur)
    {
        if (apply)
        {
            // set duration
            uint32 duration = item->GetEnchantmentDuration(slot);
            if (duration > 0)
                AddEnchantmentDuration(item, slot, duration);
        }
        else
        {
            // duration == 0 will remove EnchantDuration
            AddEnchantmentDuration(item, slot, 0);
        }
    }
}

void Player::UpdateSkillEnchantments(uint16 skill_id, uint16 curr_value, uint16 new_value)
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            for (uint8 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
            {
                if (slot > PRISMATIC_ENCHANTMENT_SLOT && slot < PROP_ENCHANTMENT_SLOT_0)    // not holding enchantment id
                    continue;

                uint32 ench_id = m_items[i]->GetEnchantmentId(EnchantmentSlot(slot));
                if (!ench_id)
                    continue;

                SpellItemEnchantmentEntry const* Enchant = sSpellItemEnchantmentStore.LookupEntry(ench_id);
                if (!Enchant)
                    return;

                if (Enchant->RequiredSkill == skill_id)
                {
                    // Checks if the enchantment needs to be applied or removed
                    if (curr_value < Enchant->RequiredSkillValue && new_value >= Enchant->RequiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                    else if (new_value < Enchant->RequiredSkillValue && curr_value >= Enchant->RequiredSkillValue)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                }

                // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
                // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
                if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
                    && !m_items[i]->GetTemplate()->Socket[slot-SOCK_ENCHANTMENT_SLOT].Color)
                {
                    SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(m_items[i]->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));

                    if (pPrismaticEnchant && pPrismaticEnchant->RequiredSkill == skill_id)
                    {
                        if (curr_value < pPrismaticEnchant->RequiredSkillValue && new_value >= pPrismaticEnchant->RequiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                        else if (new_value < pPrismaticEnchant->RequiredSkillValue && curr_value >= pPrismaticEnchant->RequiredSkillValue)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                    }
                }
            }
        }
    }
}

void Player::SendEnchantmentDurations()
{
    for (EnchantDurationList::const_iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        GetSession()->SendItemEnchantTimeUpdate(GetGUID(), itr->item->GetGUID(), itr->slot, uint32(itr->leftduration) / 1000);
}

void Player::SendItemDurations()
{
    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
        (*itr)->SendTimeUpdate(this);
}

void Player::SendNewItem(Item* item, uint32 count, bool received, bool created, bool broadcast)
{
    if (!item)                                              // prevent crash
        return;

    uint32 itemSlot = (item->GetCount() == count) ? item->GetSlot() : -1;

    ObjectGuid playerGuid = GetGUID();
    ObjectGuid itemGuid; // = item->GetGUID(); not found in sniffs, 0 in all cases

    WorldPacket data(SMSG_ITEM_PUSH_RESULT, 1 + 8 + 1 + 4 + 4 + 4 + 4 + 4 + 4 + 1 + 4 + 4 + 4);
    data.WriteBit(itemGuid[2]);
    data.WriteBit(playerGuid[4]);
    data.WriteBit(itemGuid[5]);
    data.WriteBit(1);                                       // display in chat
    data.WriteBit(playerGuid[1]);
    data.WriteBit(received);                                // 0 = looted, 1 = npc
    data.WriteBit(itemGuid[4]);
    data.WriteBit(playerGuid[6]);
    data.WriteBit(playerGuid[5]);
    data.WriteBit(playerGuid[7]);
    data.WriteBit(playerGuid[0]);
    data.WriteBit(itemGuid[0]);
    data.WriteBit(itemGuid[7]);
    data.WriteBit(playerGuid[2]);
    data.WriteBit(itemGuid[6]);
    data.WriteBit(0);                                       // bonus loot
    data.WriteBit(playerGuid[3]);
    data.WriteBit(itemGuid[1]);
    data.WriteBit(created);                                 // 0 = received. 1 = created
    data.WriteBit(itemGuid[3]);
    data.FlushBits();

    data.WriteByteSeq(playerGuid[1]);
    data.WriteByteSeq(itemGuid[1]);
    data << uint32(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_BATTLE_PET_SPECIES));
    data.WriteByteSeq(itemGuid[0]);
    data.WriteByteSeq(playerGuid[5]);
    data.WriteByteSeq(playerGuid[2]);
    data << uint32(item->GetItemSuffixFactor());            // suffix factor
    data.WriteByteSeq(itemGuid[7]);
    data << uint32(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_BATTLE_PET_BREED) >> 24);        // Quality
    data << uint32(item->GetEntry());                       // item id
    data << int32(item->GetItemRandomPropertyId());         // random item property id
    data.WriteByteSeq(itemGuid[6]);
    data << uint32(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_BATTLE_PET_BREED) & 0xFFFFFF);   // Breed
    data << uint32(GetItemCount(item->GetEntry()));         // count of items in inventory
    data.WriteByteSeq(itemGuid[2]);
    data.WriteByteSeq(playerGuid[0]);
    data << uint32(count);                                  // count of items
    data.WriteByteSeq(playerGuid[7]);
    data.WriteByteSeq(itemGuid[5]);
    data.WriteByteSeq(playerGuid[4]);
    data << uint32(itemSlot);                               // item slot, but when added to stack: 0xFFFFFFFF
    data << uint8(item->GetBagSlot());                      // bag slot
    data.WriteByteSeq(playerGuid[3]);
    data.WriteByteSeq(playerGuid[6]);
    data << uint32(item->GetDynamicUInt32Value(ITEM_DYNAMIC_MODIFIERS, ITEM_MODIFIER_INDEX_BATTLE_PET_LEVEL));
    data.WriteByteSeq(itemGuid[3]);
    data.WriteByteSeq(itemGuid[4]);

    if (broadcast && GetGroup())
        GetGroup()->BroadcastPacket(&data, true);
    else
        GetSession()->SendPacket(&data);
}

/*********************************************************/
/***                    GOSSIP SYSTEM                  ***/
/*********************************************************/

void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool showQuests /*= false*/)
{
    PlayerMenu* menu = PlayerTalkClass;
    menu->ClearMenus();

    menu->GetGossipMenu().SetMenuId(menuId);

    GossipMenuItemsMapBounds menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(menuId);

    // if default menuId and no menu options exist for this, use options from default options
    bool defaultMenu = false;
    if (menuItemBounds.first == menuItemBounds.second && menuId == GetDefaultGossipMenuForSource(source))
    {
        menuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);
        defaultMenu = true;
    }

    uint32 npcflags = 0;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        npcflags = source->GetUInt32Value(UNIT_FIELD_NPC_FLAGS);
        if (showQuests && npcflags & UNIT_NPC_FLAG_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());
    }
    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
        if (showQuests && source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());

    for (GossipMenuItemsContainer::const_iterator itr = menuItemBounds.first; itr != menuItemBounds.second; ++itr)
    {
        bool canTalk = true;
        if (!sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            continue;

        if (Creature* creature = source->ToCreature())
        {
            if (!(itr->second.OptionNpcflag & npcflags))
                continue;

            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_ARMORER:
                    canTalk = false;                       // added in special mode
                    break;
                case GOSSIP_OPTION_SPIRITHEALER:
                    if (!isDead())
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_VENDOR:
                {
                    //VendorItemData const* vendorItems = creature->GetVendorItems();
					VendorItemData const* vendorItems = itr->second.ActionMenuId ? sObjectMgr->GetNpcVendorItemList(itr->second.ActionMenuId) : creature->GetVendorItems();
					if (!itr->second.ActionMenuId && (!vendorItems || vendorItems->Empty()))
                    {
                        TC_LOG_ERROR("sql.sql", "Creature %s (Entry: %u GUID: %u DB GUID: %u) has UNIT_NPC_FLAG_VENDOR set but has an empty trading item list.", creature->GetName().c_str(), creature->GetEntry(), creature->GetGUIDLow(), creature->GetDBTableGUIDLow());
                        canTalk = false;
                    }
                    break;
                }
                case GOSSIP_OPTION_UNLEARN_SPEC:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNTALENTS:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARN_GLYPHS:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_LEARNDUALSPEC:
                    if (!(GetSpecsCount() == 1 && creature->isCanTrainingAndResetTalentsOf(this) && !(getLevel() < sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_TAXIVENDOR:
                    if (GetSession()->SendLearnNewTaxiNode(creature))
                        return;
                    break;
                case GOSSIP_OPTION_BATTLEFIELD:
                    if (!creature->isCanInteractWithBattleMaster(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_STABLEPET:
                    if (getClass() != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_PROVING_GROUNDS:
                    if (!((creature->isCanTrainingAndResetTalentsOf(this) || creature->GetEntry() == 72536) && getLevel() == 90))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_QUESTGIVER:
                    canTalk = false;
                    break;
                case GOSSIP_OPTION_TRAINER:
                    if (getClass() != creature->GetCreatureTemplate()->trainer_class && creature->GetCreatureTemplate()->trainer_type == TRAINER_TYPE_CLASS)
                        TC_LOG_ERROR("sql.sql", "GOSSIP_OPTION_TRAINER:: Player %s (GUID: %u) request wrong gossip menu: %u with wrong class: %u at Creature: %s (Entry: %u, Trainer Class: %u)",
                        GetName().c_str(), GetGUIDLow(), menu->GetGossipMenu().GetMenuId(), getClass(), creature->GetName().c_str(), creature->GetEntry(), creature->GetCreatureTemplate()->trainer_class);
                    // no break;
                case GOSSIP_OPTION_GOSSIP:
                case GOSSIP_OPTION_SPIRITGUIDE:
                case GOSSIP_OPTION_INNKEEPER:
                case GOSSIP_OPTION_BANKER:
                case GOSSIP_OPTION_PETITIONER:
                case GOSSIP_OPTION_TABARDDESIGNER:
                case GOSSIP_OPTION_AUCTIONEER:
                    break;                                  // no checks
                case GOSSIP_OPTION_OUTDOORPVP:
                    if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
                        canTalk = false;
                    break;
                default:
                    TC_LOG_ERROR("sql.sql", "Creature entry %u has unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuId);
                    canTalk = false;
                    break;
            }
        }
        else if (GameObject* go = source->ToGameObject())
        {
            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_GOSSIP:
                    if (go->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && go->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
                        canTalk = false;
                    break;
                default:
                    canTalk = false;
                    break;
            }
        }

        if (canTalk)
        {
            std::string strOptionText = itr->second.OptionText;
            std::string strBoxText = itr->second.BoxText;

            int32 locale = GetSession()->GetSessionDbLocaleIndex();
            if (locale >= 0)
            {
                uint32 idxEntry = MAKE_PAIR32(defaultMenu ? 0 : menuId, itr->second.OptionIndex);
                if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
                {
                    ObjectMgr::GetLocaleString(no->OptionText, locale, strOptionText);
                    ObjectMgr::GetLocaleString(no->BoxText, locale, strBoxText);
                }
            }

            menu->GetGossipMenu().AddMenuItem(itr->second.OptionIndex, itr->second.OptionIcon, strOptionText, 0, itr->second.OptionType, strBoxText, itr->second.BoxMoney, itr->second.BoxCoded);
            menu->GetGossipMenu().AddGossipMenuItemData(itr->second.OptionIndex, itr->second.ActionMenuId, itr->second.ActionPoiId);
        }
    }
}

void Player::SendPreparedGossip(WorldObject* source)
{
    if (!source)
        return;

    if (source->GetTypeId() == TYPEID_UNIT)
    {
        // in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
        if (!source->ToCreature()->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }
    else if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        // probably need to find a better way here
        if (!PlayerTalkClass->GetGossipMenu().GetMenuId() && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }

    // in case non empty gossip menu (that not included quests list size) show it
    // (quest entries from quest menu will be included in list)

    uint32 textId = GetGossipTextId(source);

    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
        textId = GetGossipTextId(menuId, source);

    PlayerTalkClass->SendGossipMenu(textId, source->GetGUID());
}

void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 menuId)
{
    GossipMenu& gossipMenu = PlayerTalkClass->GetGossipMenu();

    // if not same, then something funky is going on
    if (menuId != gossipMenu.GetMenuId())
        return;

    GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
    if (!item)
        return;

    uint32 gossipOptionId = item->OptionType;
    uint64 guid = source->GetGUID();

    if (source->GetTypeId() == TYPEID_GAMEOBJECT)
    {
        if (gossipOptionId > GOSSIP_OPTION_QUESTGIVER)
        {
            TC_LOG_ERROR("entities.player", "Player guid %u request invalid gossip option for GameObject entry %u", GetGUIDLow(), source->GetEntry());
            return;
        }
    }

    GossipMenuItemData const* menuItemData = gossipMenu.GetItemData(gossipListId);
    if (!menuItemData)
        return;

    int32 cost = int32(item->BoxMoney);
    if (!HasEnoughMoney(int64(cost)))
    {
        SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
        PlayerTalkClass->SendCloseGossip();
        return;
    }

    switch (gossipOptionId)
    {
        case GOSSIP_OPTION_GOSSIP:
        {
            if (menuItemData->GossipActionPoi)
                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);

            if (menuItemData->GossipActionMenuId)
            {
                PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
                SendPreparedGossip(source);
            }

            break;
        }
        case GOSSIP_OPTION_OUTDOORPVP:
            sOutdoorPvPMgr->HandleGossipOption(this, source->GetGUID(), gossipListId);
            break;
        case GOSSIP_OPTION_SPIRITHEALER:
            if (isDead())
                source->ToCreature()->CastSpell(source->ToCreature(), 17251, true, NULL, NULL, GetGUID());
            break;
        case GOSSIP_OPTION_QUESTGIVER:
            PrepareQuestMenu(guid);
            SendPreparedQuest(guid);
            break;
        case GOSSIP_OPTION_VENDOR:
        case GOSSIP_OPTION_ARMORER:
            //GetSession()->SendListInventory(guid);
		    GetSession()->SendListInventory(guid, menuItemData->GossipActionMenuId);
            break;
        case GOSSIP_OPTION_STABLEPET:
            GetSession()->SendPetList(guid, PET_SLOT_ACTIVE_FIRST, PET_SLOT_STABLE_LAST);
            break;
        case GOSSIP_OPTION_TRAINER:
            GetSession()->SendTrainerList(guid);
            break;
        case GOSSIP_OPTION_UNLEARN_SPEC:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, true);
            break;
        case GOSSIP_OPTION_UNLEARNTALENTS:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, false);
            break;
        case GOSSIP_OPTION_UNLEARN_GLYPHS:
            PlayerTalkClass->SendCloseGossip();
            // TODO - DO-DO-DO!
            break;
        case GOSSIP_OPTION_PROVING_GROUNDS:
        {
            PlayerTalkClass->SendCloseGossip();
            if (GetGroup() || IsUsingLfg() || getLevel() < 90)
                break;

            lfg::LfgDungeonSet scenario = { 658 };
            sLFGMgr->JoinLfg(this, lfg::PLAYER_ROLE_DAMAGE, scenario, "");
            break;
        }
        case GOSSIP_OPTION_LEARNDUALSPEC:
            if (GetSpecsCount() == 1 && getLevel() >= sWorld->getIntConfig(CONFIG_MIN_DUALSPEC_LEVEL))
            {
                // Cast spells that teach dual spec
                // Both are also ImplicitTarget self and must be cast by player
                CastSpell(this, 63680, true, NULL, NULL, GetGUID());
                CastSpell(this, 63624, true, NULL, NULL, GetGUID());

                // Should show another Gossip text with "Congratulations..."
                PlayerTalkClass->SendCloseGossip();
            }
            break;
        case GOSSIP_OPTION_TAXIVENDOR:
            GetSession()->SendTaxiMenu(source->ToCreature());
            break;
        case GOSSIP_OPTION_INNKEEPER:
            PlayerTalkClass->SendCloseGossip();
            SetBindPoint(guid);
            break;
        case GOSSIP_OPTION_BANKER:
            GetSession()->SendShowBank(guid);
            break;
        case GOSSIP_OPTION_PETITIONER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendPetitionShowList(guid);
            break;
        case GOSSIP_OPTION_TABARDDESIGNER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendTabardVendorActivate(guid);
            break;
        case GOSSIP_OPTION_AUCTIONEER:
            GetSession()->SendAuctionHello(guid, source->ToCreature());
            break;
        case GOSSIP_OPTION_SPIRITGUIDE:
            PrepareGossipMenu(source);
            SendPreparedGossip(source);
            break;
        case GOSSIP_OPTION_BATTLEFIELD:
        {
            BattlegroundTypeId bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());

            if (bgTypeId == BATTLEGROUND_TYPE_NONE)
            {
                TC_LOG_ERROR("entities.player", "a user (guid %u) requested battlegroundlist from a npc who is no battlemaster", GetGUIDLow());
                return;
            }

            GetSession()->SendBattleGroundList(guid, bgTypeId);
            break;
        }
    }

    ModifyMoney(-cost);
}

uint32 Player::GetGossipTextId(WorldObject* source)
{
    if (!source)
        return DEFAULT_GOSSIP_MESSAGE;

    return GetGossipTextId(GetDefaultGossipMenuForSource(source), source);
}

uint32 Player::GetGossipTextId(uint32 menuId, WorldObject* source)
{
    uint32 textId = DEFAULT_GOSSIP_MESSAGE;

    if (!menuId)
        return textId;

    GossipMenusMapBounds menuBounds = sObjectMgr->GetGossipMenusMapBounds(menuId);

    for (GossipMenusContainer::const_iterator itr = menuBounds.first; itr != menuBounds.second; ++itr)
    {
        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.conditions))
            textId = itr->second.text_id;
    }

    return textId;
}

uint32 Player::GetDefaultGossipMenuForSource(WorldObject* source)
{
    switch (source->GetTypeId())
    {
        case TYPEID_UNIT:
            return source->ToCreature()->GetGossipMenuId();
        case TYPEID_GAMEOBJECT:
            return source->ToGameObject()->GetGOInfo()->GetGossipMenuId();
        default:
            break;
    }

    return 0;
}

/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/

void Player::PrepareQuestMenu(uint64 guid)
{
    QuestRelationBounds objectQR;
    QuestRelationBounds objectQIR;

    // pets also can have quests
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (creature)
    {
        objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
        objectQIR = sObjectMgr->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
    }
    else
    {
        //we should obtain map pointer from GetMap() in 99% of cases. Special case
        //only for quests which cast teleport spells on player
        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
        ASSERT(_map);
        GameObject* gameObject = _map->GetGameObject(guid);
        if (gameObject)
        {
            objectQR  = sObjectMgr->GetGOQuestRelationBounds(gameObject->GetEntry());
            objectQIR = sObjectMgr->GetGOQuestInvolvedRelationBounds(gameObject->GetEntry());
        }
        else
            return;
    }

    QuestMenu &qm = PlayerTalkClass->GetQuestMenu();
    qm.ClearMenu();

    for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
    {
        uint32 quest_id = i->second;
        QuestStatus status = GetQuestStatus(quest_id);
        if (status == QUEST_STATUS_COMPLETE)
            qm.AddMenuItem(quest_id, 4);
        else if (status == QUEST_STATUS_INCOMPLETE)
            qm.AddMenuItem(quest_id, 4);
        //else if (status == QUEST_STATUS_AVAILABLE)
        //    qm.AddMenuItem(quest_id, 2);
    }

    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
    {
        uint32 quest_id = i->second;
        Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
        if (!quest)
            continue;

        if (!CanTakeQuest(quest, false))
            continue;

        if (!sWorld->getBoolConfig(CONFIG_QUEST_IGNORE_AUTO_COMPLETE) && quest->GetQuestMethod() == 0)
            qm.AddMenuItem(quest_id, 4);
        else if (GetQuestStatus(quest_id) == QUEST_STATUS_NONE)
            qm.AddMenuItem(quest_id, 2);
    }
}

void Player::SendPreparedQuest(uint64 guid)
{
    QuestMenu& questMenu = PlayerTalkClass->GetQuestMenu();
    if (questMenu.Empty())
        return;

    // single element case
    if (questMenu.GetMenuItemCount() == 1)
    {
        QuestMenuItem const& qmi0 = questMenu.GetItem(0);
        uint32 questId = qmi0.QuestId;

        // Auto open -- maybe also should verify there is no greeting
        if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
        {
            if (qmi0.QuestIcon == 4)
                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
            // Send completable on repeatable and autoCompletable quest if player don't have quest
            /// @todo verify if check for !quest->IsDaily() is really correct (possibly not)
            else
            {
                Object* object = ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT | TYPEMASK_ITEM);
                if (!object || (!object->hasQuest(questId) && !object->hasInvolvedQuest(questId)))
                {
                    PlayerTalkClass->SendCloseGossip();
                    return;
                }

                if (quest->IsAutoAccept() && CanAddQuest(quest, true) && CanTakeQuest(quest, true))
                    AddQuestAndCheckCompletion(quest, object);

                if (!sWorld->getBoolConfig(CONFIG_QUEST_IGNORE_AUTO_COMPLETE) && quest->GetQuestMethod() == 0 && quest->IsRepeatable() && !quest->IsDailyOrWeekly())
                    PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanCompleteRepeatableQuest(quest), true);
                else
                    PlayerTalkClass->SendQuestGiverQuestDetails(quest, guid, true);
            }
        }
    }
    // multiple entries
    else
    {
        QEmote qe;
        qe._Delay = 0;
        qe._Emote = 0;
        std::string title = "";

        // need pet case for some quests
        Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
        if (creature)
        {
            uint32 textid = GetGossipTextId(creature);
            GossipText const* gossiptext = sObjectMgr->GetGossipText(textid);
            if (!gossiptext)
            {
                qe._Delay = 0;                              //TEXTEMOTE_MESSAGE;              //zyg: player emote
                qe._Emote = 0;                              //TEXTEMOTE_HELLO;                //zyg: NPC emote
                title = "";
            }
            else
            {
                qe = gossiptext->Options[0].Emotes[0];

                if (!gossiptext->Options[0].Text_0.empty())
                {
                    title = gossiptext->Options[0].Text_0;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_0[0], loc_idx, title);
                }
                else
                {
                    title = gossiptext->Options[0].Text_1;

                    int loc_idx = GetSession()->GetSessionDbLocaleIndex();
                    if (loc_idx >= 0)
                        if (NpcTextLocale const* nl = sObjectMgr->GetNpcTextLocale(textid))
                            ObjectMgr::GetLocaleString(nl->Text_1[0], loc_idx, title);
                }
            }
        }
        PlayerTalkClass->SendQuestGiverQuestList(qe, title, guid);
    }
}

bool Player::IsActiveQuest(uint32 quest_id) const
{
    return m_QuestStatus.find(quest_id) != m_QuestStatus.end();
}

Quest const* Player::GetNextQuest(uint64 guid, Quest const* quest)
{
    QuestRelationBounds objectQR;
    uint32 nextQuestID = quest->GetNextQuestInChain();

    switch (GUID_HIPART(guid))
    {
        case HIGHGUID_PLAYER:
            ASSERT(quest->HasFlag(QUEST_FLAGS_AUTO_SUBMIT) || quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE));
            return sObjectMgr->GetQuestTemplate(nextQuestID);
        case HIGHGUID_UNIT:
        case HIGHGUID_PET:
        case HIGHGUID_VEHICLE:
        {
            if (Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid))
                objectQR  = sObjectMgr->GetCreatureQuestRelationBounds(creature->GetEntry());
            else
                return NULL;
            break;
        }
        case HIGHGUID_GAMEOBJECT:
        {
            //we should obtain map pointer from GetMap() in 99% of cases. Special case
            //only for quests which cast teleport spells on player
            Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
            ASSERT(_map);
            if (GameObject* gameObject = _map->GetGameObject(guid))
                objectQR = sObjectMgr->GetGOQuestRelationBounds(gameObject->GetEntry());
            else
                return NULL;
            break;
        }
        default:
            return NULL;
    }

    // for unit and go state
    for (QuestRelations::const_iterator itr = objectQR.first; itr != objectQR.second; ++itr)
    {
        if (itr->second == nextQuestID)
            return sObjectMgr->GetQuestTemplate(nextQuestID);
    }

    return NULL;
}

bool Player::CanSeeStartQuest(Quest const* quest)
{
    if (!DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this) && SatisfyQuestClass(quest, false) && SatisfyQuestRace(quest, false) &&
        SatisfyQuestSkill(quest, false) && SatisfyQuestExclusiveGroup(quest, false) && SatisfyQuestReputation(quest, false) &&
        SatisfyQuestPreviousQuest(quest, false) && SatisfyQuestNextChain(quest, false) &&
        SatisfyQuestPrevChain(quest, false) && SatisfyQuestDay(quest, false) && SatisfyQuestWeek(quest, false) &&
        SatisfyQuestMonth(quest, false) && SatisfyQuestSeasonal(quest, false))
    {
        return getLevel() + sWorld->getIntConfig(CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF) >= quest->GetMinLevel();
    }

    return false;
}

bool Player::CanTakeQuest(Quest const* quest, bool msg)
{
    return !DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this)
        && SatisfyQuestStatus(quest, msg) && SatisfyQuestExclusiveGroup(quest, msg)
        && SatisfyQuestClass(quest, msg) && SatisfyQuestRace(quest, msg) && SatisfyQuestLevel(quest, msg)
        && SatisfyQuestSkill(quest, msg) && SatisfyQuestReputation(quest, msg)
        && SatisfyQuestPreviousQuest(quest, msg) && SatisfyQuestTimed(quest, msg)
        && SatisfyQuestNextChain(quest, msg) && SatisfyQuestPrevChain(quest, msg)
        && SatisfyQuestDay(quest, msg) && SatisfyQuestWeek(quest, msg)
        && SatisfyQuestMonth(quest, msg) && SatisfyQuestSeasonal(quest, msg)
        && SatisfyQuestConditions(quest, msg);
}

bool Player::CanAddQuest(Quest const* quest, bool msg)
{
    if (!SatisfyQuestLog(msg))
        return false;

    uint32 srcitem = quest->GetSrcItemId();
    if (srcitem > 0)
    {
        ItemPosCountVec dest;
        InventoryResult msg2 = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);

        // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
        if (msg2 == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else if (msg2 != EQUIP_ERR_OK)
        {
            SendEquipError(msg2, NULL, NULL, srcitem);
            return false;
        }
    }
    return true;
}

bool Player::CanCompleteQuest(uint32 questId)
{
    if (questId)
    {
        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            return false;

        if (!qInfo->IsRepeatable() && IsQuestRewarded(questId))
            return false;                                   // not allow re-complete quest

        // auto complete quest
        if ((qInfo->IsAutoComplete() || qInfo->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE) && CanTakeQuest(qInfo, false))
            return true;

        QuestStatusMap::iterator itr = m_QuestStatus.find(questId);
        if (itr == m_QuestStatus.end())
            return false;

        QuestStatusData &questStatus = itr->second;
        if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
        {
            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && questStatus.Timer == 0)
                return false;

            if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_AREATRIGGER) && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT) && !questStatus.Explored)
                return false;

            for (auto&& questObjective : qInfo->m_questObjectives)
            {
                if (!IsQuestObjectiveComplete(qInfo, *questObjective))
                    return false;
            }

            return true;
        }
    }
    return false;
}

bool Player::IsQuestObjectiveComplete(Quest const* quest, QuestObjective const& objective) const
{
    switch (objective.Type)
    {
        case QUEST_OBJECTIVE_TYPE_SPELL:
            if (!HasSpell(objective.ObjectId))
                return false;
            break;
        case QUEST_OBJECTIVE_TYPE_FACTION_REP:
            if (GetReputationMgr().GetReputation(objective.ObjectId) < objective.Amount)
                return false;
            break;
        case QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG:
            if (GetReputationMgr().GetReputation(objective.ObjectId) > objective.Amount)
                return false;
            break;
        case QUEST_OBJECTIVE_TYPE_MONEY:
            if (!HasEnoughMoney(uint64(objective.Amount)))
                return false;
            break;
        case QUEST_OBJECTIVE_TYPE_AREATRIGGER:
            if (GetQuestObjectiveCounter(objective.Id) == 0)
                return false;
            break;
        case QUEST_OBJECTIVE_TYPE_CURRENCY:
            if (!HasCurrency(objective.ObjectId, objective.Amount))
                return false;
            break;
        default:
            if (GetQuestObjectiveCounter(objective.Id) < uint32(objective.Amount))
                return false;
    }

    return true;
}

bool Player::CanCompleteRepeatableQuest(Quest const* quest)
{
    // Solve problem that player don't have the quest and try complete it.
    // if repeatable she must be able to complete event if player don't have it.
    // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
    if (!CanTakeQuest(quest, false))
        return false;

    for (auto&& objective : quest->m_questObjectives)
    {
        if (objective->Type == QUEST_OBJECTIVE_TYPE_ITEM)
            if (!HasItemCount(objective->ObjectId, objective->Amount))
                return false;

        if (objective->Type == QUEST_OBJECTIVE_TYPE_CURRENCY)
            if (!HasCurrency(objective->ObjectId, objective->Amount))
                return false;
    }

    if (!CanRewardQuest(quest, false))
        return false;

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, bool msg)
{
    // not auto complete quest and not completed quest (only cheating case, then ignore without message)
    if (!quest->IsDFQuest() && !quest->IsAutoComplete() && !(quest->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE) && GetQuestStatus(quest->GetQuestId()) != QUEST_STATUS_COMPLETE)
        return false;

    // daily quest can't be rewarded (25 daily quest already completed)
    if (!SatisfyQuestDay(quest, true) || !SatisfyQuestWeek(quest, true) || !SatisfyQuestMonth(quest, true) || !SatisfyQuestSeasonal(quest, true))
        return false;

    // rewarded and not repeatable quest (only cheating case, then ignore without message)
    if (GetQuestRewardStatus(quest->GetQuestId()))
        return false;

    for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
    {
        QuestObjective const* questObjective = *citr;
        switch (questObjective->Type)
        {
            case QUEST_OBJECTIVE_TYPE_ITEM:
            {
                if (GetItemCount(questObjective->ObjectId) < uint32(questObjective->Amount))
                {
                    if (msg)
                        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, questObjective->ObjectId);

                    return false;
                }

                break;
            }
            case QUEST_OBJECTIVE_TYPE_CURRENCY:
            {
                if (!HasCurrency(questObjective->ObjectId, questObjective->Amount))
                    return false;

                break;
            }
            case QUEST_OBJECTIVE_TYPE_MONEY:
            {
                if (!HasEnoughMoney(uint64(questObjective->Amount)))
                    return false;

                break;
            }
            default:
                break;
        }
    }

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, uint32 reward, bool msg)
{
    // prevent receive reward with quest items in bank or for not completed quest
    if (!CanRewardQuest(quest, msg))
        return false;

    if (quest->GetRewItemsCount() > 0)
    {
        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
        {
            if (quest->RewardItemId[i])
            {
                ItemPosCountVec dest;
                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardItemId[i], quest->RewardItemIdCount[i]);
                if (res != EQUIP_ERR_OK)
                {
                    SendEquipError(res, NULL, NULL, quest->RewardItemId[i]);
                    return false;
                }
            }
        }
    }

    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST))
    {
        if (!sWorld->AreprojectDailyQuestsEnabled())
            return false;

        projectMemberInfo* info = GetSession()->GetprojectMemberInfo();
        if (!info || !info->CanCompleteMoreDailyQuests())
            return false;

        if (info->CompletedDailyQuestExclusiveGroups.find(quest->GetExclusiveGroup()) != info->CompletedDailyQuestExclusiveGroups.end())
            return false;
    }

    uint32 count = 0;
    if (quest->GetRewardPackageItemId())
    {
        // Can be without a reward for specified spec
        if (reward && !GetQuestRewardItemCountFromPackage(reward, quest->GetRewardPackageItemId(), count))
            return false;
    }
    else if (quest->GetRewChoiceItemsCount() > 0)
    {
        if (!quest->IsRewChoiceItemValid(reward))
            return false;

        count = quest->GetRewChoiceItemCount(reward);
    }

    if (count)
    {
        ItemPosCountVec dest;
        InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, reward, count);
        if (res != EQUIP_ERR_OK)
        {
            SendEquipError(res, NULL, NULL, reward);
            return false;
        }
    }

    return true;
}

void Player::AddQuestAndCheckCompletion(Quest const* quest, Object* questGiver)
{
    AddQuest(quest, questGiver);

    bool brokenQuest = sObjectMgr->IsBrokenQuest(quest->GetQuestId());

    if (CanCompleteQuest(quest->GetQuestId()) || brokenQuest)
        CompleteQuest(quest->GetQuestId(), brokenQuest, false);

    if (!questGiver)
        return;

    switch (questGiver->GetTypeId())
    {
        case TYPEID_UNIT:
            sScriptMgr->OnQuestAccept(this, (questGiver->ToCreature()), quest);
            questGiver->ToCreature()->AI()->sQuestAccept(this, quest);
            break;
        case TYPEID_ITEM:
        case TYPEID_CONTAINER:
        {
            Item* item = (Item*)questGiver;
            sScriptMgr->OnQuestAccept(this, item, quest);
            break;
        }
        case TYPEID_GAMEOBJECT:
            sScriptMgr->OnQuestAccept(this, questGiver->ToGameObject(), quest);
            questGiver->ToGameObject()->AI()->QuestAccept(this, quest);
            break;
        default:
            break;
    }
}

void Player::AddQuest(Quest const* quest, Object* questGiver)
{
    uint16 logSlot = FindQuestSlot(0);

    if (logSlot >= MAX_QUEST_LOG_SIZE) // Player does not have any free slot in the quest log
        return;

    uint32 questId = quest->GetQuestId();

    // if not exist then created with set uState == NEW and rewarded=false
    QuestStatusData& questStatusData = m_QuestStatus[questId];

    // check for repeatable quests status reset
    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
    questStatusData.Explored = false;

    for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
    {
        QuestObjective const* questObjective = *citr;
        if (questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP || questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG)
            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(questObjective->ObjectId))
                GetReputationMgr().SetVisible(factionEntry);

        // not all Quest Objective types need to be tracked, some such as reputation are handled/checked externally
        if (questObjective->Type == QUEST_OBJECTIVE_TYPE_CURRENCY
            || questObjective->Type == QUEST_OBJECTIVE_TYPE_SPELL
            || questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP
            || questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG
            || questObjective->Type == QUEST_OBJECTIVE_TYPE_MONEY
            || questObjective->Type == QUEST_OBJECTIVE_TYPE_AREATRIGGER)
            continue;

        m_questObjectiveStatus.emplace(questObjective->Id, uint32(0));
        m_questObjectiveStatusSave.emplace(questObjective->Id, true);
    }

    GiveQuestSourceItem(quest);
    AdjustQuestReqItemCount(quest, questStatusData);

    uint32 qtime = 0;
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        uint32 limittime = quest->GetLimitTime();

        // shared timed quest
        if (questGiver && questGiver->GetTypeId() == TYPEID_PLAYER)
            limittime = questGiver->ToPlayer()->getQuestStatusMap()[questId].Timer / IN_MILLISECONDS;

        AddTimedQuest(questId);
        questStatusData.Timer = limittime * IN_MILLISECONDS;
        qtime = static_cast<uint32>(time(NULL)) + limittime;
    }
    else
        questStatusData.Timer = 0;

    if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
    {
        pvpInfo.IsHostile = true;
        UpdatePvPState();
    }

    SetQuestSlot(logSlot, questId, qtime);

    m_QuestStatusSave[questId] = true;

    StartCriteria(CRITERIA_START_TYPE_QUEST, questId);

    if (questGiver) // script managment for every quest
    {
        switch (questGiver->GetTypeId())
        {
            case TYPEID_UNIT:
                sScriptMgr->OnQuestAccept(this, (questGiver->ToCreature()), quest);
                break;
            case TYPEID_ITEM:
            case TYPEID_CONTAINER:
                {
                    Item* item = (Item*)questGiver;
                    sScriptMgr->OnQuestAccept(this, item, quest);
                    break;
                }
            case TYPEID_GAMEOBJECT:
                sScriptMgr->OnQuestAccept(this, questGiver->ToGameObject(), quest);
                break;
            default:
                break;
        }
    }

    SendQuestUpdate(questId);

    sScriptMgr->OnPlayerQuestAdded(this, quest);
}

void Player::CompleteQuest(uint32 quest_id, bool completely, bool fromCommand)
{
    if (quest_id && completely)
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
        if (!quest)
            return;

        for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
        {
            QuestObjective const* questObjective = *citr;
            if (!questObjective)
                continue;

            switch (questObjective->Type)
            {
                case QUEST_OBJECTIVE_TYPE_NPC:
                {
                    if (CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(questObjective->ObjectId))
                        for (uint32 i = 0; i < uint32(questObjective->Amount); i++)
                            KilledMonster(creatureInfo, 0);
                    break;
                }
                case QUEST_OBJECTIVE_TYPE_GO:
                {
                    if (GameObjectTemplate const* goInfo = sObjectMgr->GetGameObjectTemplate(questObjective->ObjectId))
                        for (uint32 i = 0; i < uint32(questObjective->Amount); i++)
                            KillCreditGO(goInfo->entry, 0);
                    break;
                }
                case QUEST_OBJECTIVE_TYPE_ITEM:
                {
                    bool valid = true;
                    if (!fromCommand) // prevent possible exploits for players
                    {
                        ItemTemplate const* item = sObjectMgr->GetItemTemplate(questObjective->ObjectId);
                        if (!item)
                            continue;

                        if (item->Quality > ITEM_QUALITY_NORMAL)
                            valid = false;

                        if (item->SellPrice > 0)
                            valid = false;
                    }

                    if (valid)
                    {
                        ItemPosCountVec dest;
                        uint32 currentCounter = GetItemCount(questObjective->ObjectId, true);

                        uint8 msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, questObjective->ObjectId, uint32(questObjective->Amount) - currentCounter);
                        if (msg == EQUIP_ERR_OK)
                        {
                            Item* item = StoreNewItem(dest, questObjective->ObjectId, true);
                            if (item)
                            {
                                SendNewItem(item, uint32(questObjective->Amount) - currentCounter, true, false);
                                sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::Command, GetGUIDLow());
                            }
                        }
                        SendQuestUpdateAddCredit(quest, questObjective, ObjectGuid(0), currentCounter, uint32(questObjective->Amount) - currentCounter);
                    }
                    break;
                }
                case QUEST_OBJECTIVE_TYPE_FACTION_REP:
                case QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG:
                {
                    if (fromCommand) // see above
                        if (GetReputationMgr().GetReputation(questObjective->ObjectId) < questObjective->Amount)
                            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(questObjective->ObjectId))
                                GetReputationMgr().SetReputation(factionEntry, questObjective->Amount);
                    break;
                }
                case QUEST_OBJECTIVE_TYPE_MONEY:
                {
                    if (fromCommand) // see above
                        ModifyMoney(uint64(questObjective->Amount));
                    break;
                }
                default:
                    break;
            }
        }
    }

    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_COMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
        {
            if (qInfo->HasFlag(QUEST_FLAGS_TRACKING))
                RewardQuest(qInfo, 0, this, false);
            else
                SendQuestComplete(qInfo);

            sScriptMgr->OnPlayerQuestCompleted(this, qInfo);
        }
    }
}

void Player::IncompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_INCOMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            RemoveQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
    }
}

void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver, bool announce)
{
    //this THING should be here to protect code from quest, which cast on player far teleport as a reward
    //should work fine, cause far teleport will be executed in Player::Update()
    SetCanDelayTeleport(true);

    uint32 quest_id = quest->GetQuestId();

    for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
    {
        QuestObjective const* questObjective = *citr;
        switch (questObjective->Type)
        {
            case QUEST_OBJECTIVE_TYPE_ITEM:
            {
                DestroyItemCount(questObjective->ObjectId, questObjective->Amount, true);
                break;
            }
            case QUEST_OBJECTIVE_TYPE_CURRENCY:
            {
                if (GetMap() && GetMap()->GetDifficulty() == SCENARIO_DIFFICULTY_HEROIC) // this cause decrease VP by value that more than int32 data, not required for it.
                    break;

                ModifyCurrency(questObjective->ObjectId, -int32(questObjective->Amount));
                break;
            }
            case QUEST_OBJECTIVE_TYPE_MONEY:
            {
                ModifyMoney(-int64(questObjective->Amount));
                break;
            }
            default:
                break;
        }
    }

    for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
    {
        if (quest->RequiredSourceItemId[i])
        {
            uint32 count = quest->RequiredSourceItemCount[i];
            DestroyItemCount(quest->RequiredSourceItemId[i], count ? count : 9999, true);
        }
    }

    RemoveTimedQuest(quest_id);

    uint32 itemsCount = 0;
    if (uint32 packageId = quest->GetRewardPackageItemId())
        GetQuestRewardItemCountFromPackage(reward, packageId, itemsCount);
    else if (quest->GetRewChoiceItemsCount() > 0)
        itemsCount = quest->GetRewChoiceItemCount(reward);

    if (itemsCount)
    {
        ItemPosCountVec dest;
        if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, reward, itemsCount) == EQUIP_ERR_OK)
        {
            Item* item = StoreNewItem(dest, reward, true, Item::GenerateItemRandomPropertyId(reward));
            SendNewItem(item, quest->GetRewChoiceItemCount(reward), true, false);
            sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::QuestReward, quest->GetQuestId());
        }
    }

    if (quest->GetRewItemsCount() > 0)
    {
        for (uint32 i = 0; i < quest->GetRewItemsCount(); ++i)
        {
            if (uint32 itemId = quest->RewardItemId[i])
            {
                uint32 count = quest->RewardItemIdCount[i];

                // Increase reward for premium players
                if (i == 0 && quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST))
                    if (projectMemberInfo* info = GetSession()->GetprojectMemberInfo())
                        count += info->GetPremiumQuestRewardBonus(quest) + info->GetVotingQuestRewardBonus(quest);

                ItemPosCountVec dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count) == EQUIP_ERR_OK)
                {
                    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
                    SendNewItem(item, count, true, false);
                    sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::QuestReward, quest->GetQuestId());
                }
                else
                {
                    // FIXME, will send mail
                    Item* item = Item::CreateItem(itemId, count, this);
                    StoreNewItem(item);
                }
            }
        }
    }

    for (uint8 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
        if (quest->RewardCurrencyId[i])
        {
            CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(quest->RewardCurrencyId[i]);
            if (!currency)
                return;

            uint8 precision = currency->Flags & CURRENCY_FLAG_HIGH_PRECISION ? CURRENCY_PRECISION : 1;

            ModifyCurrency(currency->ID, quest->RewardCurrencyCount[i] * precision);
        }

    if (uint32 skill = quest->GetRewardSkillId())
        UpdateSkillPro(skill, 1000, quest->GetRewardSkillPoints());

    RewardReputation(quest);

    uint16 log_slot = FindQuestSlot(quest_id);
    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlot(log_slot, 0);

    // Not give XP in case already completed once repeatable quest
    uint32 XP = IsQuestRewarded(quest_id) ? 0 : uint32(quest->XPValue(this) * sWorld->getRate(RATE_XP_QUEST, this));

    // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
    Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
    for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
        AddPct(XP, (*i)->GetAmount());

    if (getLevel() < quest->GetQuestLevel() + 9) // I dunno how to detect a gray quest better...
    {
        if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
        {
            // Fixed value for any non grey quests.
            uint32 experience = 60000;
            guild->GiveXP(experience, this);
            guild->RewardReputation(this, experience / 360.0f);
        }
    }

    int32 moneyRew = quest->GetRewardOrRequiredMoney();
    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        GiveXP(XP, NULL);
    else
    {
        if (moneyRew > 0)
            moneyRew = std::max(moneyRew, int32(quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY)));
        else
            moneyRew += quest->GetRewMoneyMaxLevel();
    }

    if (moneyRew)
    {
        ModifyMoney(moneyRew);
        logs::CurrencyTransaction(this, CurrencyOperation::QuerstReward, quest_id, moneyRew);
    }

    if (moneyRew > 0)
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_MONEY_FROM_QUEST_REWARD, uint32(moneyRew));

    // honor reward
    if (uint32 honor = quest->CalculateHonorGain(getLevel()))
        RewardHonor(NULL, 0, honor);

    // title reward
    if (quest->GetCharTitleId())
    {
        if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
            SetTitle(titleEntry);
    }

    // Send reward mail
    if (uint32 mail_template_id = quest->GetRewMailTemplateId())
    {
        /// @todo Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft(mail_template_id).SendMailTo(trans, this, questGiver, MAIL_CHECK_MASK_HAS_BODY, quest->GetRewMailDelaySecs());
        CharacterDatabase.CommitTransaction(trans);
    }

    if (quest->IsDaily() && !quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST) || quest->IsDFQuest())
    {
        SetDailyQuestStatus(quest_id);
        if (quest->IsDaily())
        {
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, quest_id);
        }
    }
    else if (quest->IsWeekly())
        SetWeeklyQuestStatus(quest_id);
    else if (quest->IsMonthly())
        SetMonthlyQuestStatus(quest_id);
    else if (quest->IsSeasonal())
        SetSeasonalQuestStatus(quest_id);

    RemoveActiveQuest(quest_id, false);
    m_RewardedQuests.insert(quest_id);
    m_RewardedQuestsSave[quest_id] = true;

    PhaseUpdateData phaseUpdateData;
    phaseUpdateData.AddQuestUpdate(quest_id);
    phaseMgr.NotifyConditionChanged(phaseUpdateData);

    // StoreNewItem, mail reward, etc. save data directly to the database
    // to prevent exploitable data desynchronisation we save the quest status to the database too
    // (to prevent rewarding this quest another time while rewards were already given out)
    SQLTransaction trans = SQLTransaction(NULL);
    _SaveQuestStatus(trans);

    if (announce)
        SendQuestReward(quest, XP);

    // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
    if (quest->GetRewSpellCast() > 0)
        CastSpell(this, quest->GetRewSpellCast(), true);
    else if (quest->GetRewSpell() > 0)
        CastSpell(this, quest->GetRewSpell(), true);

    if (!quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST))
    {
        if (quest->GetZoneOrSort() > 0)
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_IN_ZONE, quest->GetZoneOrSort());
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST_COUNT);
        UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUEST, quest->GetQuestId());
        if (Guild* guild = GetGuild())
            guild->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_QUESTS_GUILD, 0, 0, 0, this, this);
    }

    if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
    {
        _completedQuestBits.set(questBit - 1);

        WorldPacket data(SMSG_SET_QUEST_COMPLETED_BIT, 4);
        data << uint32(questBit);
        SendDirectMessage(&data);
    }

    SendQuestUpdate(quest_id);

    if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
    {
        pvpInfo.IsHostile = pvpInfo.IsInHostileArea || HasPvPForcingQuest();
        UpdatePvPState();
    }

    UpdateForQuestWorldObjects();

    //lets remove flag for delayed teleports
    SetCanDelayTeleport(false);

    sScriptMgr->OnPlayerQuestRewarded(this, quest);

    SetSaveTimer(1);

    if (sWorld->AreprojectDailyQuestsEnabled())
    {
        if (!quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST))
            CreditprojectDailyQuest(180018); // project Daily Quest Credit - Quest Completed
        else if (projectMemberInfo* info = GetSession()->GetprojectMemberInfo())
            info->Notify(this, projectMemberInfo::Notification::QuestComplete);
    }
}

void Player::FailQuest(uint32 questId)
{
    if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
    {
        SetQuestStatus(questId, QUEST_STATUS_FAILED);

        uint16 log_slot = FindQuestSlot(questId);

        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotTimer(log_slot, 1);
            SetQuestSlotState(log_slot, QUEST_STATE_FAIL);
        }

        if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
        {
            QuestStatusData& q_status = m_QuestStatus[questId];

            RemoveTimedQuest(questId);
            q_status.Timer = 0;

            SendQuestTimerFailed(questId);
        }
        else
            SendQuestFailed(questId);

        DestroyQuestItems(questId);

        sScriptMgr->OnPlayerQuestFailed(this, quest);
    }
}

bool Player::SatisfyQuestSkill(Quest const* qInfo, bool msg) const
{
    uint32 skill = qInfo->GetRequiredSkill();

    // skip 0 case RequiredSkill
    if (skill == 0)
        return true;

    // check skill value
    if (GetSkillValue(skill) < qInfo->GetRequiredSkillValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestSkill: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required skill value.", qInfo->GetQuestId());
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestLevel(Quest const* qInfo, bool msg)
{
    if (getLevel() < qInfo->GetMinLevel())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_LOW_LEVEL);
            TC_LOG_DEBUG("misc", "SatisfyQuestLevel: Sent INVALIDREASON_QUEST_FAILED_LOW_LEVEL (questId: %u) because player does not have required (min) level.", qInfo->GetQuestId());
        }
        return false;
    }
    else if (qInfo->GetMaxLevel() > 0 && getLevel() > qInfo->GetMaxLevel())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ); // There doesn't seem to be a specific response for too high player level
            TC_LOG_DEBUG("misc", "SatisfyQuestLevel: Sent INVALIDREASON_QUEST_FAILED_LOW_LEVEL (questId: %u) because player does not have required (max) level.", qInfo->GetQuestId());
        }
        return false;
    }
    return true;
}

bool Player::SatisfyQuestLog(bool msg)
{
    // exist free slot
    if (FindQuestSlot(0) < MAX_QUEST_LOG_SIZE)
        return true;

    if (msg)
    {
        WorldPacket data(SMSG_QUESTLOG_FULL, 0);
        GetSession()->SendPacket(&data);
        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTLOG_FULL");
    }
    return false;
}

bool Player::SatisfyQuestPreviousQuest(Quest const* qInfo, bool msg)
{
    // No previous quest (might be first quest in a series)
    if (qInfo->prevQuests.empty())
        return true;

    for (Quest::PrevQuests::const_iterator iter = qInfo->prevQuests.begin(); iter != qInfo->prevQuests.end(); ++iter)
    {
        uint32 prevId = abs(*iter);

        Quest const* qPrevInfo = sObjectMgr->GetQuestTemplate(prevId);

        if (qPrevInfo)
        {
            // If any of the positive previous quests completed, return true
            if (*iter > 0 && IsQuestRewarded(prevId))
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group completed and rewarded
                ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qPrevInfo->GetExclusiveGroup()));

                for (; range.first != range.second; ++range.first)
                {
                    uint32 exclude_Id = range.first->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be completed and rewarded (reported)
                    if (!IsQuestRewarded(exclude_Id))
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                            TC_LOG_DEBUG("misc", "SatisfyQuestPreviousQuest: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required quest (1).", qInfo->GetQuestId());
                        }
                        return false;
                    }
                }
                return true;
            }

            // If any of the negative previous quests active, return true
            if (*iter < 0 && GetQuestStatus(prevId) != QUEST_STATUS_NONE)
            {
                // skip one-from-all exclusive group
                if (qPrevInfo->GetExclusiveGroup() >= 0)
                    return true;

                // each-from-all exclusive group (< 0)
                // can be start if only all quests in prev quest exclusive group active
                ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qPrevInfo->GetExclusiveGroup()));

                for (; range.first != range.second; ++range.first)
                {
                    uint32 exclude_Id = range.first->second;

                    // skip checked quest id, only state of other quests in group is interesting
                    if (exclude_Id == prevId)
                        continue;

                    // alternative quest from group also must be active
                    if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE)
                    {
                        if (msg)
                        {
                            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                            TC_LOG_DEBUG("misc", "SatisfyQuestPreviousQuest: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required quest (2).", qInfo->GetQuestId());

                        }
                        return false;
                    }
                }
                return true;
            }
        }
    }

    // Has only positive prev. quests in non-rewarded state
    // and negative prev. quests in non-active state
    if (msg)
    {
        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
        TC_LOG_DEBUG("misc", "SatisfyQuestPreviousQuest: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required quest (3).", qInfo->GetQuestId());
    }

    return false;
}

bool Player::SatisfyQuestClass(Quest const* qInfo, bool msg) const
{
    uint32 reqClass = qInfo->GetRequiredClasses();

    if (reqClass == 0)
        return true;

    if ((reqClass & getClassMask()) == 0)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestClass: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required class.", qInfo->GetQuestId());
        }

        return false;
    }

    return true;
}

bool Player::SatisfyQuestRace(Quest const* qInfo, bool msg)
{
    uint32 reqraces = qInfo->GetRequiredRaces();
    if (reqraces == 0)
        return true;
    if ((reqraces & getRaceMask()) == 0)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_WRONG_RACE);
            TC_LOG_DEBUG("misc", "SatisfyQuestRace: Sent INVALIDREASON_QUEST_FAILED_WRONG_RACE (questId: %u) because player does not have required race.", qInfo->GetQuestId());

        }
        return false;
    }
    return true;
}

bool Player::SatisfyQuestReputation(Quest const* qInfo, bool msg)
{
    uint32 fIdMin = qInfo->GetRequiredMinRepFaction();      //Min required rep
    if (fIdMin && GetReputationMgr().GetReputation(fIdMin) < qInfo->GetRequiredMinRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestReputation: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required reputation (min).", qInfo->GetQuestId());
        }
        return false;
    }

    uint32 fIdMax = qInfo->GetRequiredMaxRepFaction();      //Max required rep
    if (fIdMax && GetReputationMgr().GetReputation(fIdMax) >= qInfo->GetRequiredMaxRepValue())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestReputation: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required reputation (max).", qInfo->GetQuestId());
        }
        return false;
    }

    // ReputationObjective2 does not seem to be an objective requirement but a requirement
    // to be able to accept the quest

    if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG))
        return true;

    for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
    {
        QuestObjective const* questObjective = *citr;
        if (questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG && GetReputationMgr().GetReputation(questObjective->ObjectId) >= questObjective->Amount)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                TC_LOG_DEBUG("misc", "SatisfyQuestReputation: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required reputation (ReputationObjective2).", qInfo->GetQuestId());
            }

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestStatus(Quest const* qInfo, bool msg)
{
    if (GetQuestStatus(qInfo->GetQuestId()) != QUEST_STATUS_NONE)
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ALREADY_ON);
            TC_LOG_DEBUG("misc", "SatisfyQuestStatus: Sent INVALIDREASON_QUEST_ALREADY_ON (questId: %u) because player quest status is not NONE.", qInfo->GetQuestId());
        }
        return false;
    }
    return true;
}

bool Player::SatisfyQuestConditions(Quest const* qInfo, bool msg)
{
    ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, qInfo->GetQuestId());
    if (!sConditionMgr->IsObjectMeetToConditions(this, conditions))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestConditions: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not meet conditions.", qInfo->GetQuestId());
        }
        TC_LOG_DEBUG("condition", "Player::SatisfyQuestConditions: conditions not met for quest %u", qInfo->GetQuestId());
        return false;
    }
    return true;
}

bool Player::SatisfyQuestTimed(Quest const* qInfo, bool msg)
{
    if (!m_timedquests.empty() && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ONLY_ONE_TIMED);
            TC_LOG_DEBUG("misc", "SatisfyQuestTimed: Sent INVALIDREASON_QUEST_ONLY_ONE_TIMED (questId: %u) because player is already on a timed quest.", qInfo->GetQuestId());
        }
        return false;
    }
    return true;
}

bool Player::SatisfyQuestExclusiveGroup(Quest const* qInfo, bool msg)
{
    // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
    if (qInfo->GetExclusiveGroup() <= 0)
        return true;

    ObjectMgr::ExclusiveQuestGroupsBounds range(sObjectMgr->mExclusiveQuestGroups.equal_range(qInfo->GetExclusiveGroup()));

    for (; range.first != range.second; ++range.first)
    {
        uint32 exclude_Id = range.first->second;

        // skip checked quest id, only state of other quests in group is interesting
        if (exclude_Id == qInfo->GetQuestId())
            continue;

        // not allow have daily quest if daily quest from exclusive group already recently completed
        Quest const* Nquest = sObjectMgr->GetQuestTemplate(exclude_Id);
        if (!SatisfyQuestDay(Nquest, false) || !SatisfyQuestWeek(Nquest, false) || !SatisfyQuestSeasonal(Nquest, false))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                TC_LOG_DEBUG("misc", "SatisfyQuestExclusiveGroup: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player already did daily quests in exclusive group.", qInfo->GetQuestId());
            }

            return false;
        }

        // alternative quest already started or completed - but don't check rewarded states if both are repeatable
        if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE || (!(qInfo->IsRepeatable() && Nquest->IsRepeatable()) && (m_RewardedQuests.find(exclude_Id) != m_RewardedQuests.end())))
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                TC_LOG_DEBUG("misc", "SatisfyQuestExclusiveGroup: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player already did quest in exclusive group.", qInfo->GetQuestId());
            }
            return false;
        }
    }
    return true;
}

bool Player::SatisfyQuestNextChain(Quest const* qInfo, bool msg)
{
    uint32 nextQuest = qInfo->GetNextQuestInChain();
    if (!nextQuest)
        return true;

    if (qInfo->IsRepeatable())
        return true;

    // next quest in chain already started or completed
    if (GetQuestStatus(nextQuest) != QUEST_STATUS_NONE) // GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
            TC_LOG_DEBUG("misc", "SatisfyQuestNextChain: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player already did or started next quest in chain.", qInfo->GetQuestId());
        }
        return false;
    }

    // check for all quests further up the chain
    // only necessary if there are quest chains with more than one quest that can be skipped
    //return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
    return true;
}

bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
{
    // No previous quest in chain
    if (qInfo->prevChainQuests.empty())
        return true;

    for (Quest::PrevChainQuests::const_iterator iter = qInfo->prevChainQuests.begin(); iter != qInfo->prevChainQuests.end(); ++iter)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(*iter);

        // If any of the previous quests in chain active, return false
        if (itr != m_QuestStatus.end() && itr->second.Status != QUEST_STATUS_NONE)
        {
            if (msg)
            {
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ);
                TC_LOG_DEBUG("misc", "SatisfyQuestNextChain: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player already did or started next quest in chain.", qInfo->GetQuestId());
            }
            return false;
        }

        // check for all quests further down the chain
        // only necessary if there are quest chains with more than one quest that can be skipped
        //if (!SatisfyQuestPrevChain(prevId, msg))
        //    return false;
    }

    // No previous quest in chain active
    return true;
}

bool Player::SatisfyQuestDay(Quest const* qInfo, bool msg)
{
    if (!qInfo->IsDaily() && !qInfo->IsDFQuest())
        return true;

    if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST))
    {
        if (!sWorld->AreprojectDailyQuestsEnabled())
            return false;

        // Skip native daily quest limit check
        projectMemberInfo* info = GetSession()->GetprojectMemberInfo();
        if (!info || !info->CanCompleteMoreDailyQuests())
            return false;

        if (info->CompletedDailyQuestExclusiveGroups.find(qInfo->GetExclusiveGroup()) != info->CompletedDailyQuestExclusiveGroups.end())
            return false;

        return true;
    }

    return m_dailyquests.find(qInfo->GetQuestId()) == m_dailyquests.end();
}

bool Player::SatisfyQuestWeek(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsWeekly() || m_weeklyquests.empty())
        return true;

    // if not found in cooldown list
    return m_weeklyquests.find(qInfo->GetQuestId()) == m_weeklyquests.end();
}

bool Player::SatisfyQuestSeasonal(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsSeasonal() || m_seasonalquests.empty())
        return true;

    uint16 eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
    if (m_seasonalquests.find(eventId) == m_seasonalquests.end() || m_seasonalquests[eventId].empty())
        return true;

    // if not found in cooldown list
    return m_seasonalquests[eventId].find(qInfo->GetQuestId()) == m_seasonalquests[eventId].end();
}

bool Player::SatisfyQuestMonth(Quest const* qInfo, bool /*msg*/)
{
    if (!qInfo->IsMonthly() || m_monthlyquests.empty())
        return true;

    // if not found in cooldown list
    return m_monthlyquests.find(qInfo->GetQuestId()) == m_monthlyquests.end();
}

bool Player::GiveQuestSourceItem(Quest const* quest)
{
    uint32 srcitem = quest->GetSrcItemId();
    if (srcitem > 0)
    {
        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, srcitem, QUEST_SOURCE_ITEM_COUNT);
        if (msg == EQUIP_ERR_OK)
        {
            Item* item = StoreNewItem(dest, srcitem, true);
            SendNewItem(item, QUEST_SOURCE_ITEM_COUNT, true, false);
            sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::QuestSource, quest->GetQuestId());
            return true;
        }
        // player already have max amount required item, just report success
        else if (msg == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        else
            SendEquipError(msg, NULL, NULL, srcitem);
        return false;
    }

    return true;
}

bool Player::TakeQuestSourceItem(uint32 questId, bool msg)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
    if (quest)
    {
        uint32 srcItemId = quest->GetSrcItemId();
        ItemTemplate const* item = sObjectMgr->GetItemTemplate(srcItemId);

        if (srcItemId > 0)
        {
            // exist two cases when destroy source quest item not possible:
            // a) non un-equippable item (equipped non-empty bag, for example)
            // b) when quest is started from an item and item also is needed in
            // the end as RequiredItemId
            InventoryResult res = CanUnequipItems(srcItemId, QUEST_SOURCE_ITEM_COUNT);
            if (res != EQUIP_ERR_OK)
            {
                if (msg)
                    SendEquipError(res, NULL, NULL, srcItemId);
                return false;
            }

            bool destroyItem = true;
            if (item && item->StartQuest == questId)
                for (auto&& objective : quest->m_questObjectives)
                    if (objective->Type == QUEST_OBJECTIVE_TYPE_ITEM  && srcItemId == objective->ObjectId)
                        destroyItem = false;

            if (destroyItem)
                DestroyItemCount(srcItemId, QUEST_SOURCE_ITEM_COUNT, true, true);
        }
    }

    return true;
}

bool Player::GetQuestRewardStatus(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (qInfo)
    {
        // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
        if (!qInfo->IsRepeatable())
            return IsQuestRewarded(quest_id);

        return false;
    }
    return false;
}

QuestStatus Player::GetQuestStatus(uint32 quest_id) const
{
    if (quest_id)
    {
        QuestStatusMap::const_iterator itr = m_QuestStatus.find(quest_id);
        if (itr != m_QuestStatus.end())
            return itr->second.Status;

        if (Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id))
            if (!qInfo->IsRepeatable() && IsQuestRewarded(quest_id))
                return QUEST_STATUS_REWARDED;
    }
    return QUEST_STATUS_NONE;
}

bool Player::CanShareQuest(uint32 quest_id) const
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    return qInfo && qInfo->HasFlag(QUEST_FLAGS_SHARABLE) && IsActiveQuest(quest_id);
}

void Player::SetQuestStatus(uint32 quest_id, QuestStatus status, bool update /*= true*/)
{
    if (sObjectMgr->GetQuestTemplate(quest_id))
    {
        m_QuestStatus[quest_id].Status = status;
        m_QuestStatusSave[quest_id] = true;
    }

    PhaseUpdateData phaseUpdateData;
    phaseUpdateData.AddQuestUpdate(quest_id);

    phaseMgr.NotifyConditionChanged(phaseUpdateData);

    /*uint32 zone = 0, area = 0;

    SpellAreaForQuestMapBounds saBounds = sSpellMgr->GetSpellAreaForQuestMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
            if (itr->second->autocast && itr->second->IsFitToRequirements(this, zone, area))
                if (!HasAura(itr->second->spellId))
                    CastSpell(this, itr->second->spellId, true);
    }

    saBounds = sSpellMgr->GetSpellAreaForQuestEndMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        if (!zone || !area)
            GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
            if (!itr->second->IsFitToRequirements(this, zone, area))
                RemoveAurasDueToSpell(itr->second->spellId);
    }*/

    if (update)
        SendQuestUpdate(quest_id);
}

void Player::RemoveActiveQuest(uint32 quest_id, bool update /*= true*/, bool /*removeFromQuestLog = false*/)
{
    QuestStatusMap::iterator itr = m_QuestStatus.find(quest_id);
    if (itr != m_QuestStatus.end())
    {
        if (auto questTemplate = sObjectMgr->GetQuestTemplate(quest_id))
        {
            for (auto&& it : questTemplate->m_questObjectives)
            {
                m_questObjectiveStatus.erase(it->Id);
                m_questObjectiveStatusSave[it->Id] = false;
            }
        }

        m_QuestStatus.erase(itr);
        m_QuestStatusSave[quest_id] = false;

        PhaseUpdateData phaseUpdateData;
        phaseUpdateData.AddQuestUpdate(quest_id);

        phaseMgr.NotifyConditionChanged(phaseUpdateData);

        sScriptMgr->OnPlayerQuestAbandoned(this, sObjectMgr->GetQuestTemplate(quest_id));
    }

    if (update)
        SendQuestUpdate(quest_id);
}

void Player::RemoveRewardedQuest(uint32 quest_id, bool update /*= true*/)
{
    RewardedQuestSet::iterator rewItr = m_RewardedQuests.find(quest_id);
    if (rewItr != m_RewardedQuests.end())
    {
        m_RewardedQuests.erase(rewItr);
        m_RewardedQuestsSave[quest_id] = false;

        PhaseUpdateData phaseUpdateData;
        phaseUpdateData.AddQuestUpdate(quest_id);

        phaseMgr.NotifyConditionChanged(phaseUpdateData);
    }

    if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
    {
        _completedQuestBits.reset(questBit - 1);

        WorldPacket data(SMSG_CLEAR_QUEST_COMPLETED_BIT, 4);
        data << uint32(questBit);
        SendDirectMessage(&data);
    }

    if (update)
        SendQuestUpdate(quest_id);
}

void Player::SendQuestUpdate(uint32 questId)
{
    uint32 zone = 0, area = 0;

    GetZoneAndAreaId(zone, area);
    UpdateZoneDependentAuras(zone);
    UpdateAreaDependentAuras(area);
    UpdateForQuestWorldObjects();
}

void Player::DestroyQuestItems(uint32 questId)
{
    if (Quest const* quest = sObjectMgr->GetQuestTemplate(questId))
    {
        // Destroy quest items on quest fail or abandon.
        for (auto&& objective : quest->m_questObjectives)
            if (objective->Type == QUEST_OBJECTIVE_TYPE_ITEM)
                DestroyItemCount(objective->ObjectId, objective->Amount, true, true);

        // Destroy items received during the quest.
        for (uint8 i = 0; i < QUEST_SOURCE_ITEM_IDS_COUNT; ++i)
            if (quest->RequiredSourceItemId[i]  && quest->RequiredSourceItemCount[i] && sObjectMgr->GetItemTemplate(quest->RequiredSourceItemId[i])->Bonding == BIND_QUEST_ITEM)
                DestroyItemCount(quest->RequiredSourceItemId[i], quest->RequiredSourceItemCount[i], true, true);
    }
}

// not used in Trinity, but used in scripting code
uint16 Player::GetReqKillOrCastCurrentCount(uint32 quest_id, int32 entry)
{
    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (!qInfo)
        return 0;

    if (qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
            if ((*citr)->Type == QUEST_OBJECTIVE_TYPE_NPC && (*citr)->ObjectId == entry)
                return GetQuestObjectiveCounter((*citr)->Id);

    return 0;
}

void Player::AdjustQuestReqItemCount(Quest const* quest, QuestStatusData& questStatusData)
{
    if (!quest->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
        return;

    for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
    {
        QuestObjective const* questObjective = *citr;
        if (questObjective->Type == QUEST_OBJECTIVE_TYPE_ITEM)
        {
            m_questObjectiveStatus[questObjective->Id] = std::min(GetItemCount(questObjective->ObjectId, true), uint32(questObjective->Amount));
            MarkQuestObjectiveToSave(quest->GetQuestId(), questObjective->Id);
        }
    }
}

uint16 Player::FindQuestSlot(uint32 quest_id) const
{
    for (uint16 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
        if (GetQuestSlotQuestId(i) == quest_id)
            return i;

    return MAX_QUEST_LOG_SIZE;
}

uint32 Player::GetQuestSlotQuestId(uint16 slot) const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_ID_OFFSET);
}

uint32 Player::GetQuestSlotState(uint16 slot)   const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET);
}

uint16 Player::GetQuestSlotCounter(uint16 slot, uint8 counter) const
{
    if (counter < MAX_QUEST_COUNTS)
        return GetUInt16Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + counter / 2, counter % 2);
    return 0;
}

uint32 Player::GetQuestSlotTime(uint16 slot) const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET);
}

void Player::SetQuestSlot(uint16 slot, uint32 quest_id, uint32 timer /*= 0*/)
{
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_ID_OFFSET, quest_id);
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, 0);
    for (uint32 i = 0; i < MAX_QUEST_COUNTS / 2; ++i)
        SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + i, 0);
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET, timer);
}

void Player::SetQuestSlotCounter(uint16 slot, uint8 counter, uint16 count)
{
    if (counter >= MAX_QUEST_COUNTS)
        return;

    SetUInt16Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + counter / 2, counter % 2, count);
}

void Player::SetQuestSlotState(uint16 slot, uint32 state)
{
    SetFlag(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, state);
}

void Player::RemoveQuestSlotState(uint16 slot, uint32 state)
{
    RemoveFlag(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, state);
}

void Player::SetQuestSlotTimer(uint16 slot, uint32 timer)
{
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET, timer);
}

void Player::SwapQuestSlot(uint16 slot1, uint16 slot2)
{
    for (int i = 0; i < MAX_QUEST_OFFSET; ++i)
    {
        uint32 temp1 = GetUInt32Value(PLAYER_FIELD_QUEST_LOG + MAX_QUEST_OFFSET * slot1 + i);
        uint32 temp2 = GetUInt32Value(PLAYER_FIELD_QUEST_LOG + MAX_QUEST_OFFSET * slot2 + i);

        SetUInt32Value(PLAYER_FIELD_QUEST_LOG + MAX_QUEST_OFFSET * slot1 + i, temp2);
        SetUInt32Value(PLAYER_FIELD_QUEST_LOG + MAX_QUEST_OFFSET * slot2 + i, temp1);
    }
}

void Player::AreaExploredOrEventHappens(uint32 questId)
{
    if (questId)
    {
        uint16 log_slot = FindQuestSlot(questId);
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            QuestStatusData& q_status = m_QuestStatus[questId];

            if (!q_status.Explored)
            {
                q_status.Explored = true;
                m_QuestStatusSave[questId] = true;
            }
        }

        if (CanCompleteQuest(questId))
            CompleteQuest(questId);
    }
}

//not used in Trinityd, function for external script library
void Player::GroupEventHappens(uint32 questId, WorldObject const* pEventObject)
{
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* player = itr->GetSource();

            // for any leave or dead (with not released body) group member at appropriate distance
            if (player && player->IsAtGroupRewardDistance(pEventObject) && !player->GetCorpse())
                player->AreaExploredOrEventHappens(questId);
        }
    }
    else
        AreaExploredOrEventHappens(questId);
}

void Player::ItemAddedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questid];
        if (questStatus.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
            continue;

        for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
        {
            QuestObjective const* questObjective = *citr;
            if (questObjective->Type == QUEST_OBJECTIVE_TYPE_ITEM && questObjective->ObjectId == entry)
            {
                uint32 currentCounter = GetQuestObjectiveCounter(questObjective->Id);
                uint32 requiredCounter = uint32(questObjective->Amount);

                if (currentCounter < requiredCounter)
                {
                    uint16 addCount = currentCounter + count <= requiredCounter ? count : requiredCounter - currentCounter;
                    m_questObjectiveStatus[questObjective->Id] += addCount;
                    MarkQuestObjectiveToSave(questid, questObjective->Id);

                    SendQuestUpdateAddCredit(qInfo, questObjective, ObjectGuid(0), currentCounter, addCount);
                }

                if (CanCompleteQuest(questid))
                    CompleteQuest(questid);

                return;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::ItemRemovedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questid];

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_ITEM))
            continue;

        for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
        {
            QuestObjective const* questObjective = *citr;
            if (questObjective->Type == QUEST_OBJECTIVE_TYPE_ITEM && questObjective->ObjectId == entry)
            {
                uint32 currentCounter = questStatus.Status != QUEST_STATUS_COMPLETE ? GetQuestObjectiveCounter(questObjective->Id) : GetItemCount(entry, true);
                uint32 requiredCounter = uint32(questObjective->Amount);

                if (currentCounter < requiredCounter)
                {
                    uint16 remainingItems = currentCounter <= requiredCounter ? count : count + requiredCounter - currentCounter;

                    m_questObjectiveStatus[questObjective->Id] = (currentCounter <= remainingItems) ? 0 : currentCounter - remainingItems;
                    MarkQuestObjectiveToSave(questid, questObjective->Id);
                    IncompleteQuest(questid);
                }

                break;
            }
        }
    }

    UpdateForQuestWorldObjects();
}

void Player::KilledMonster(CreatureTemplate const* cInfo, uint64 guid)
{
    ASSERT(cInfo);

    if (cInfo->Entry)
        KilledMonsterCredit(cInfo->Entry, guid);

    for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
        if (cInfo->KillCredit[i])
            KilledMonsterCredit(cInfo->KillCredit[i], 0);
}

void Player::KilledMonsterCredit(uint32 entry, uint64 guid /*= 0*/, uint32 count)
{
    // Siphon Essence
    if (entry == 54198)
    {
        switch (GetMap()->GetDifficulty())
        {
            case RAID_DIFFICULTY_10MAN_NORMAL:
                count = urand(4, 6);
                break;
            case RAID_DIFFICULTY_10MAN_HEROIC:
                count = urand(7, 8);
                break;
            case RAID_DIFFICULTY_25MAN_NORMAL:
                count = urand(7, 8);
                break;
            case RAID_DIFFICULTY_25MAN_HEROIC:
                count = urand(9, 11);
                break;
        }
    }

    uint32 realEntry = entry;
    Creature* killed = NULL;

    if (guid)
    {
        killed = GetMap()->GetCreature(guid);
        if (killed && killed->GetEntry())
            realEntry = killed->GetEntry();
    }

    StartCriteria(CRITERIA_START_TYPE_CREATURE, realEntry);   // MUST BE CALLED FIRST
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_KILL_CREATURE, realEntry, count, 0, killed);

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (!questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_NPC))
            continue;

        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& questStatus = m_QuestStatus[questId];
        if (questStatus.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficulty())))
        {
            for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
            {
                QuestObjective const* questObjective = *citr;
                if (questObjective->Type == QUEST_OBJECTIVE_TYPE_NPC && questObjective->ObjectId == realEntry)
                {
                    uint32 currentCounter = GetQuestObjectiveCounter(questObjective->Id);
                    if (currentCounter < uint32(questObjective->Amount))
                    {
                        uint32 addKillCount = count;
                        if ((uint32)currentCounter + addKillCount > uint32(questObjective->Amount))
                            addKillCount = uint32(questObjective->Amount) - currentCounter;

                        m_questObjectiveStatus[questObjective->Id] += addKillCount;
                        MarkQuestObjectiveToSave(questId, questObjective->Id);

                        SendQuestUpdateAddCredit(qInfo, questObjective, ObjectGuid(guid), currentCounter, addKillCount);

                        // Complete all objectives on completion of one
                        if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_project_DAILY_QUEST) && questObjective->Type == QUEST_OBJECTIVE_TYPE_NPC && GetQuestObjectiveCounter(questObjective->Id) >= uint32(questObjective->Amount))
                        {
                            for (auto&& objective2 : qInfo->m_questObjectives)
                            {
                                if (questObjective->Id == objective2->Id || !objective2->Amount)
                                    continue;

                                uint16 c = GetQuestObjectiveCounter(objective2->Id);
                                uint32 r = objective2->Amount;
                                if (c >= r)
                                    continue;

                                m_questObjectiveStatus[objective2->Id] = objective2->Amount;
                                SendQuestUpdateAddCredit(qInfo, objective2, ObjectGuid(guid), c, r - c);
                            }
                        }
                    }

                    if (CanCompleteQuest(questId))
                        CompleteQuest(questId);

                    break;
                }
            }
        }
    }
}

void Player::KilledPlayerCredit()
{
    uint16 addKillCount = 1;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (!questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_PLAYER))
            continue;

        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData& questStatus = m_QuestStatus[questId];
        if (questStatus.Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficulty())))
        {
            for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
            {
                QuestObjective const* questObjective = *citr;
                if (questObjective->Type == QUEST_OBJECTIVE_TYPE_PLAYER)
                {
                    uint32 currentCounter = GetQuestObjectiveCounter(questObjective->Id);
                    if (currentCounter < uint32(questObjective->Amount))
                    {
                        m_questObjectiveStatus[questObjective->ObjectId] = currentCounter + addKillCount;
                        MarkQuestObjectiveToSave(questId, questObjective->ObjectId);

                        SendQuestUpdateAddPlayer(qInfo, questObjective, currentCounter, addKillCount);
                    }

                    if (CanCompleteQuest(questId))
                        CompleteQuest(questId);

                    break;
                }
            }
        }
    }
}

void Player::KillCreditGO(uint32 entry, uint64 guid)
{
    // here to not break old scripts, this function should be removed at some point
    QuestObjectiveSatisfy(entry, 1, QUEST_OBJECTIVE_TYPE_GO, 0);
}

void Player::TalkedToCreature(uint32 entry, uint64 guid)
{
    // here to not break old scripts, this function should be removed at some point
    QuestObjectiveSatisfy(entry, 1, QUEST_OBJECTIVE_TYPE_NPC_INTERACT, guid);
}

void Player::MoneyChanged(uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (!questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_MONEY))
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];

        for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
        {
            QuestObjective const* questObjective = *citr;
            if (questObjective->Type == QUEST_OBJECTIVE_TYPE_MONEY)
            {
                if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (count >= uint32(questObjective->Amount))
                        if (CanCompleteQuest(questId))
                            CompleteQuest(questId);
                }
                else if (questStatus.Status == QUEST_STATUS_COMPLETE)
                {
                    if (count < uint32(questObjective->Amount))
                        IncompleteQuest(questId);
                }
            }
        }
    }
}

void Player::ReputationChanged(FactionEntry const* factionEntry)
{
    ReputationChangedQuestCheck(factionEntry);
}

void Player::ReputationChangedQuestCheck(FactionEntry const* factionEntry)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId)
            continue;

        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
        if (!qInfo)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];

        for (auto&& questObjective : qInfo->m_questObjectives)
        {
            // I'm not sure what this is needed
            if (questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP)
            {
                if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) >= questObjective->Amount)
                        if (CanCompleteQuest(questId))
                            CompleteQuest(questId);
                }
                else if (questStatus.Status == QUEST_STATUS_COMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) < questObjective->Amount)
                        IncompleteQuest(questId);
                }
            }
            else if (questObjective->Type == QUEST_OBJECTIVE_TYPE_FACTION_REP_NEG)
            {
                if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) <= questObjective->Amount)
                        if (CanCompleteQuest(questId))
                            CompleteQuest(questId);
                }
                else if (questStatus.Status == QUEST_STATUS_COMPLETE)
                {
                    if (GetReputationMgr().GetReputation(factionEntry) > questObjective->Amount)
                        IncompleteQuest(questId);
                }
            }
        }
    }
}

void Player::QuestObjectiveSatisfy(uint32 objectId, uint32 amount, uint8 type, uint64 guid)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (!questId)
            continue;

        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
        if (!quest)
            continue;

        QuestStatusData& questStatus = m_QuestStatus[questId];
        if (questStatus.Status != QUEST_STATUS_INCOMPLETE)
            continue;

        if (type)
            if (!quest->GetQuestObjectiveCountType(type))
                continue;

        for (QuestObjectiveSet::const_iterator citr = quest->m_questObjectives.begin(); citr != quest->m_questObjectives.end(); citr++)
        {
            QuestObjective const* questObjective = *citr;

            if (questObjective->Type == type && questObjective->ObjectId == objectId)
            {
                uint32 currentCounter = GetQuestObjectiveCounter(questObjective->Id);
                uint32 requiredCounter = uint32(questObjective->Amount);

                if (currentCounter < requiredCounter)
                {
                    uint32 addCounter = currentCounter + amount > requiredCounter ? requiredCounter - currentCounter : amount;

                    m_questObjectiveStatus[questObjective->Id] += addCounter;
                    MarkQuestObjectiveToSave(questId, questObjective->Id);

                    SendQuestUpdateAddCredit(quest, questObjective, ObjectGuid(guid), currentCounter, addCounter);
                }
                if (CanCompleteQuest(questId))
                    CompleteQuest(questId);

                break;
            }
        }
    }
}

bool Player::HasQuestForItem(uint32 itemId) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId == 0)
            continue;

        QuestStatusMap::const_iterator citrQs = m_QuestStatus.find(questId);
        if (citrQs == m_QuestStatus.end())
            continue;

        QuestStatusData const& questStatus = citrQs->second;
        if (questStatus.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
            if (!qInfo)
                continue;

            // hide quest if player is in raid-group and quest is no raid quest
            if (GetGroup() && GetGroup()->isRaidGroup() && !qInfo->IsAllowedInRaid(GetMap()->GetDifficulty()))
                if (!InBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                    continue;

            // There should be no mixed ReqItem/ReqSource drop
            // This part for ReqItem drop
            for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
                if ((*citr)->Type == QUEST_OBJECTIVE_TYPE_ITEM)
                    if (itemId == (*citr)->ObjectId && GetQuestObjectiveCounter((*citr)->Id) < uint32((*citr)->Amount))
                        return true;

            // This part - for ReqSource
            for (uint8 j = 0; j < QUEST_SOURCE_ITEM_IDS_COUNT; ++j)
            {
                // examined item is a source item
                if (qInfo->RequiredSourceItemId[j] == itemId)
                {
                    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemId);

                    // 'unique' item
                    if (pProto->MaxCount && int32(GetItemCount(itemId, true)) < pProto->MaxCount)
                        return true;

                    // allows custom amount drop when not 0
                    if (qInfo->RequiredSourceItemCount[j])
                    {
                        if (GetItemCount(itemId, true) < qInfo->RequiredSourceItemCount[j])
                            return true;
                    }
                    else if (GetItemCount(itemId, true) < pProto->GetMaxStackSize())
                        return true;
                }
            }
        }
    }

    return false;
}

void Player::SendQuestComplete(Quest const* quest)
{
    if (quest)
    {
        WorldPacket data(SMSG_QUESTUPDATE_COMPLETE, 4);
        data << uint32(quest->GetQuestId());
        GetSession()->SendPacket(&data);
        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTUPDATE_COMPLETE quest = %u", quest->GetQuestId());
    }
}

void Player::SendQuestReward(Quest const* quest, uint32 XP)
{
    uint32 questId = quest->GetQuestId();
    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTGIVER_QUEST_COMPLETE quest = %u", questId);
    sGameEventMgr->HandleQuestComplete(questId);

    uint32 xp = 0;
    uint32 moneyReward = 0;

    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        xp = XP;
        if (quest->GetRewardOrRequiredMoney() > 0)
            moneyReward = quest->GetRewardOrRequiredMoney();
    }
    else // At max level, increase gold reward
    {
        moneyReward = quest->GetRewMoneyMaxLevel() * sWorld->getRate(RATE_DROP_MONEY);
        if (quest->GetRewardOrRequiredMoney() > 0)
            moneyReward = std::max(moneyReward, uint32(quest->GetRewardOrRequiredMoney()));
    }

    WorldPacket data(SMSG_QUESTGIVER_QUEST_COMPLETE, 4 + 4 + 4 + 4 + 4 + 4 + 1);
    data.WriteBit(1);                                      // FIXME: unknown bits, common values sent
    data.WriteBit(0);
    data.FlushBits();

    data << uint32(quest->GetBonusTalents());              // bonus talents (still sent to 5.4.x client)
    data << uint32(moneyReward);
    data << uint32(questId);
    data << uint32(quest->GetRewardSkillId());             // 4.x bonus skill id
    data << uint32(xp);
    data << uint32(quest->GetRewardSkillPoints());         // 4.x bonus skill points

    GetSession()->SendPacket(&data);
}

void Player::SendQuestFailed(uint32 questId, InventoryResult reason)
{
    if (questId)
    {
        WorldPacket data(SMSG_QUESTGIVER_QUEST_FAILED, 4 + 4);
        data << uint32(reason);                             // failed reason (valid reasons: 4, 16, 50, 17, 74, other values show default message)
        data << uint32(questId);
        GetSession()->SendPacket(&data);
        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTGIVER_QUEST_FAILED");
    }
}

void Player::SendQuestTimerFailed(uint32 quest_id)
{
    if (quest_id)
    {
        WorldPacket data(SMSG_QUESTUPDATE_FAILEDTIMER, 4);
        data << uint32(quest_id);
        GetSession()->SendPacket(&data);
        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTUPDATE_FAILEDTIMER");
    }
}

void Player::SendCanTakeQuestResponse(QuestFailedReason msg) const
{
    WorldPacket data(SMSG_QUESTGIVER_QUEST_INVALID, 5); 
    data.WriteBit(1);
    data.FlushBits();
    data << uint32(msg);
    GetSession()->SendPacket(&data);

    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTGIVER_QUEST_INVALID");
}

void Player::SendQuestConfirmAccept(const Quest* quest, Player* pReceiver)
{
    if (pReceiver)
    {
        std::string strTitle = quest->GetTitle();

        int loc_idx = pReceiver->GetSession()->GetSessionDbLocaleIndex();
        if (loc_idx >= 0)
            if (const QuestLocale* pLocale = sObjectMgr->GetQuestLocale(quest->GetQuestId()))
                ObjectMgr::GetLocaleString(pLocale->Title, loc_idx, strTitle);

        ObjectGuid guid = GetGUID();

        WorldPacket data(SMSG_QUEST_CONFIRM_ACCEPT, 1 + 8 + 2 + strTitle.size() + 4);
        data.WriteBit(guid[0]);
        data.WriteBit(guid[3]);
        data.WriteBit(0);       // has quest title
        data.WriteBit(guid[2]);
        data.WriteBit(guid[5]);
        data.WriteBit(guid[6]);
        data.WriteBit(guid[4]);
        data.WriteBit(guid[1]);
        data.WriteBits(strTitle.size(), 10);
        data.WriteBit(guid[7]);
        data.FlushBits();

        data.WriteByteSeq(guid[6]);
        data.WriteString(strTitle);
        data.WriteByteSeq(guid[0]);
        data.WriteByteSeq(guid[5]);
        data.WriteByteSeq(guid[3]);
        data.WriteByteSeq(guid[1]);
        data.WriteByteSeq(guid[4]);
        data.WriteByteSeq(guid[2]);
        data.WriteByteSeq(guid[7]);
        data << uint32(quest->GetQuestId());

        pReceiver->GetSession()->SendPacket(&data);

        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUEST_CONFIRM_ACCEPT");
    }
}

void Player::SendPushToPartyResponse(Player* player, uint8 msg)
{
    if (player)
    {
        ObjectGuid guid = player->GetGUID();

        WorldPacket data(SMSG_QUEST_PUSH_RESULT, 8 + 1);
        data.WriteGuidMask(guid, 3, 0, 1, 4, 7, 5, 6, 2);

        data.WriteGuidBytes(guid, 4);
        data << uint8(msg);
        data.WriteGuidBytes(guid, 1, 5, 3, 7, 6, 2, 0);

        GetSession()->SendPacket(&data);

        TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUEST_PUSH_RESULT");
    }
}

void Player::SendQuestUpdateAddCredit(Quest const* quest, QuestObjective const* objective, ObjectGuid guid, uint16 oldCount, uint16 addCount)
{
    WorldPacket data(SMSG_QUESTUPDATE_ADD_CREDIT, 1 + 8 + 2 + 1 + 4 + 2 + 4);
    data << uint16(oldCount + addCount);
    data << uint8(objective->Type);
    data << uint32(quest->GetQuestId());
    data << uint16(objective->Amount);
    data << uint32(objective->ObjectId);

    data.WriteBit(guid[0]);
    data.WriteBit(guid[4]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[3]);

    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[6]);

    GetSession()->SendPacket(&data);

    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTUPDATE_ADD_KILL");

    uint16 logSlot = FindQuestSlot(quest->GetQuestId());
    if (logSlot < MAX_QUEST_LOG_SIZE)
        SetQuestSlotCounter(logSlot, objective->Index, GetQuestSlotCounter(logSlot, objective->Index) + addCount);
}

void Player::SendQuestUpdateAddCreditSimple(Quest const* quest, QuestObjective const* objective)
{
    WorldPacket data(SMSG_QUESTUPDATE_ADD_CREDIT_SIMPLE, 4 + 4 + 1);
    data << uint32(objective->ObjectId);
    data << uint32(quest->GetQuestId());
    data << uint8(objective->Type);
    GetSession()->SendPacket(&data);

    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTUPDATE_ADD_CREDIT_SIMPLE");

    uint16 logSlot = FindQuestSlot(quest->GetQuestId());
    if (logSlot < MAX_QUEST_LOG_SIZE)
        SetQuestSlotState(logSlot, 256 << objective->Index);
}

void Player::SendQuestUpdateAddPlayer(Quest const* quest, QuestObjective const* objective, uint16 oldCount, uint16 addCount)
{
    WorldPacket data(SMSG_QUESTUPDATE_ADD_PVP_KILL, 4 + 2);
    data << uint32(quest->GetQuestId());
    data << uint32(oldCount + addCount);

    GetSession()->SendPacket(&data);

    TC_LOG_DEBUG("network", "WORLD: Sent SMSG_QUESTUPDATE_ADD_PVP_KILL");

    uint16 logSlot = FindQuestSlot(quest->GetQuestId());
    if (logSlot < MAX_QUEST_LOG_SIZE)
        SetQuestSlotCounter(logSlot, objective->Index, GetQuestSlotCounter(logSlot, objective->Index) + addCount);
}

bool Player::HasPvPForcingQuest() const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId == 0)
            continue;

        Quest const* quest = sObjectMgr->GetQuestTemplate(questId);
        if (!quest)
            continue;

        if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
            return true;
    }

    return false;
}

/*********************************************************/
/***                   LOAD SYSTEM                     ***/
/*********************************************************/

void Player::Initialize(uint32 guid)
{
    Object::_Create(guid, 0, HIGHGUID_PLAYER);
}

void Player::_LoadDeclinedNames(PreparedQueryResult result)
{
    if (!result)
        return;

    delete m_declinedname;
    m_declinedname = new DeclinedName;
    for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
        m_declinedname->name[i] = (*result)[i].GetString();
}

void Player::_LoadEquipmentSets(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS,   "SELECT setguid, setindex, name, iconname, item0, item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11, item12, item13, item14, item15, item16, item17, item18 FROM character_equipmentsets WHERE guid = '%u' ORDER BY setindex", GUID_LOPART(m_guid));
    if (!result)
        return;

    uint32 count = 0;
    do
    {
        Field* fields = result->Fetch();
        EquipmentSet eqSet;

        eqSet.Guid      = fields[0].GetUInt64();
        uint8 index    = fields[1].GetUInt8();
        eqSet.Name      = fields[2].GetString();
        eqSet.IconName  = fields[3].GetString();
        eqSet.IgnoreMask = fields[4].GetUInt32();
        eqSet.state     = EQUIPMENT_SET_UNCHANGED;

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
            eqSet.Items[i] = fields[5+i].GetUInt32();

        m_EquipmentSets[index] = eqSet;

        ++count;

        if (count >= MAX_EQUIPMENT_SET_INDEX)                // client limit
            break;
    }
    while (result->NextRow());
}

void Player::_LoadBGData(PreparedQueryResult result)
{
    if (!result)
        return;

    Field* fields = result->Fetch();
    // Expecting only one row
    //        0           1     2      3      4      5      6          7          8        9
    // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell FROM character_battleground_data WHERE guid = ?

    m_bgData.bgInstanceID = fields[0].GetUInt32();
    m_bgData.bgTeam       = fields[1].GetUInt16();
    m_bgData.joinPos      = WorldLocation(fields[6].GetUInt16(),    // Map
                                          fields[2].GetFloat(),     // X
                                          fields[3].GetFloat(),     // Y
                                          fields[4].GetFloat(),     // Z
                                          fields[5].GetFloat());    // Orientation
    m_bgData.taxiPath[0]  = fields[7].GetUInt32();
    m_bgData.taxiPath[1]  = fields[8].GetUInt32();
    m_bgData.taxiLastNode = fields[9].GetUInt16();
    m_bgData.mountSpell   = fields[10].GetUInt32();
}

bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, uint64 guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return false;

    Field* fields = result->Fetch();

    x = fields[0].GetFloat();
    y = fields[1].GetFloat();
    z = fields[2].GetFloat();
    o = fields[3].GetFloat();
    mapid = fields[4].GetUInt16();
    in_flight = !fields[5].GetString().empty();

    return true;
}

void Player::SetHomebind(WorldLocation const& loc, uint32 areaId)
{
    loc.GetPosition(m_homebindX, m_homebindY, m_homebindZ);
    m_homebindMapId = loc.GetMapId();
    m_homebindAreaId = areaId;

    // update sql homebind
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_HOMEBIND);
    stmt->setUInt16(0, m_homebindMapId);
    stmt->setUInt16(1, m_homebindAreaId);
    stmt->setFloat (2, m_homebindX);
    stmt->setFloat (3, m_homebindY);
    stmt->setFloat (4, m_homebindZ);
    stmt->setUInt32(5, GetGUIDLow());
    CharacterDatabase.Execute(stmt);
}

uint32 Player::GetUInt32ValueFromArray(Tokenizer const& data, uint16 index)
{
    if (index >= data.size())
        return 0;

    return (uint32)atoi(data[index]);
}

float Player::GetFloatValueFromArray(Tokenizer const& data, uint16 index)
{
    float result;
    uint32 temp = Player::GetUInt32ValueFromArray(data, index);
    memcpy(&result, &temp, sizeof(result));

    return result;
}

bool Player::isBeingLoaded() const
{
    return GetSession()->PlayerLoading();
}

bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
{
    ////                                                     0     1        2     3     4        5      6    7      8     9           10              11
    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid, account, name, race, class, gender, level, xp, money, playerBytes, playerBytes2, playerFlags, "
     // 12          13          14          15   16           17        18        19         20         21          22           23                 24
    //"position_x, position_y, position_z, map, orientation, taximask, cinematic, totaltime, leveltime, rest_bonus, logout_time, is_logout_resting, resettalents_cost, "
    // 25                 26          27       28       29       30       31         32           33            34        35    36      37                 38         39
    //"resettalents_time, talentTree, trans_x, trans_y, trans_z, trans_o, transguid, extra_flags, stable_slots, at_login, zone, online, death_expire_time, taxi_path, instance_mode_mask, "
    //    40           41          42              43           44            45
    //"totalKills, todayKills, yesterdayKills, chosenTitle, watchedFaction, drunk, "
    // 46      47      48      49      50      51      52           53         54          55             56
    //"health, power1, power2, power3, power4, power5, instance_id, speccount, activespec, exploredZones, equipmentCache, "
    // 57           58          59                 60          61
    //"knownTitles, actionBars, grantableLevels, lootspec, project_transfer FROM characters WHERE guid = '%u'", guid);
    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_FROM);
    if (!result)
    {
        std::string name = "<unknown>";
        sObjectMgr->GetPlayerNameByGUID(guid, name);
        TC_LOG_ERROR("entities.player", "Player %s (GUID: %u) not found in table `characters`, can't load. ", name.c_str(), guid);
        return false;
    }

    Field* fields = result->Fetch();

    uint32 dbAccountId = fields[1].GetUInt32();

    // check if the character's account in the db and the logged in account match.
    // player should be able to load/delete character only with correct account!
    if (dbAccountId != GetSession()->GetAccountId())
    {
        TC_LOG_ERROR("entities.player", "Player (GUID: %u) loading from wrong account (is: %u, should be: %u)", guid, GetSession()->GetAccountId(), dbAccountId);
        return false;
    }

    if (holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BANNED))
    {
        TC_LOG_ERROR("entities.player", "Player (GUID: %u) is banned, can't load.", guid);
        return false;
    }

    Object::_Create(guid, 0, HIGHGUID_PLAYER);

    m_name = fields[2].GetString();

    // check name limitations
    if (ObjectMgr::CheckPlayerName(m_name) != CHAR_NAME_SUCCESS ||
        (GetSession()->GetSecurity() == SEC_PLAYER &&
         sObjectMgr->IsReservedName(m_name)))
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);
        stmt->setUInt16(0, uint16(AT_LOGIN_RENAME));
        stmt->setUInt32(1, guid);
        CharacterDatabase.Execute(stmt);
        return false;
    }

    // overwrite possible wrong/corrupted guid
    SetUInt64Value(OBJECT_FIELD_GUID, MAKE_NEW_GUID(guid, 0, HIGHGUID_PLAYER));

    uint8 gender = fields[5].GetUInt8();
    if (!IsValidGender(gender))
    {
        TC_LOG_ERROR("entities.player", "Player (GUID: %u) has wrong gender (%u), can't be loaded.", guid, gender);
        return false;
    }

    SetRace(fields[3].GetUInt8());
    SetClass(fields[4].GetUInt8());
    SetGender(gender);

    SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
    SetUInt32Value(PLAYER_FIELD_XP, fields[7].GetUInt32());

    _LoadIntoDataField(fields[55].GetCString(), PLAYER_FIELD_EXPLORED_ZONES, PLAYER_EXPLORED_ZONES_SIZE);
    _LoadIntoDataField(fields[57].GetCString(), PLAYER_FIELD_KNOWN_TITLES, KNOWN_TITLES_SIZE*2);

    SetObjectScale(1.0f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);

    // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
    m_achievementMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACHIEVEMENTS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CRITERIA_PROGRESS));

    uint64 money = fields[8].GetUInt64();
    if (money > MAX_MONEY_AMOUNT)
        money = MAX_MONEY_AMOUNT;
    SetMoney(money);

    SetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID, fields[9].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_REST_STATE, fields[10].GetUInt32());
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 0, fields[5].GetUInt8());
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 1, fields[45].GetUInt8());
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS, fields[11].GetUInt32());
    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fields[44].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, realmID);

    // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)
    SetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 2, fields[58].GetUInt8());

    InitDisplayIds();

    // cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        SetUInt64Value(PLAYER_FIELD_INV_SLOTS + (slot * 2), 0);
        SetVisibleItemSlot(slot, NULL);

        delete m_items[slot];
        m_items[slot] = NULL;
    }

    TC_LOG_DEBUG("entities.player.loading", "Load Basic value of player %s is: ", m_name.c_str());
    outDebugValues();

    //Need to call it to initialize m_team (m_team can be calculated from race)
    //Other way is to saves m_team into characters table.
    setFactionForRace(getRace());

    // load home bind and check in same time class/race pair, it used later for restore broken positions
    if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
        return false;

    InitPrimaryProfessions();                               // to max set before any spell loaded

    // init saved position, and fix it later if problematic
    uint32 transLowGUID = uint32(fields[31].GetUInt32());

    Relocate(fields[12].GetFloat(), fields[13].GetFloat(), fields[14].GetFloat(), fields[16].GetFloat());

    uint32 mapId = fields[15].GetUInt16();
    uint32 instanceId = fields[52].GetUInt32();

    uint32 dungeonDiff = fields[39].GetUInt8() & 0x0F;
    if ((sMapStore.LookupEntry(mapId) && sMapStore.LookupEntry(mapId)->Instanceable() && dungeonDiff != DUNGEON_DIFFICULTY_NORMAL && dungeonDiff != DUNGEON_DIFFICULTY_HEROIC && dungeonDiff != DUNGEON_DIFFICULTY_CHALLENGE) || dungeonDiff >= MAX_DUNGEON_DIFFICULTY)
        dungeonDiff = DUNGEON_DIFFICULTY_NORMAL;
    uint32 raidDiff = (fields[39].GetUInt8() >> 4) & 0x0F;
    if ((sMapStore.LookupEntry(mapId) && sMapStore.LookupEntry(mapId)->Instanceable() && raidDiff != RAID_DIFFICULTY_10MAN_NORMAL && raidDiff != RAID_DIFFICULTY_25MAN_NORMAL && raidDiff != RAID_DIFFICULTY_10MAN_HEROIC && raidDiff != RAID_DIFFICULTY_25MAN_HEROIC) || raidDiff >= MAX_RAID_DIFFICULTY)
        raidDiff = RAID_DIFFICULTY_10MAN_NORMAL;
    SetDungeonDifficulty(Difficulty(dungeonDiff));          // may be changed in _LoadGroup
    SetRaidDifficulty(Difficulty(raidDiff));                // may be changed in _LoadGroup

    std::string taxi_nodes = fields[38].GetString();

#define RelocateToHomebind(){ mapId = m_homebindMapId; instanceId = 0; Relocate(m_homebindX, m_homebindY, m_homebindZ); }

    sGroupMgr->LoadGroups(this);

    if (Group* group = GetGroup())
    {
        SetDungeonDifficulty(group->GetDungeonDifficulty());
        SetRaidDifficulty(group->GetRaidDifficulty());
    }

    _LoadCurrency(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CURRENCY));
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[40].GetUInt32());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0, fields[41].GetUInt16());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, fields[42].GetUInt16());

    m_lootLockouts->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOOTLOCKOUTS));
    _LoadBoundInstances(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BOUND_INSTANCES));
    _LoadInstanceTimeRestrictions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_INSTANCE_LOCK_TIMES));
    _LoadBGData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BG_DATA));

    Battleground* currentBg = nullptr;
    bool toTransport = false;
    GetSession()->SetPlayer(this);
    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
    if (!mapEntry || !IsPositionValid())
    {
        TC_LOG_ERROR("entities.player", "Player (guidlow %d) have invalid coordinates (MapId: %u X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        RelocateToHomebind();
    }
    // Player was saved in Arena or Bg
    else if (mapEntry && mapEntry->IsBattlegroundOrArena())
    {
        if (m_bgData.bgInstanceID)                                                //saved in Battleground
            currentBg = sBattlegroundMgr->GetBattleground(m_bgData.bgInstanceID, BATTLEGROUND_TYPE_NONE);

        bool player_at_bg = currentBg && currentBg->IsPlayerInBattleground(GetGUID());

        if (player_at_bg && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
        {
            BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(currentBg->GetTypeID(), currentBg->GetArenaType());
            AddBattlegroundQueueId(bgQueueTypeId);

            m_bgData.bgTypeID = currentBg->GetTypeID();

            //join player to battleground group
            currentBg->AddOrSetPlayerToCorrectBgGroup(this, m_bgData.bgTeam);

            SetInviteForBattlegroundQueueType(bgQueueTypeId, currentBg->GetInstanceID());
        }
        // Bg was not found - go to Entry Point
        else
        {
            // leave bg
            if (player_at_bg)
                currentBg->RemovePlayerAtLeave(GetGUID(), false, true);
            
            // Do not look for instance if bg not found
            const WorldLocation& _loc = GetBattlegroundEntryPoint();
            mapId = _loc.GetMapId(); instanceId = 0;

            // Db field type is type int16, so it can never be MAPID_INVALID
            //if (mapId == MAPID_INVALID) -- code kept for reference
            if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
            {
                TC_LOG_ERROR("entities.player", "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid);
                RelocateToHomebind();
            }
            else
                Relocate(&_loc);

            // We are not in BG anymore
            m_bgData.bgInstanceID = 0;

            ResetCriterias(CRITERIA_RESET_TYPE_LEAVE_BATTLEGORUND, mapEntry->MapID);
        }
    }
    // currently we do not support transport in bg
    else if (transLowGUID)
    {
        toTransport = true;
    }
    // currently we do not support taxi in instance
    else if (!taxi_nodes.empty())
    {
        instanceId = 0;

        // Not finish taxi flight path
        if (m_bgData.HasTaxiPath())
        {
            for (int i = 0; i < 2; ++i)
                m_taxi.AddTaxiDestination(m_bgData.taxiPath[i]);
        }
        else if (!m_taxi.LoadTaxiDestinationsFromString(taxi_nodes, GetTeam()))
        {
            // problems with taxi path loading
            TaxiNodesEntry const* nodeEntry = NULL;
            if (uint32 node_id = m_taxi.GetTaxiSource())
                nodeEntry = sTaxiNodesStore.LookupEntry(node_id);

            if (!nodeEntry)                                      // don't know taxi start node, to homebind
            {
                TC_LOG_ERROR("entities.player", "Character %u have wrong data in taxi destination list, teleport to homebind.", GetGUIDLow());
                RelocateToHomebind();
            }
            else                                                // have start node, to it
            {
                TC_LOG_ERROR("entities.player", "Character %u have too short taxi destination list, teleport to original node.", GetGUIDLow());
                mapId = nodeEntry->map_id;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }
            m_taxi.ClearTaxiDestinations();
        }

        if (uint32 node_id = m_taxi.GetTaxiSource())
        {
            // save source node as recall coord to prevent recall and fall from sky
            TaxiNodesEntry const* nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
            if (nodeEntry && nodeEntry->map_id == GetMapId())
            {
                ASSERT(nodeEntry);                                  // checked in m_taxi.LoadTaxiDestinationsFromString
                mapId = nodeEntry->map_id;
                Relocate(nodeEntry->x, nodeEntry->y, nodeEntry->z, 0.0f);
            }
            m_taxi.SetLastNodeIndex(fields[62].GetUInt16());
            // flight will started later
        }
    }

    // Map could be changed before
    mapEntry = sMapStore.LookupEntry(mapId);
    // client without expansion support
    if (mapEntry)
    {
        if (GetSession()->Expansion() < mapEntry->Expansion())
        {
            TC_LOG_DEBUG("entities.player.loading", "Player %s using client without required expansion tried login at non accessible map %u", GetName().c_str(), mapId);
            RelocateToHomebind();
        }

        // fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
        if (instanceId)
            if (InstanceSave* save = GetInstanceSave(mapId, mapEntry->IsRaid()))
                if (save->GetInstanceId() != instanceId)
                    instanceId = 0;
    }

    // NOW player must have valid map
    // load the player's map here if it's not already loaded
    Map* map = sMapMgr->CreateMap(mapId, this);
    bool reCreateMap = false;
    if (!map)
    {
        instanceId = 0;
        AreaTriggerStruct const* at = sObjectMgr->GetGoBackTrigger(mapId);
        if (at)
        {
            TC_LOG_ERROR("entities.player", "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
            mapId = at->target_mapId;
        }
        else
        {
            TC_LOG_ERROR("entities.player", "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            RelocateToHomebind();
        }
        reCreateMap = true;
    }

    if (toTransport)
    {
        uint64 transGUID = MAKE_NEW_GUID(transLowGUID, 0, HIGHGUID_MO_TRANSPORT);

        Transport* transport = NULL;
        if (GameObject* go = HashMapHolder<GameObject>::Find(transGUID))
            transport = go->ToTransport();

        if (transport)
        {
            float x = fields[26].GetFloat(), y = fields[27].GetFloat(), z = fields[28].GetFloat(), o = fields[29].GetFloat();
            m_movementInfo.transport.pos.Relocate(x, y, z, o);
            transport->CalculatePassengerPosition(x, y, z, &o);

            if (!Trinity::IsValidMapCoord(x, y, z, o) ||
                // transport size limited
                std::fabs(m_movementInfo.transport.pos.GetPositionX()) > 250.0f ||
                std::fabs(m_movementInfo.transport.pos.GetPositionY()) > 250.0f ||
                std::fabs(m_movementInfo.transport.pos.GetPositionZ()) > 250.0f)
            {
                TC_LOG_ERROR("entities.player", "Player (guidlow %d) have invalid transport coordinates (X: %f Y: %f Z: %f O: %f). Teleport to bind location.",
                    guid, x, y, z, o);

                m_movementInfo.transport.Reset();

                reCreateMap = true;
            }
            else
            {
                Relocate(x, y, z, o);
                mapId = transport->GetMapId();

                transport->AddPassenger(this);
            }
        }
        else
        {
            TC_LOG_ERROR("entities.player", "Player (guidlow %d) have problems with transport guid (%u). Teleport to bind location.",
                guid, transLowGUID);

            reCreateMap = true;
        }

        if (reCreateMap)
        {
            if (AreaTriggerStruct const* at = sObjectMgr->GetGoBackTrigger(mapId))
            {
                TC_LOG_ERROR("entities.player", "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
                mapId = at->target_mapId;
            }
            else
            {
                TC_LOG_ERROR("entities.player", "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid, mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                RelocateToHomebind();
            }
        }
    }

    if (reCreateMap)
    {
        map = sMapMgr->CreateMap(mapId, this);
        if (!map)
        {
            PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
            mapId = info->mapId;
            Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
            TC_LOG_ERROR("entities.player", "Player (guidlow %d) have invalid coordinates (X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            map = sMapMgr->CreateMap(mapId, this);
            if (!map)
            {
                TC_LOG_ERROR("entities.player", "Player (guidlow %d) has invalid default map coordinates (X: %f Y: %f Z: %f O: %f). or instance couldn't be created", guid, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                return false;
            }
        }
    }

    // if the player is in an instance and it has been reset in the meantime teleport him to the entrance
    if (instanceId && !sInstanceSaveMgr->GetInstanceSave(instanceId) && !map->IsBattlegroundOrArena())
    {
        AreaTriggerStruct const* at = sObjectMgr->GetMapEntranceTrigger(mapId);
        if (at)
            Relocate(at->target_X, at->target_Y, at->target_Z, at->target_Orientation);
        // If map is Scenario, then handle relocate cuz scenario maps doesn`t have at
        else if (map->IsScenario())
        {
            switch (map->GetId())
            {
                case 1005: // Brewing Storm
                    Relocate(2248.37f, 1123.1f, 485.23f, 4.78f);
                    break;
                case 999: // Theramores Fall
                    Relocate(3817.44f, 4799.1f, 11.49f, 0.8f);
                    break;
                case 1024: // Greenstone Village
                    Relocate(2006.24f, 2032.13f, 220.77f, 1.63f);
                    break;
                case 1030: // Crypt of Forgotten Kings
                    Relocate(905.3f, 2354.04f, 97.56f, 3.11f);
                    break;
                case 1031: // Arena of Annihilation
                    Relocate(3795.69f, 533.61f, 639.0f, 6.1f);
                    break;
                case 1048: // Unga Ingo
                    Relocate(3007.67f, 942.94f, 11.3f, 5.34f);
                    break;
                case 1050: // Assault on Zanves
                    Relocate(1434.61f, 3935.7f, 6.5f, 5.67f);
                    break;
                case 1051: // Brewmoon Festival
                    Relocate(1735.55f, 296.65f, 475.58f, 1.4f);
                    break;
            }
        }
        else
        {
            TC_LOG_ERROR("entities.player", "Player %s(GUID: %u) logged in to a reset instance (map: %u) and there is no area-trigger leading to this map. Thus he can't be ported back to the entrance. This _might_ be an exploit attempt.", GetName().c_str(), GetGUIDLow(), mapId);
            RelocateToHomebind();
        }
    }

    SetMap(map);
    StoreRaidMapDifficulty();

    if (currentBg && currentBg->IsPlayerInBattleground(GetGUID()) && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
        currentBg->EventPlayerLoggedIn(this);

    // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
    // this must help in case next save after mass player load after server startup
    m_nextSave = urand(m_nextSave/2, m_nextSave*3/2);

    SaveRecallPosition();

    time_t now = time(NULL);
    time_t logoutTime = time_t(fields[22].GetUInt32());

    // since last logout (in seconds)
    uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.

    // set value, including drunk invisibility detection
    // calculate sobering. after 15 minutes logged out, the player will be sober again
    uint8 newDrunkValue = 0;
    if (time_diff < uint32(GetDrunkValue()) * 9)
        newDrunkValue = GetDrunkValue() - time_diff / 9;

    SetDrunkValue(newDrunkValue);

    m_cinematic = fields[18].GetUInt8();
    m_Played_time[PLAYED_TIME_TOTAL]= fields[19].GetUInt32();
    m_Played_time[PLAYED_TIME_LEVEL]= fields[20].GetUInt32();

    SetTalentResetCost(fields[24].GetUInt32());
    SetTalentResetTime(time_t(fields[25].GetUInt32()));

    m_taxi.LoadTaxiMask(fields[17].GetString());                // must be before InitTaxiNodesForLevel

    uint32 extraflags = fields[32].GetUInt16();

    m_atLoginFlags = fields[34].GetUInt16();

    // Honor system
    // Update Honor kills data
    m_lastHonorUpdateTime = logoutTime;
    UpdateHonorFields();

    m_deathExpireTime = time_t(fields[37].GetUInt32());
    if (m_deathExpireTime > now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP)
        m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP-1;

    // clear channel spell data (if saved at channel spell casting)
    SetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT, 0);
    SetUInt32Value(UNIT_FIELD_CHANNEL_SPELL, 0);

    // clear charm/summon related fields
    SetOwnerGUID(0);
    SetUInt64Value(UNIT_FIELD_CHARMED_BY, 0);
    SetUInt64Value(UNIT_FIELD_CHARM, 0);
    SetUInt64Value(UNIT_FIELD_SUMMON, 0);
    SetUInt64Value(PLAYER_FIELD_FARSIGHT_OBJECT, 0);
    SetCreatorGUID(0);

    RemoveFlag(UNIT_FIELD_FLAGS2, UNIT_FLAG2_FORCE_MOVEMENT);

    // reset some aura modifiers before aura apply
    SetUInt32Value(PLAYER_FIELD_TRACK_CREATURE_MASK, 0);
    SetUInt32Value(PLAYER_FIELD_TRACK_RESOURCE_MASK, 0);

    // make sure the unit is considered out of combat for proper loading
    ClearInCombat();

    // make sure the unit is considered not in duel for proper loading
    SetUInt64Value(PLAYER_FIELD_DUEL_ARBITER, 0);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    // reset stats before loading any modifiers
    InitStatsForLevel();
    InitGlyphsForLevel();
    InitTaxiNodesForLevel();
    InitRunes();

    // rest bonus can only be calculated after InitStatsForLevel()
    m_rest_bonus = fields[21].GetFloat();

    if (time_diff > 0)
    {
        //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
        float bubble0 = 0.031f;
        //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
        float bubble1 = 0.125f;
        float bubble = fields[23].GetUInt8() > 0
            ? bubble1*sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY)
            : bubble0*sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);

        SetRestBonus(GetRestBonus()+ time_diff*((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)/72000)*bubble);
    }

    // must be before skills load
    _LoadResearchDigsites(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_RESEARCH_DIGSITES));
    _LoadResearchHistory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_RESEARCH_HISTORY));
    _LoadResearchProjects(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_RESEARCH_PROJECTS));

    // load skills after InitStatsForLevel because it triggering aura apply also
    _LoadSkills(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SKILLS));
    UpdateSkillsForLevel(); //update skills after load, to make sure they are correctly update at player load

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()

    //mails are loaded only when needed ;-) - when player in game click on mailbox.
    _LoadMail();

    SetSpecsCount(fields[53].GetUInt8());
    SetActiveSpec(fields[54].GetUInt8());

    // sanity check
    if (GetSpecsCount() > MAX_TALENT_SPECS || GetActiveSpec() > MAX_TALENT_SPEC || GetSpecsCount() < MIN_TALENT_SPECS)
    {
        SetActiveSpec(0);
        TC_LOG_ERROR("entities.player", "Player %s(GUID: %u) has SpecCount = %u and ActiveSpec = %u.", GetName().c_str(), GetGUIDLow(), GetSpecsCount(), GetActiveSpec());
    }

    // Only load selected specializations, learning mastery spells requires this
    Tokenizer talentTrees(fields[26].GetString(), ' ', MAX_TALENT_SPECS);
    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
    {
        if (i >= talentTrees.size())
            break;

        uint32 talentTree = atol(talentTrees[i]);
        if (sChrSpecializationStore.LookupEntry(talentTree))
            SetTalentSpecialization(i, Specializations(talentTree));
    }

    SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, GetTalentSpecialization(GetActiveSpec()));

    // must be loaded before spells
    m_battlePetMgr->LoadFromDb(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BATTLE_PETS));
    m_battlePetMgr->LoadSlotsFromDb(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BATTLE_PET_SLOTS));

    _LoadTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_TALENTS));
    _LoadSpells(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SPELLS));

    for (auto&& itr : m_battlePetMgr->BattlePets)
        if (uint32 spell = db2::GetBattlePetSummonSpell(itr->GetSpecies()))
            if (!HasSpell(spell))
                LearnSpell(spell, false);

    _LoadGlyphs(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GLYPHS));
    _LoadAuras(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_AURAS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_AURA_EFFECT), time_diff);
    _LoadGlyphAuras();
    // add ghost flag (must be after aura load: PLAYER_FLAGS_GHOST set in aura)
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
        m_deathState = DEAD;

    // after spell load, learn rewarded spell if need also
    _LoadQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS));
    _LoadQuestObjectiveStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_OBJECTIVE_STATUS));
    _LoadQuestStatusRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS_REW));
    _LoadDailyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DAILY_QUEST_STATUS));
    _LoadWeeklyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_WEEKLY_QUEST_STATUS));
    _LoadSeasonalQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SEASONAL_QUEST_STATUS));
    _LoadMonthlyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MONTHLY_QUEST_STATUS));
    _LoadRandomBGStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_RANDOM_BG));
    _LoadWeekendBGStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_WEEKEND_BG));

    // after spell and quest load
    InitTalentForLevel();
    LearnDefaultSkills();
    LearnSpecializationSpells();

    // must be before inventory (some items required reputation check)
    m_reputationMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_REPUTATION));

    _LoadInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_INVENTORY), time_diff);

    if (IsVoidStorageUnlocked())
        _LoadVoidStorage(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_VOID_STORAGE));

    // update items with duration and realtime
    UpdateItemDuration(time_diff, true);

    _LoadGuildInfo(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GUILD)); // Before _LoadActions
    _LoadActions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACTIONS));

    // unread mails and next delivery time, actual mails not loaded
    _LoadMailInit(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MAIL_COUNT), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_MAIL_DATE));

    m_social = sSocialMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SOCIAL_LIST), GetGUIDLow());

    // check PLAYER_FIELD_PLAYER_TITLE compatibility with PLAYER__FIELD_KNOWN_TITLES
    // note: PLAYER__FIELD_KNOWN_TITLES updated at quest status loaded
    uint32 curTitle = fields[43].GetUInt32();
    if (curTitle && !HasTitle(curTitle))
        curTitle = 0;

    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, curTitle);

    // has to be called after last Relocate() in Player::LoadFromDB
    SetFallInformation(0, GetPositionZ());

    GetSpellHistory()->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SPELL_COOLDOWNS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_SPELL_CHARGES));

    _LoadCompletedChallenges(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_COMPLETED_CHALLENGES));

    // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
    // Do now before stats re-calculation cleanup for ghost state unexpected auras
    if (!IsAlive())
        RemoveAllAurasOnDeath();
    else
        RemoveAllAurasRequiringDeadTarget();

    //apply all stat bonuses from items and auras
    SetCanModifyStats(true);
    UpdateAllStats();

    // restore remembered power/health values (but not more max values)
    uint32 savedHealth = fields[46].GetUInt32();
    SetHealth(savedHealth > GetMaxHealth() ? GetMaxHealth() : savedHealth);
    uint32 loadedPowers = 0;
    for (uint32 i = 0; i < MAX_POWERS; ++i)
    {
        if (GetPowerIndex(i) != MAX_POWERS)
        {
            uint32 savedPower = i != POWER_ECLIPSE ? fields[47+loadedPowers].GetUInt32() : 0;
            uint32 maxPower = GetUInt32Value(UNIT_FIELD_MAX_POWER + loadedPowers);
            SetPower(Powers(i), (savedPower > maxPower) ? maxPower : savedPower);
            if (++loadedPowers >= MAX_POWERS_PER_CLASS)
                break;
        }
    }

    for (; loadedPowers < MAX_POWERS_PER_CLASS; ++loadedPowers)
        SetUInt32Value(UNIT_FIELD_POWER + loadedPowers, 0);

    SetPower(POWER_ECLIPSE, 0);
    SetPower(POWER_SHADOW_ORBS, 0);

    // Verify loaded talent specializations
    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
    {
        if (i >= talentTrees.size())
            break;

        uint32 talentTree = atol(talentTrees[i]);
        if (talentTree != 0 && !sChrSpecializationStore.LookupEntry(talentTree) && i == GetActiveSpec())
            SetAtLoginFlag(AT_LOGIN_RESET_TALENTS); // invalid tree, reset talents
    }

    TC_LOG_DEBUG("entities.player.loading", "The value of player %s after load item and aura is: ", m_name.c_str());
    outDebugValues();

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER))
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP | PLAYER_FLAGS_PVP_TIMER))
    {
        bool enablePvp = true;
        if (AreaTableEntry const* zone = sAreaTableStore.LookupEntry(GetZoneId()))
        {
            if (zone->IsSanctuary())
                enablePvp = false;
            if (zone->team == AREATEAM_ALLY && GetTeam() == ALLIANCE)
                enablePvp = false;
            if (zone->team == AREATEAM_HORDE && GetTeam() == HORDE)
                enablePvp = false;
        }
        if (enablePvp)
        {
            SetPvP(true);
            RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER); // Will be enabled in HandlePlayerLogin if need
        }
    }

    // GM state
    if (GetSession()->GetSecurity() > SEC_PLAYER)
    {
        switch (sWorld->getIntConfig(CONFIG_GM_LOGIN_STATE))
        {
            default:
            case 0:                      break;             // disable
            case 1: SetGameMaster(true); break;             // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_ON)
                    SetGameMaster(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_VISIBLE_STATE))
        {
            default:
            case 0: SetGMVisible(false); break;             // invisible
            case 1:                      break;             // visible
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_INVISIBLE)
                    SetGMVisible(false);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_CHAT))
        {
            default:
            case 0:                  break;                 // disable
            case 1: SetGMChat(true); break;                 // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_CHAT)
                    SetGMChat(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_WHISPERING_TO))
        {
            default:
            case 0:                          break;         // disable
            case 1: SetAcceptWhispers(true); break;         // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_ACCEPT_WHISPERS)
                    SetAcceptWhispers(true);
                break;
        }
    }

    // RaF stuff.
    m_grantableLevels = fields[59].GetUInt8();
    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    if (m_grantableLevels > 0)
        SetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 1, 0x01);

    uint32 lootSpecialization = fields[60].GetUInt32();
    auto specializationEntry = sChrSpecializationStore.LookupEntry(lootSpecialization);
    if (!specializationEntry)
        lootSpecialization = 0;
    SetLootSpecialization(lootSpecialization);

    _LoadDeclinedNames(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DECLINED_NAMES));

    m_achievementMgr->CheckAllAchievementCriteria(this);

    _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_EQUIPMENT_SETS));

    _LoadCUFProfiles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CUF_PROFILES));

    auto petresult = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CURRENT_PET_ID);
    m_currentPetId = petresult ? (*petresult)[0].GetUInt32() : 0;

    sServiceMgr->ApplyRetroactiveFixes(this);

    uint32 transferDate = fields[61].GetUInt32();
    if (transferDate && HasAtLoginFlag(AT_LOGIN_FIRST))
        sServiceMgr->AddSpecificPlayerData(guid, 0, getRace(), getClass(), this, true, false);

    if (auto res = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BONUS_ROLL))
        m_bonusRollBonusChance = (*res)[0].GetFloat();

    _LoadDeserterInfo(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DESERTER_INFO));
    _LoadBattlegroundStats(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_BATTLGEROUND_STATS));

    return true;
}

void Player::_LoadCUFProfiles(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154 FROM character_cuf_profiles WHERE guid = ?
        Field* fields = result->Fetch();

        uint8 id           = fields[0].GetUInt8();
        std::string name   = fields[1].GetString();
        uint16 frameHeight = fields[2].GetUInt16();
        uint16 frameWidth  = fields[3].GetUInt16();
        uint8 sortBy       = fields[4].GetUInt8();
        uint8 healthText   = fields[5].GetUInt8();
        uint32 boolOptions = fields[6].GetUInt32();
        uint8 unk146       = fields[7].GetUInt8();
        uint8 unk147       = fields[8].GetUInt8();
        uint8 unk148       = fields[9].GetUInt8();
        uint16 unk150      = fields[10].GetUInt16();
        uint16 unk152      = fields[11].GetUInt16();
        uint16 unk154      = fields[12].GetUInt16();

        if (id >= MAX_CUF_PROFILES)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadCUFProfiles - Player (GUID: %u, name: %s) has an CUF profile with invalid id (id: %u), max is %i.", GetGUIDLow(), GetName().c_str(), id, MAX_CUF_PROFILES);
            continue;
        }

        _CUFProfiles[id] = new CUFProfile(name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154);
    }
    while (result->NextRow());
}

bool Player::IsAllowedToLoot(Creature const* creature)
{
    if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
        return false;

    if (HasPendingBind())
        return false;

    const Loot* loot = &creature->loot;
    if (loot->isLooted()) // nothing to loot or everything looted.
        return false;

    if (creature->HasLootRecipient(this))
        return true;

    Group* thisGroup = GetGroup();
    if (!thisGroup)
        return this == creature->GetLootRecipient();
    if (thisGroup != creature->GetLootRecipientGroup() || !creature->IsLootRecipientGroupMember(GetGUID()))
        return false;

    switch (thisGroup->GetLootMethod())
    {
        case FREE_FOR_ALL:
        case MASTER_LOOT:
            return true;
        case ROUND_ROBIN:
            // may only loot if the player is the loot roundrobin player
            // or if there are free/quest/conditional item for the player
            if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
                return true;

            return loot->hasItemFor(this);
        case GROUP_LOOT:
        case NEED_BEFORE_GREED:
            // may only loot if the player is the loot roundrobin player
            // or item over threshold (so roll(s) can be launched)
            // or if there are free/quest/conditional item for the player
            if (loot->roundRobinPlayer == 0 || loot->roundRobinPlayer == GetGUID())
                return true;

            if (loot->hasOverThresholdItem())
                return true;

            return loot->hasItemFor(this);
    }

    return false;
}

void Player::_LoadActions(PreparedQueryResult result)
{
    m_actionButtons.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint8 button = fields[0].GetUInt8();
            uint32 action = fields[1].GetUInt32();
            uint8 type = fields[2].GetUInt8();

            if (ActionButton* ab = addActionButton(button, action, type))
                ab->uState = ACTIONBUTTON_UNCHANGED;
            else
            {
                TC_LOG_ERROR("entities.player", "  ...at loading, and will deleted in DB also");

                // Will deleted in DB at next save (it can create data until save but marked as deleted)
                m_actionButtons[button].uState = ACTIONBUTTON_DELETED;
            }
        } while (result->NextRow());
    }
}

void Player::_LoadAuras(PreparedQueryResult result, PreparedQueryResult effectResult, uint32 timediff)
{
    TC_LOG_DEBUG("entities.player.loading", "Loading auras for player %u", GetGUIDLow());

    /*                                                           0       1        2         3                 4         5      6       7         8              9            10
    QueryResult* result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2,
                                                        11          12          13
                                                    maxduration, remaintime, remaincharges FROM character_aura WHERE guid = '%u'", GetGUIDLow());
    */

    struct EffectData
    {
        uint8 Slot;
        uint8 Index;
        int32 BaseAmount;
        int32 Amount;
    };

    std::vector<EffectData> effects;

    if (effectResult)
    {
        do
        {
            Field* fields = effectResult->Fetch();

            effects.emplace_back();
            auto& effect = effects.back();
            effect.Slot = fields[0].GetUInt8();
            effect.Index = fields[1].GetUInt8();
            effect.BaseAmount = fields[2].GetInt32();
            effect.Amount = fields[3].GetInt32();
        } while (effectResult->NextRow());
    }

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            std::array<int32, MAX_SPELL_EFFECTS> damage;
            damage.fill(0);
            std::array<int32, MAX_SPELL_EFFECTS> baseDamage;
            baseDamage.fill(0);
            uint64 casterGuid = fields[0].GetUInt64();
            uint32 higuid = GUID_HIPART(casterGuid);

            // Okay...
            if ((higuid == 0 && higuid != HIGHGUID_PLAYER) || (higuid == 0x070 && higuid != HIGHGUID_PLAYER))
                casterGuid = MAKE_NEW_GUID(GUID_LOPART(casterGuid), 0, HIGHGUID_PLAYER);

            uint32 spellid = fields[1].GetUInt32();
            uint32 effMask = fields[2].GetUInt32();
            uint32 recalculatemask = fields[3].GetUInt32();
            uint8 stackcount = fields[4].GetUInt8();
            int32 maxduration = fields[5].GetInt32();
            int32 remaintime = fields[6].GetInt32();
            uint8 remaincharges = fields[7].GetUInt8();
            uint8 slot = fields[8].GetUInt8();

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
            if (!spellInfo)
            {
                TC_LOG_ERROR("entities.player", "Unknown aura (spellid %u), ignore.", spellid);
                continue;
            }

            // negative effects should continue counting down after logout
            if (remaintime != -1 && !spellInfo->IsPositive())
            {
                if (remaintime/IN_MILLISECONDS <= int32(timediff))
                    continue;

                remaintime -= timediff*IN_MILLISECONDS;
            }

            // prevent wrong values of remaincharges
            if (spellInfo->ProcCharges)
            {
                // we have no control over the order of applying auras and modifiers allow auras
                // to have more charges than value in SpellInfo
                if (remaincharges <= 0/* || remaincharges > spellproto->procCharges*/)
                    remaincharges = spellInfo->ProcCharges;
            }
            else
                remaincharges = 0;

            for (auto&& it : effects)
            {
                if (it.Slot == slot && it.Index < MAX_SPELL_EFFECTS)
                {
                    damage[it.Index] = it.Amount;
                    baseDamage[it.Index] = it.BaseAmount;
                }
            }

            if (Aura* aura = Aura::TryCreate(spellInfo, effMask, this, nullptr, &baseDamage[0], nullptr, casterGuid))
            {
                if (!aura->CanBeSaved())
                {
                    aura->Remove();
                    continue;
                }

                aura->SetLoadedState(maxduration, remaintime, remaincharges, stackcount, recalculatemask, &damage[0]);
                aura->ApplyForTargets();
                TC_LOG_INFO("entities.player", "Added aura spellid %u, effectmask %u", spellInfo->Id, effMask);
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadGlyphAuras()
{
    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
    {
        if (uint32 glyph = GetGlyph(GetActiveSpec(), i))
        {
            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
            {
                if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(GetGlyphSlot(i)))
                {
                    if (gp->TypeFlags == gs->TypeFlags)
                    {
                        ApplyGlyph(i, glyph);
                        continue;
                    }
                    else
                        TC_LOG_ERROR("entities.player", "Player %s has glyph with typeflags %u in slot with typeflags %u, removing.", m_name.c_str(), gp->TypeFlags, gs->TypeFlags);
                }
                else
                    TC_LOG_ERROR("entities.player", "Player %s has not existing glyph slot entry %u on index %u", m_name.c_str(), GetGlyphSlot(i), i);
            }
            else
                TC_LOG_ERROR("entities.player", "Player %s has not existing glyph entry %u on index %u", m_name.c_str(), glyph, i);

            // On any error remove glyph
            SetGlyph(i, 0);
        }
    }
}

void Player::LoadCorpse()
{
    if (IsAlive())
        sObjectAccessor->ConvertCorpseForPlayer(GetGUID());
    else
    {
        if (Corpse* corpse = GetCorpse())
            ApplyModFlag(PLAYER_FIELD_LIFETIME_MAX_RANK, PLAYER_FIELD_BYTE_RELEASE_TIMER, corpse && !sMapStore.LookupEntry(corpse->GetMapId())->Instanceable());
        else
            //Prevent Dead Player login without corpse
            ResurrectPlayer(0.5f);
    }
}

void Player::_LoadInventory(PreparedQueryResult result, uint32 timeDiff)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT data, text, bag, slot, item, item_template FROM character_inventory JOIN item_instance ON character_inventory.item = item_instance.guid WHERE character_inventory.guid = '%u' ORDER BY bag, slot", GetGUIDLow());
    //NOTE: the "order by `bag`" is important because it makes sure
    //the bagMap is filled before items in the bags are loaded
    //NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
    //expected to be equipped before offhand items (@todo fixme)

    if (result)
    {
        uint32 zoneId = GetZoneId();

        std::map<uint32, Bag*> bagMap;                               // fast guid lookup for bags
        std::map<uint32, Item*> invalidBagMap;                       // fast guid lookup for bags
        std::list<Item*> problematicItems;
        SQLTransaction trans = CharacterDatabase.BeginTransaction();

        // Prevent items from being added to the queue while loading
        m_itemUpdateQueueBlocked = true;
        do
        {
            Field* fields = result->Fetch();
            if (Item* item = _LoadItem(trans, zoneId, timeDiff, fields))
            {
                uint32 bagGuid  = fields[18].GetUInt32();
                uint8  slot     = fields[19].GetUInt8();

                uint8 err = EQUIP_ERR_OK;
                // Item is not in bag
                if (!bagGuid)
                {
                    item->SetContainer(NULL);
                    item->SetSlot(slot);

                    if (IsInventoryPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        uint16 dest;
                        err = CanEquipItem(slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            QuickEquipItem(dest, item);
                    }
                    else if (IsBankPos(INVENTORY_SLOT_BAG_0, slot))
                    {
                        ItemPosCountVec dest;
                        err = CanBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false, false);
                        if (err == EQUIP_ERR_OK)
                            item = BankItem(dest, item, true);
                    }

                    // Remember bags that may contain items in them
                    if (err == EQUIP_ERR_OK)
                    {
                        if (IsBagPos(item->GetPos()))
                            if (Bag* pBag = item->ToBag())
                                bagMap[item->GetGUIDLow()] = pBag;
                    }
                    else
                        if (IsBagPos(item->GetPos()))
                            if (item->IsBag())
                                invalidBagMap[item->GetGUIDLow()] = item;
                }
                else
                {
                    item->SetSlot(NULL_SLOT);
                    // Item is in the bag, find the bag
                    std::map<uint32, Bag*>::iterator itr = bagMap.find(bagGuid);
                    if (itr != bagMap.end())
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (invalidBagMap.find(bagGuid) != invalidBagMap.end())
                    {
                        std::map<uint32, Item*>::iterator itr = invalidBagMap.find(bagGuid);
                        if (std::find(problematicItems.begin(), problematicItems.end(), itr->second) != problematicItems.end())
                            err = EQUIP_ERR_INTERNAL_BAG_ERROR;
                    }
                    else
                    {
                        TC_LOG_ERROR("entities.player", "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which doesnt have a valid bag (Bag GUID: %u, slot: %u). Possible cheat?",
                            GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot);
                        item->DeleteFromInventoryDB(trans);
                        // Send items from invalid bags via mail for autotransferred characters - who knows what custom bags may've been used on their source server
                        if (HasAtLoginFlag(AT_LOGIN_POST_AUTOTRANSFER))
                            problematicItems.push_back(item);
                        else
                        {
                            delete item;
                            continue;
                        }
                    }

                }

                // Item's state may have changed after storing
                if (err == EQUIP_ERR_OK)
                    item->SetState(ITEM_UNCHANGED, this);
                else
                {
                    TC_LOG_ERROR("entities.player", "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which can't be loaded into inventory (Bag GUID: %u, slot: %u) by reason %u. Item will be sent by mail.",
                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), bagGuid, slot, err);
                    item->DeleteFromInventoryDB(trans);
                    problematicItems.push_back(item);
                }
            }
        } while (result->NextRow());

        m_itemUpdateQueueBlocked = false;

        // Send problematic items by mail
        while (!problematicItems.empty())
        {
            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

            MailDraft draft(subject, "There were problems with equipping item(s).");
            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
            {
                draft.AddItem(problematicItems.front());
                problematicItems.pop_front();
            }
            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
        }
        CharacterDatabase.CommitTransaction(trans);
    }
    //if (IsAlive())
    _ApplyAllItemMods();
}

void Player::_LoadVoidStorage(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
        Field* fields = result->Fetch();

        uint64 itemId = fields[0].GetUInt64();
        uint32 itemEntry = fields[1].GetUInt32();
        uint8 slot = fields[2].GetUInt8();
        uint32 creatorGuid = fields[3].GetUInt32();
        uint32 randomProperty = fields[4].GetUInt32();
        uint32 suffixFactor = fields[5].GetUInt32();
        uint32 upgradeId = fields[6].GetUInt32();

        if (!itemId)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry);
            continue;
        }

        if (!sObjectMgr->GetItemTemplate(itemEntry))
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid entry (item id: " UI64FMTD ", entry: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry);
            continue;
        }

        if (slot >= VOID_STORAGE_MAX_SLOT)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry, slot);
            continue;
        }

        std::string name;
        if (creatorGuid && !sObjectMgr->GetPlayerNameByGUID(creatorGuid, name))
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid creator guid, set to 0 (item id: " UI64FMTD ", entry: %u, creatorGuid: %u).", GetGUIDLow(), GetName().c_str(), itemId, itemEntry, creatorGuid);
            creatorGuid = 0;
        }

        _voidStorageItems[slot] = new VoidStorageItem(itemId, itemEntry, creatorGuid, randomProperty, suffixFactor, upgradeId);
    }
    while (result->NextRow());
}

Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
{
    Item* item = NULL;
    uint32 itemGuid  = fields[20].GetUInt32();
    uint32 itemEntry = fields[21].GetUInt32();
    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry))
    {
        bool remove = false;
        item = NewItemOrBag(proto);
        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry, this))
        {
            PreparedStatement* stmt = NULL;

            // Do not allow to have item limited to another map/zone in alive state
            if (IsAlive() && item->IsLimitedToAnotherMapOrZone(GetMapId(), zoneId))
            {
                TC_LOG_DEBUG("entities.player.loading", "Player::_LoadInventory: player (GUID: %u, name: '%s', map: %u) has item (GUID: %u, entry: %u) limited to another map (%u). Deleting item.",
                    GetGUIDLow(), GetName().c_str(), GetMapId(), item->GetGUIDLow(), item->GetEntry(), zoneId);
                remove = true;
            }
            // "Conjured items disappear if you are logged out for more than 15 minutes"
            else if (timeDiff > 15 * MINUTE && proto->Flags & ITEM_PROTO_FLAG_CONJURED)
            {
                TC_LOG_DEBUG("entities.player.loading", "Player::_LoadInventory: player (GUID: %u, name: '%s', diff: %u) has conjured item (GUID: %u, entry: %u) with expired lifetime (15 minutes). Deleting item.",
                    GetGUIDLow(), GetName().c_str(), timeDiff, item->GetGUIDLow(), item->GetEntry());
                remove = true;
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
            {
                if (item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2 * HOUR < GetTotalPlayedTime())
                {
                    uint32 timer = GetTotalPlayedTime() - item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME);
                    TC_LOG_DEBUG("entities.player.loading", "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry(), timer);

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
                    stmt->setUInt32(0, item->GetGUIDLow());
                    trans->Append(stmt);

                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
                }
                else
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_REFUNDS);
                    stmt->setUInt32(0, item->GetGUIDLow());
                    stmt->setUInt32(1, GetGUIDLow());
                    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
                    {
                        item->SetRefundRecipient((*result)[0].GetUInt32());
                        item->SetPaidMoney((*result)[1].GetUInt32());
                        item->SetPaidExtendedCost((*result)[2].GetUInt16());
                        AddRefundReference(item->GetGUIDLow());
                    }
                    else
                    {
                        TC_LOG_DEBUG("entities.player.loading", "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with refundable flags, but without data in item_refund_instance. Removing flag.",
                            GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry());
                        item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
                    }
                }
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_BOP_TRADE);
                stmt->setUInt32(0, item->GetGUIDLow());
                if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
                {
                    std::string strGUID = (*result)[0].GetString();
                    Tokenizer GUIDlist(strGUID, ' ');
                    AllowedLooterSet looters;
                    for (Tokenizer::const_iterator itr = GUIDlist.begin(); itr != GUIDlist.end(); ++itr)
                        looters.insert(atol(*itr));

                    if (looters.size() > 1 && item->GetTemplate()->GetMaxStackSize() == 1 && item->IsSoulBound())
                    {
                        item->SetSoulboundTradeable(looters);
                    }
                    else
                        item->ClearSoulboundTradeable(this);
                }
                else
                {
                    TC_LOG_DEBUG("entities.player.loading", "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with ITEM_FLAG_BOP_TRADEABLE flag, but without data in item_soulbound_trade_data. Removing flag.",
                        GetGUIDLow(), GetName().c_str(), item->GetGUIDLow(), item->GetEntry());
                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE);
                }
            }
            else if (proto->HolidayId)
            {
                remove = true;
                GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
                GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
                for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
                {
                    if (uint32(events[*itr].holiday_id) == proto->HolidayId)
                    {
                        remove = false;
                        break;
                    }
                }
            }
        }
        else
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadInventory: player (GUID: %u, name: '%s') has broken item (GUID: %u, entry: %u) in inventory. Deleting item.",
                GetGUIDLow(), GetName().c_str(), itemGuid, itemEntry);
            remove = true;
        }
        // Remove item from inventory if necessary
        if (remove)
        {
            Item::DeleteFromInventoryDB(trans, itemGuid);
            item->FSetState(ITEM_REMOVED);
            item->SaveToDB(trans);                           // it also deletes item object!
            item = NULL;
        }
    }
    else
    {
        TC_LOG_ERROR("entities.player", "Player::_LoadInventory: player (GUID: %u, name: '%s') has unknown item (entry: %u) in inventory. Deleting item.",
            GetGUIDLow(), GetName().c_str(), itemEntry);
        Item::DeleteFromInventoryDB(trans, itemGuid);
        Item::DeleteFromDB(trans, itemGuid);
    }
    return item;
}

// load mailed item which should receive current player
void Player::_LoadMailedItems(Mail* mail)
{
    // data needs to be at first place for Item::LoadFromDB
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
    stmt->setUInt32(0, mail->messageID);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint32 itemGuid = fields[18].GetUInt32();
        uint32 itemTemplate = fields[19].GetUInt32();

        mail->AddItem(itemGuid, itemTemplate);

        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTemplate);

        if (!proto)
        {
            TC_LOG_ERROR("entities.player", "Player %u has unknown item_template (ProtoType) in mailed items(GUID: %u template: %u) in mail (%u), deleted.", GetGUIDLow(), itemGuid, itemTemplate, mail->messageID);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_MAIL_ITEM);
            stmt->setUInt32(0, itemGuid);
            CharacterDatabase.Execute(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            stmt->setUInt32(0, itemGuid);
            CharacterDatabase.Execute(stmt);
            continue;
        }

        Item* item = NewItemOrBag(proto);

        if (!item->LoadFromDB(itemGuid, MAKE_NEW_GUID(fields[20].GetUInt32(), 0, HIGHGUID_PLAYER), fields, itemTemplate, this))
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", mail->messageID, itemGuid);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
            stmt->setUInt32(0, itemGuid);
            CharacterDatabase.Execute(stmt);

            item->FSetState(ITEM_REMOVED);

            SQLTransaction temp = SQLTransaction(NULL);
            item->SaveToDB(temp);                               // it also deletes item object !
            continue;
        }

        AddMItem(item);
    }
    while (result->NextRow());
}

void Player::_LoadMailInit(PreparedQueryResult resultUnread, PreparedQueryResult resultDelivery)
{
    //set a count of unread mails
    //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
    if (resultUnread)
        unReadMails = uint8((*resultUnread)[0].GetUInt64());

    // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
    //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
    if (resultDelivery)
        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
}

void Player::_LoadMail()
{
    m_mail.clear();

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL);
    stmt->setUInt32(0, GetGUIDLow());
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            Mail* m = new Mail;

            m->messageID      = fields[0].GetUInt32();
            m->messageType    = fields[1].GetUInt8();
            m->sender         = fields[2].GetUInt32();
            m->receiver       = fields[3].GetUInt32();
            m->subject        = fields[4].GetString();
            m->body           = fields[5].GetString();
            bool has_items    = fields[6].GetBool();
            m->expire_time    = time_t(fields[7].GetUInt32());
            m->deliver_time   = time_t(fields[8].GetUInt32());
            m->money          = fields[9].GetUInt64();
            m->COD            = fields[10].GetUInt64();
            m->checked        = fields[11].GetUInt32();
            m->stationery     = fields[12].GetUInt8();
            m->mailTemplateId = fields[13].GetInt16();

            if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
            {
                TC_LOG_ERROR("entities.player", "Player::_LoadMail - Mail (%u) have not existed MailTemplateId (%u), remove at load", m->messageID, m->mailTemplateId);
                m->mailTemplateId = 0;
            }

            m->state = MAIL_STATE_UNCHANGED;

            if (has_items)
                _LoadMailedItems(m);

            m_mail.push_back(m);
        }
        while (result->NextRow());
    }
    m_mailsLoaded = true;
}

void Player::LoadPet()
{
    //fixme: the pet should still be loaded if the player is not in world
    // just not added to the map
    if (IsInWorld())
    {
        Pet* pet = new Pet(this);
        if (!pet->LoadPetFromDB(PET_LOAD_BY_ID, GetCurrentPetId()))
            delete pet;
    }

    if (getClass() == CLASS_HUNTER)
    {
        // Required to track what slots are still free for Tame Beast spell
        LoadPetList();
        // Required to properly display pet portraits on Call Pet spells
        GetSession()->SendPetList(0, PET_SLOT_ACTIVE_FIRST, PET_SLOT_ACTIVE_LAST);
    }
}

void Player::_LoadQuestStatus(PreparedQueryResult result)
{
    uint16 slot = 0;

    ////                                                       0      1       2        3        4           5          6         7           8           9           10
    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, explored, timer, mobcount1, mobcount2, mobcount3, mobcount4, itemcount1, itemcount2, itemcount3,
    //                                                    11           12
    //                                                itemcount4, playercount FROM character_queststatus WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                // find or create
                QuestStatusData& questStatusData = m_QuestStatus[quest_id];

                uint8 qstatus = fields[1].GetUInt8();
                if (qstatus < MAX_QUEST_STATUS)
                    questStatusData.Status = QuestStatus(qstatus);
                else
                {
                    questStatusData.Status = QUEST_STATUS_INCOMPLETE;
                    TC_LOG_ERROR("entities.player", "Player %s (GUID: %u) has invalid quest %d status (%u), replaced by QUEST_STATUS_INCOMPLETE(3).",
                        GetName().c_str(), GetGUIDLow(), quest_id, qstatus);
                }

                questStatusData.Explored = (fields[2].GetUInt8() > 0);

                time_t quest_time = time_t(fields[3].GetUInt32());

                if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && !GetQuestRewardStatus(quest_id))
                {
                    AddTimedQuest(quest_id);

                    if (quest_time <= sWorld->GetGameTime())
                        questStatusData.Timer = 1;
                    else
                        questStatusData.Timer = uint32((quest_time - sWorld->GetGameTime()) * IN_MILLISECONDS);
                }
                else
                    quest_time = 0;

                // add to quest log
                if (slot < MAX_QUEST_LOG_SIZE && questStatusData.Status != QUEST_STATUS_NONE)
                {
                    SetQuestSlot(slot, quest_id, uint32(quest_time)); // cast can't be helped

                    if (questStatusData.Status == QUEST_STATUS_COMPLETE)
                        SetQuestSlotState(slot, QUEST_STATE_COMPLETE);
                    else if (questStatusData.Status == QUEST_STATUS_FAILED)
                        SetQuestSlotState(slot, QUEST_STATE_FAIL);

                    ++slot;
                }

                TC_LOG_DEBUG("entities.player.loading", "Quest status is {%u} for quest {%u} for player (GUID: %u)", questStatusData.Status, quest_id, GetGUIDLow());
            }
        }
        while (result->NextRow());
    }

    // clear quest log tail
    for (uint16 i = slot; i < MAX_QUEST_LOG_SIZE; ++i)
        SetQuestSlot(i, 0);

    // Remove status of all daily quests, in case the player completed them on another character/account
    if (sWorld->AreprojectDailyQuestsEnabled())
    {
        if (projectMemberInfo* info = GetSession()->GetprojectMemberInfo())
        {
            for (auto&& group : info->CompletedDailyQuestExclusiveGroups)
            {
                auto bounds = sObjectMgr->mExclusiveQuestGroups.equal_range(group);
                for (auto itr = bounds.first; itr != bounds.second; ++itr)
                    RemoveActiveQuest(itr->second, false, true);
            }
        }
    }
}

void Player::_LoadQuestObjectiveStatus(PreparedQueryResult result)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 objectiveId = fields[0].GetUInt32();
            uint32 amount      = fields[1].GetUInt32();

            if (!sObjectMgr->QuestObjectiveExists(objectiveId))
            {
                TC_LOG_ERROR("entities.player", "Player %s (%u) has invalid Quest Objective Id %u in Quest Objective status data! Skipping.", GetName().c_str(), GetGUIDLow(), objectiveId);
                continue;
            }

            for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
            {
                uint32 questId = GetQuestSlotQuestId(i);
                if (!questId)
                    continue;

                uint32 objectiveQuestId = sObjectMgr->GetQuestObjectiveQuestId(objectiveId);
                if (questId != objectiveQuestId)
                    continue;

                // Quest existence is checked on Quest Objective load, no issue should arise
                QuestObjective const* objective = sObjectMgr->GetQuestTemplate(objectiveQuestId)->GetQuestObjective(objectiveId);
                if (objective != nullptr)
                SetQuestSlotCounter(i, objective->Index, amount);
                m_questObjectiveStatus.insert(std::make_pair(objectiveId, amount));

                break;
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadQuestStatusRewarded(PreparedQueryResult result)
{
    // SELECT quest FROM character_queststatus_rewarded WHERE guid = ?

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
                                                            // used to be new, no delete?
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (quest)
            {
                // learn rewarded spell if unknown
                learnQuestRewardedSpells(quest);

                // set rewarded title if any
                if (quest->GetCharTitleId())
                    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->GetCharTitleId()))
                        SetTitle(titleEntry);

                // Skip loading special quests - they are also added to rewarded quests but only once and remain there forever
                // instead add them separately from load daily/weekly/monthly/seasonal
                if (!quest->IsDailyOrWeekly() && !quest->IsMonthly() && !quest->IsSeasonal())
                    if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                        _completedQuestBits.set(questBit - 1);
            }

            m_RewardedQuests.insert(quest_id);
        }
        while (result->NextRow());
    }
}

void Player::_LoadDailyQuestStatus(PreparedQueryResult result)
{
    //for (uint32 quest_daily_idx = 0; quest_daily_idx < PLAYER_MAX_DAILY_QUESTS; ++quest_daily_idx)
        //SetUInt32Value(PLAYER_FIELD_DAILY_QUESTS_1+quest_daily_idx, 0);

    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time FROM character_queststatus_daily WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();

            // save _any_ from daily quest times (it must be after last reset anyway)
            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());

            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_dailyquests.insert(quest_id);
            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                _completedQuestBits.set(questBit - 1);

            TC_LOG_DEBUG("entities.player.loading", "Daily quest (%u) cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_DailyQuestChanged = false;
}

void Player::_LoadWeeklyQuestStatus(PreparedQueryResult result)
{
    m_weeklyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_weeklyquests.insert(quest_id);
            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                _completedQuestBits.set(questBit - 1);

            TC_LOG_DEBUG("entities.player.loading", "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_WeeklyQuestChanged = false;
}

void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
{
    m_seasonalquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            uint32 event_id = fields[1].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_seasonalquests[event_id].insert(quest_id);
            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                _completedQuestBits.set(questBit - 1);

            TC_LOG_DEBUG("entities.player.loading", "Seasonal quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_SeasonalQuestChanged = false;
}

void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
{
    m_monthlyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_monthlyquests.insert(quest_id);
            if (uint32 questBit = GetQuestUniqueBitFlag(quest_id))
                _completedQuestBits.set(questBit - 1);

            TC_LOG_DEBUG("entities.player.loading", "Monthly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_MonthlyQuestChanged = false;
}

void Player::_LoadSpells(PreparedQueryResult result)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, active, disabled FROM character_spell WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
            AddSpell((*result)[0].GetUInt32(), (*result)[1].GetBool(), false, false, (*result)[2].GetBool(), true);
        while (result->NextRow());
    }
}

void Player::_LoadBoundInstances(PreparedQueryResult result)
{
    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
        m_boundInstances[i].clear();

    Group* group = GetGroup();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT id, permanent, map, difficulty, resettime FROM character_instance LEFT JOIN instance ON instance = id WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            bool perm = fields[1].GetBool();
            uint32 mapId = fields[2].GetUInt16();
            uint32 instanceId = fields[0].GetUInt32();
            uint8 difficulty = fields[3].GetUInt8();

            time_t resetTime = time_t(fields[4].GetUInt32());
            // the resettime for normal instances is only saved when the InstanceSave is unloaded
            // so the value read from the DB may be wrong here but only if the InstanceSave is loaded
            // and in that case it is not used

            bool deleteInstance = false;

            MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
            std::string mapname = mapEntry ? mapEntry->name[sObjectMgr->GetDBCLocaleIndex()] : "Unknown";

            if (!mapEntry || (!mapEntry->IsDungeon() && !mapEntry->IsScenario()))
            {
                TC_LOG_ERROR("entities.player", "_LoadBoundInstances: player %s(%d) has bind to not existed or not dungeon map %d (%s)", GetName().c_str(), GetGUIDLow(), mapId, mapname.c_str());
                deleteInstance = true;
            }
            else if (difficulty >= MAX_DIFFICULTY && !mapEntry->IsScenario())
            {
                TC_LOG_ERROR("entities.player", "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u (%s)", GetName().c_str(), GetGUIDLow(), difficulty, mapId, mapname.c_str());
                deleteInstance = true;
            }
            else
            {
                MapDifficulty const* mapDiff = GetMapDifficultyData(mapId, Difficulty(difficulty));
                if (!mapDiff && !mapEntry->IsScenario())
                {
                    TC_LOG_ERROR("entities.player", "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u (%s)", GetName().c_str(), GetGUIDLow(), difficulty, mapId, mapname.c_str());
                    deleteInstance = true;
                }
                else if (!perm && group)
                {
                    TC_LOG_ERROR("entities.player", "_LoadBoundInstances: player %s(%d) is in group %d but has a non-permanent character bind to map %d (%s), %d, %d", GetName().c_str(), GetGUIDLow(), GUID_LOPART(group->GetGUID()), mapId, mapname.c_str(), instanceId, difficulty);
                    deleteInstance = true;
                }
            }

            if (deleteInstance)
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt32(1, instanceId);

                CharacterDatabase.Execute(stmt);

                continue;
            }

            // since non permanent binds are always solo bind, they can always be reset
            if (InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapId, instanceId, Difficulty(difficulty), resetTime, !perm, true))
               BindToInstance(save, perm, true);
        }
        while (result->NextRow());
    }
}

InstancePlayerBind* Player::GetBoundInstance(uint32 mapid, Difficulty difficulty)
{
    // some instances only have one difficulty
    MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(mapid, difficulty);
    if (!mapDiff)
        return NULL;

    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
    if (itr != m_boundInstances[difficulty].end())
        return &itr->second;

    Difficulty altDifficulty;
    switch (difficulty)
    {
        case RAID_DIFFICULTY_10MAN_NORMAL: altDifficulty = RAID_DIFFICULTY_25MAN_NORMAL; break;
        case RAID_DIFFICULTY_25MAN_NORMAL: altDifficulty = RAID_DIFFICULTY_10MAN_NORMAL; break;
        case RAID_DIFFICULTY_10MAN_HEROIC: altDifficulty = RAID_DIFFICULTY_25MAN_HEROIC; break;
        case RAID_DIFFICULTY_25MAN_HEROIC: altDifficulty = RAID_DIFFICULTY_10MAN_HEROIC; break;
        default:
            return nullptr;
    }

    itr = m_boundInstances[altDifficulty].find(mapid);
    if (itr != m_boundInstances[altDifficulty].end())
        return &itr->second;

    return nullptr;
}

InstanceSave* Player::GetInstanceSave(uint32 mapid, bool raid)
{
    InstancePlayerBind* pBind = GetBoundInstance(mapid, GetDifficulty(raid));
    InstanceSave* pSave = pBind ? pBind->save : NULL;
    if (!pBind || !pBind->perm)
        if (Group* group = GetGroup())
            if (InstanceGroupBind* groupBind = group->GetBoundInstance(this))
                pSave = groupBind->save;

    return pSave;
}

void Player::UnbindInstance(uint32 mapid, Difficulty difficulty, bool unload)
{
    BoundInstancesMap::iterator itr = m_boundInstances[difficulty].find(mapid);
    UnbindInstance(itr, difficulty, unload);
}

void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficulty, bool unload)
{
    if (itr != m_boundInstances[difficulty].end())
    {
        if (!unload)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, itr->second.save->GetInstanceId());

            CharacterDatabase.Execute(stmt, DBConnection::Instances);
        }

        if (itr->second.perm)
            GetSession()->SendCalendarRaidLockout(itr->second.save, false);

        itr->second.save->RemovePlayer(this);               // save can become invalid
        m_boundInstances[difficulty].erase(itr++);
    }
}

InstancePlayerBind* Player::BindToInstance(InstanceSave* save, bool permanent, bool load)
{
    if (save)
    {
        InstancePlayerBind& bind = m_boundInstances[save->GetDifficulty()][save->GetMapId()];
        if (!load)
        {
            if (bind.save)
            {
                // update the save when the group kills a boss
                if (permanent != bind.perm || save != bind.save)
                {
                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_INSTANCE);

                    stmt->setUInt32(0, save->GetInstanceId());
                    stmt->setBool(1, permanent);
                    stmt->setUInt32(2, GetGUIDLow());
                    stmt->setUInt32(3, bind.save->GetInstanceId());

                    CharacterDatabase.Execute(stmt, DBConnection::Instances);
                }
            }
            else
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_INSTANCE);

                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt32(1, save->GetInstanceId());
                stmt->setBool(2, permanent);

                CharacterDatabase.Execute(stmt, DBConnection::Instances);
            }
        }

        if (bind.save != save)
        {
            if (bind.save)
                bind.save->RemovePlayer(this);
            save->AddPlayer(this);
        }

        if (permanent)
            save->SetCanReset(false);

        bind.save = save;
        bind.perm = permanent;
        if (!load)
            TC_LOG_DEBUG("maps", "Player::BindToInstance: %s(%d) is now bound to map %d, instance %d, difficulty %d", GetName().c_str(), GetGUIDLow(), save->GetMapId(), save->GetInstanceId(), save->GetDifficulty());
        sScriptMgr->OnPlayerBindToInstance(this, save->GetDifficulty(), save->GetMapId(), permanent);
        return &bind;
    }

    return NULL;
}

void Player::BindToInstance()
{
    InstanceSave* mapSave = sInstanceSaveMgr->GetInstanceSave(_pendingBindId);
    if (!mapSave) //it seems sometimes mapSave is NULL, but I did not check why
        return;

    WorldPacket data(SMSG_INSTANCE_SAVE_CREATED, 1);
    data.WriteBit(false);
    data.FlushBits();
    GetSession()->SendPacket(&data);
    BindToInstance(mapSave, true);

    GetSession()->SendCalendarRaidLockout(mapSave, true);
}

void Player::SetPendingBind(uint32 instanceId, uint32 bindTimer)
{
    _pendingBindId = instanceId;
    _pendingBindTimer = bindTimer;
}

void Player::SendRaidInfo()
{
    uint32 counter = 0;

    WorldPacket data(SMSG_RAID_INSTANCE_INFO);

    time_t now = time(nullptr);

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i) // Instances.
        if (i != RAID_DIFFICULTY_25MAN_LFR)
            for (auto&& itr : m_boundInstances[i])
                if (itr.second.perm)
                    counter++;

    data.WriteBits(counter, 20);

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
    {
        if (i == RAID_DIFFICULTY_25MAN_LFR)
            continue;

        for (auto&& itr : m_boundInstances[i])
        {
            {
                if (itr.second.perm)
                {
                    InstanceSave* save = itr.second.save;
                    ObjectGuid instanceGUID = MAKE_NEW_GUID(save->GetInstanceId(), 0, HIGHGUID_INSTANCE_SAVE);

                    data.WriteBit(instanceGUID[1]);
                    data.WriteBit(instanceGUID[2]);
                    data.WriteBit(instanceGUID[6]);
                    data.WriteBit(0);                           // extended = 1
                    data.WriteBit(instanceGUID[0]);
                    data.WriteBit(instanceGUID[5]);
                    data.WriteBit(instanceGUID[4]);
                    data.WriteBit(1);                           // expired = 0
                    data.WriteBit(instanceGUID[7]);
                    data.WriteBit(instanceGUID[3]);
                }
            }
        }
    }

    data.FlushBits();

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
    {
        if (i == RAID_DIFFICULTY_25MAN_LFR)
            continue;

        for (auto&& itr : m_boundInstances[i])
        {
            Map* map = sMapMgr->FindMap(itr.second.save->GetMapId(), itr.second.save->GetInstanceId());
            {
                if (itr.second.perm)
                {
                    InstanceSave* save = itr.second.save;
                    uint32 completedEncounters = 0;
                    if (map)
                        if (InstanceScript* instanceScript = ((InstanceMap*) map)->GetInstanceScript())
                            completedEncounters = instanceScript->GetCompletedEncounterMask();

                    ObjectGuid instanceGUID = MAKE_NEW_GUID(save->GetInstanceId(), 0, HIGHGUID_INSTANCE_SAVE);

                    data.WriteByteSeq(instanceGUID[7]);
                    data.WriteByteSeq(instanceGUID[6]);
                    data.WriteByteSeq(instanceGUID[4]);
                    data.WriteByteSeq(instanceGUID[2]);
                    data.WriteByteSeq(instanceGUID[0]);
                    data << uint32(save->GetResetTime() - now); // Reset time.
                    data << uint32(completedEncounters);        // completed encounters mask
                    data.WriteByteSeq(instanceGUID[1]);
                    data << uint32(save->GetMapId());           // map id
                    data << uint32(save->GetDifficulty());      // difficulty
                    data.WriteByteSeq(instanceGUID[3]);
                    data.WriteByteSeq(instanceGUID[5]);
                }
            }
        }
    }

    GetSession()->SendPacket(&data);
}

/*
- called on every successful teleportation to a map
*/
void Player::SendSavedInstances()
{
    bool hasBeenSaved = false;
    WorldPacket data;

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)                               // only permanent binds are sent
            {
                hasBeenSaved = true;
                break;
            }
        }
    }

    //Send opcode SMSG_UPDATE_INSTANCE_OWNERSHIP. true or false means, whether you have current raid/heroic instances
    data.Initialize(SMSG_UPDATE_INSTANCE_OWNERSHIP, 4);
    data << uint32(hasBeenSaved);
    GetSession()->SendPacket(&data);

    if (!hasBeenSaved)
        return;

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)
            {
                data.Initialize(SMSG_UPDATE_LAST_INSTANCE, 4);
                data << uint32(itr->second.save->GetMapId());
                GetSession()->SendPacket(&data);
            }
        }
    }
}

/// convert the player's binds to the group
void Player::ConvertInstancesToGroup(Player* player, Group* group, bool switchLeader)
{
    // copy all binds to the group, when changing leader it's assumed the character
    // will not have any solo binds

    for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
    {
        for (BoundInstancesMap::iterator itr = player->m_boundInstances[i].begin(); itr != player->m_boundInstances[i].end();)
        {
            if (!switchLeader || !group->GetBoundInstance(itr->second.save->GetDifficulty(), itr->first))
                group->BindToInstance(itr->second.save, itr->second.perm, false);

            // permanent binds are not removed
            if (switchLeader && !itr->second.perm)
            {
                // increments itr in call
                player->UnbindInstance(itr, Difficulty(i), false);
            }
            else
                ++itr;
        }
    }
}

bool Player::Satisfy(AccessRequirement const* ar, uint32 target_map, bool report)
{
    if (!IsGameMaster() && ar)
    {
        uint8 LevelMin = 0;
        uint8 LevelMax = 0;

        MapEntry const* mapEntry = sMapStore.LookupEntry(target_map);
        if (!mapEntry)
            return false;

        if (!sWorld->getBoolConfig(CONFIG_INSTANCE_IGNORE_LEVEL))
        {
            if (ar->levelMin && getLevel() < ar->levelMin)
                LevelMin = ar->levelMin;
            if (ar->levelMax && getLevel() > ar->levelMax)
                LevelMax = ar->levelMax;
        }

        uint32 missingItem = 0;
        if (ar->item)
        {
            if (!HasItemCount(ar->item) &&
                (!ar->item2 || !HasItemCount(ar->item2)))
                missingItem = ar->item;
        }
        else if (ar->item2 && !HasItemCount(ar->item2))
            missingItem = ar->item2;

        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, target_map, this))
        {
            SendTransferAborted(target_map, TRANSFER_ABORT_MAP_NOT_ALLOWED);
            return false;
        }

        uint32 missingQuest = 0;
        if (GetTeam() == ALLIANCE && ar->quest_A && !GetQuestRewardStatus(ar->quest_A))
            missingQuest = ar->quest_A;
        else if (GetTeam() == HORDE && ar->quest_H && !GetQuestRewardStatus(ar->quest_H))
            missingQuest = ar->quest_H;

        uint32 missingAchievement = 0;
        Player* leader = this;
        uint64 leaderGuid = GetGroup() ? GetGroup()->GetLeaderGUID() : GetGUID();
        if (leaderGuid != GetGUID())
            leader = ObjectAccessor::FindPlayerInOrOutOfWorld(leaderGuid);

        if (ar->achievement)
            if (!leader || !leader->HasAchieved(ar->achievement))
                missingAchievement = ar->achievement;

        Difficulty target_difficulty = GetDifficulty(mapEntry->IsRaid());
        MapDifficulty const* mapDiff = GetDownscaledMapDifficultyData(target_map, target_difficulty);
        if (LevelMin || LevelMax || missingItem || missingQuest || missingAchievement)
        {
            if (report)
            {
                if (missingQuest && !ar->questFailedText.empty())
                    ChatHandler(GetSession()).PSendSysMessage("%s", ar->questFailedText.c_str());
                else if (mapDiff->hasErrorMessage) // if (missingAchievement) covered by this case
                    SendTransferAborted(target_map, TRANSFER_ABORT_DIFFICULTY, target_difficulty);
                else if (missingItem)
                    SendGameError(GameError::ERR_RAID_GROUP_REQUIREMENTS_UNMATCH);
                else if (LevelMin)
                    SendGameError(GameError::ERR_RAID_GROUP_LOWLEVEL);
            }
            return false;
        }
    }
    return true;
}

bool Player::CheckInstanceLoginValid()
{
    if (!FindMap())
        return false;

    if (!GetMap()->IsDungeon() || IsGameMaster())
        return true;

    if (GetMap()->IsRaid())
    {
        // cannot be in raid instance without a group
        if (!GetGroup() && GetMap()->GetEntry()->Expansion() >= EXPANSION_MISTS_OF_PANDARIA)
            return false;
    }
    else
    {
        // cannot be in normal instance without a group and more players than 1 in instance
        if (!GetGroup() && GetMap()->GetPlayersCountExceptGMs() > 1)
            return false;
    }

    // do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
    return sMapMgr->CanPlayerEnter(GetMap()->GetId(), this, true);
}

bool Player::CheckInstanceCount(uint32 instanceId) const
{
    if (_instanceResetTimes.size() < sWorld->getIntConfig(CONFIG_MAX_INSTANCES_PER_HOUR))
        return true;
    return _instanceResetTimes.find(instanceId) != _instanceResetTimes.end();
}

void Player::AddInstanceEnterTime(uint32 instanceId, time_t enterTime)
{
    if (_instanceResetTimes.find(instanceId) == _instanceResetTimes.end())
        _instanceResetTimes.insert(InstanceTimeMap::value_type(instanceId, enterTime + HOUR));
}

bool Player::_LoadHomeBind(PreparedQueryResult result)
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        TC_LOG_ERROR("entities.player", "Player (Name %s) has incorrect race/class (%u/%u) pair. Can't be loaded.",
            GetName().c_str(), uint32(getRace()), uint32(getClass()));
        return false;
    }

    bool ok = false;
    // SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
    if (result)
    {
        Field* fields = result->Fetch();

        m_homebindMapId = fields[0].GetUInt16();
        m_homebindAreaId = fields[1].GetUInt16();
        m_homebindX = fields[2].GetFloat();
        m_homebindY = fields[3].GetFloat();
        m_homebindZ = fields[4].GetFloat();

        MapEntry const* bindMapEntry = sMapStore.LookupEntry(m_homebindMapId);

        // accept saved data only for valid position (and non instanceable), and accessable
        if (MapManager::IsValidMapCoord(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ) &&
            !bindMapEntry->Instanceable() && GetSession()->Expansion() >= bindMapEntry->Expansion())
            ok = true;
        else
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt32(0, GetGUIDLow());
            CharacterDatabase.Execute(stmt);
        }
    }

    if (!ok)
    {
        m_homebindMapId = info->mapId;
        m_homebindAreaId = info->areaId;
        m_homebindX = info->positionX;
        m_homebindY = info->positionY;
        m_homebindZ = info->positionZ;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt16(1, m_homebindMapId);
        stmt->setUInt16(2, m_homebindAreaId);
        stmt->setFloat (3, m_homebindX);
        stmt->setFloat (4, m_homebindY);
        stmt->setFloat (5, m_homebindZ);
        CharacterDatabase.Execute(stmt);
    }

    TC_LOG_DEBUG("entities.player", "Setting player home position - mapid: %u, areaid: %u, X: %f, Y: %f, Z: %f",
        m_homebindMapId, m_homebindAreaId, m_homebindX, m_homebindY, m_homebindZ);

    return true;
}

/*********************************************************/
/***                   SAVE SYSTEM                     ***/
/*********************************************************/

void Player::SaveToDB(bool create /*=false*/)
{
    // delay auto save at any saves (manual, in code, or autosave)
    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    //lets allow only players in world to be saved
    if (IsBeingTeleportedFar())
    {
        ScheduleDelayedOperation(DELAYED_SAVE_PLAYER);
        return;
    }

    // first save/honor gain after midnight will also update the player's honor fields
    UpdateHonorFields();

    TC_LOG_DEBUG("entities.unit", "The value of player %s at save: ", m_name.c_str());
    outDebugValues();

    PreparedStatement* stmt = NULL;
    uint8 index = 0;

    if (create)
    {
        //! Insert query
        /// @todo: Filter out more redundant fields that can take their default value at player create
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER);
        stmt->setUInt32(index++, GetGUIDLow());
        stmt->setUInt32(index++, GetSession()->GetAccountId());
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_REST_STATE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt16(index++, (uint16)GetMapId());
        stmt->setUInt32(index++, (uint32)GetInstanceId());
        stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
        stmt->setFloat(index++, finiteAlways(GetPositionX()));
        stmt->setFloat(index++, finiteAlways(GetPositionY()));
        stmt->setFloat(index++, finiteAlways(GetPositionZ()));
        stmt->setFloat(index++, finiteAlways(GetOrientation()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetX()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetY()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetZ()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetO()));
        uint32 transLowGUID = 0;
        if (GetTransport() && GetTransport()->GetGoType() == GAMEOBJECT_TYPE_MO_TRANSPORT)
            transLowGUID = GetTransport()->GetGUIDLow();
        stmt->setUInt32(index++, transLowGUID);

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());

        ss.str("");
        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
            ss << GetTalentSpecialization(i) << " ";
        stmt->setString(index++, ss.str());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId());
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(i) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetSpecsCount());
        stmt->setUInt8(index++, GetActiveSpec());

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");
        // cache equipment...
        for (uint32 i = 0; i < EQUIPMENT_SLOT_END * 2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + i) << ' ';

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';
            ss << " 0 ";
        }
        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';
        stmt->setString(index++, ss.str());

        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 2));
        stmt->setUInt32(index++, m_grantableLevels);
    }
    else
    {
        // Update query
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getGender());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_HAIR_COLOR_ID));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_REST_STATE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));

        if (!IsBeingTeleported())
        {
            stmt->setUInt16(index++, (uint16)GetMapId());
            stmt->setUInt32(index++, (uint32)GetInstanceId());
            stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
            stmt->setFloat(index++, finiteAlways(GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetOrientation()));
        }
        else
        {
            stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
            stmt->setUInt32(index++, (uint32)0);
            stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
        }

        stmt->setFloat(index++, finiteAlways(GetTransOffsetX()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetY()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetZ()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetO()));
        uint32 transLowGUID = 0;
        if (GetTransport())
            transLowGUID = GetTransport()->GetGUIDLow();
        stmt->setUInt32(index++, transLowGUID);

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        //save, far from tavern/city
        //save, but in tavern/city
        stmt->setUInt32(index++, GetTalentResetCost());
        stmt->setUInt32(index++, GetTalentResetTime());

        ss.str("");
        for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
            ss << GetTalentSpecialization(i) << " ";
        stmt->setString(index++, ss.str());
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt8(index++,  m_stableSlots);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, GetZoneId());
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt16(index++, uint16(m_taxi.GetLastNodeIndex()));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetHealth());

        uint32 storedPowers = 0;
        for (uint32 i = 0; i < MAX_POWERS; ++i)
        {
            if (GetPowerIndex(i) != MAX_POWERS)
            {
                stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_POWER + storedPowers));
                if (++storedPowers >= MAX_POWERS_PER_CLASS)
                    break;
            }
        }

        for (; storedPowers < MAX_POWERS_PER_CLASS; ++storedPowers)
            stmt->setUInt32(index++, 0);

        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetSpecsCount());
        stmt->setUInt8(index++, GetActiveSpec());

        ss.str("");
        for (uint32 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");
        // cache equipment...
        for (uint32 i = 0; i < EQUIPMENT_SLOT_END * 2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + i) << ' ';

        // ...and bags for enum opcode
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                ss << item->GetEntry();
            else
                ss << '0';
            ss << " 0 ";
        }

        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';

        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, GetByteValue(PLAYER_FIELD_LIFETIME_MAX_RANK, 2));
        stmt->setUInt32(index++, m_grantableLevels);

        stmt->setUInt8(index++, IsInWorld() && !GetSession()->PlayerLogout() ? 1 : 0);
        stmt->setUInt32(index++, GetLootSpecialization());
        // Index
        stmt->setUInt32(index++, GetGUIDLow());
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    trans->Append(stmt);

    if (m_mailsUpdated)                                     //save mails only when needed
        _SaveMail(trans);

    _SaveBGData(trans);
    _SaveInventory(trans);
    _SaveVoidStorage(trans);
    _SaveQuestStatus(trans);
    _SaveQuestObjectiveStatus(trans);
    _SaveDailyQuestStatus(trans);
    _SaveWeeklyQuestStatus(trans);
    _SaveSeasonalQuestStatus(trans);
    _SaveMonthlyQuestStatus(trans);
    _SaveTalents(trans);
    _SaveSpells(trans);
    GetSpellHistory()->SaveToDB<Player>(trans);
    _SaveActions(trans);
    _SaveAuras(trans);
    _SaveSkills(trans);
    GetAchievementMgr().SaveToDB(trans);
    GetSession()->GetAchievementMgr().SaveToDB(trans);
    m_reputationMgr->SaveToDB(trans);
    _SaveEquipmentSets(trans);
    GetSession()->SaveTutorialsData(trans);                 // changed only while character in game
    _SaveGlyphs(trans);
    _SaveInstanceTimeRestrictions(trans);
    _SaveCurrency(trans);
    _SaveCUFProfiles(trans);
    _SaveResearchHistory(trans);
    _SaveResearchProjects(trans);
    _SaveDeserterInfo(trans);
    _SaveBattlegroundStats(trans);
    m_battlePetMgr->SaveToDb(trans);

    // check if stats should only be saved on logout
    // save stats can be out of transaction
    if (m_session->isLogingOut() || !sWorld->getBoolConfig(CONFIG_STATS_SAVE_ONLY_ON_LOGOUT))
        _SaveStats(trans);

    CharacterDatabase.CommitTransaction(trans);

    // save pet (hunter pet level and experience and all type pets health/mana).
    if (Pet* pet = GetPet())
        pet->SavePetToDB();

    if (GetSession()->GetMute().Timer > 0)
        LoginDatabase.PExecute("UPDATE mute_active SET mute_timer = '%u' WHERE realmid = '%u' AND account = '%u'", GetSession()->GetMute().Timer, realmID, GetSession()->GetAccountId());

    // we save the data here to prevent spamming
    sAnticheatMgr->SavePlayerData(this);
}

// fast save function for item/money cheating preventing - save only inventory and money state
void Player::SaveInventoryAndGoldToDB(SQLTransaction& trans)
{
    _SaveInventory(trans);
    _SaveCurrency(trans);
    SaveGoldToDB(trans);
}

void Player::SaveGoldToDB(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
    stmt->setUInt64(0, GetMoney());
    stmt->setUInt32(1, GetGUIDLow());
    trans->Append(stmt);
}

void Player::_SaveActions(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
    {
        switch (itr->second.uState)
        {
            case ACTIONBUTTON_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt8(1, GetActiveSpec());
                stmt->setUInt8(2, itr->first);
                stmt->setUInt32(3, itr->second.GetAction());
                stmt->setUInt8(4, uint8(itr->second.GetType()));
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
                stmt->setUInt32(0, itr->second.GetAction());
                stmt->setUInt8(1, uint8(itr->second.GetType()));
                stmt->setUInt32(2,  GetGUIDLow());
                stmt->setUInt8(3, itr->first);
                stmt->setUInt8(4, GetActiveSpec());
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_DELETED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt8(1, itr->first);
                stmt->setUInt8(2, GetActiveSpec());
                trans->Append(stmt);

                m_actionButtons.erase(itr++);
                break;
            default:
                ++itr;
                break;
        }
    }
}

void Player::_SaveAuras(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
    {
        if (!itr->second->CanBeSaved())
            continue;

        Aura* aura = itr->second;
        auto aurApp = GetAuraApplication(aura->GetId(), aura->GetCasterGUID(), aura->GetCastItemGUID());
        if (!aurApp)
            continue;

        uint32 effMask = 0;
        uint32 recalculateMask = 0;
        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
        {
            if (auto effect = aura->GetEffect(i))
            {
                uint32 index = 0;
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AURA_EFFECT);
                stmt->setUInt32(index++, GetGUIDLow());
                stmt->setUInt8(index++, aurApp->GetSlot());
                stmt->setUInt8(index++, i);
                stmt->setInt32(index++, effect->GetBaseAmount());
                stmt->setInt32(index++, effect->GetAmount());
                trans->Append(stmt);

                effMask |= 1 << i;
                if (effect->CanBeRecalculated())
                    recalculateMask |= 1 << i;
            }
        }

        uint8 index = 0;
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AURA);
        stmt->setUInt32(index++, GetGUIDLow());
        stmt->setUInt64(index++, itr->second->GetCasterGUID());
        stmt->setUInt64(index++, itr->second->GetCastItemGUID());
        stmt->setUInt32(index++, itr->second->GetId());
        stmt->setUInt32(index++, effMask);
        stmt->setUInt32(index++, recalculateMask);
        stmt->setUInt8(index++, itr->second->GetStackAmount());
        stmt->setInt32(index++, itr->second->GetMaxDuration());
        stmt->setInt32(index++, itr->second->GetDuration());
        stmt->setUInt8(index++, itr->second->GetCharges());
        stmt->setUInt8(index++, aurApp->GetSlot());
        trans->Append(stmt);
    }
}

void Player::_SaveInventory(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // force items in buyback slots to new state
    // and remove those that aren't already
    for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
    {
        Item* item = m_items[i];
        if (!item || item->GetState() == ITEM_NEW)
            continue;

        sServiceMgr->DeletedItemNotify(GetGUIDLow(), item, DELETING_TYPE_VENDOR);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
        stmt->setUInt32(0, item->GetGUIDLow());
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
        stmt->setUInt32(0, item->GetGUIDLow());
        trans->Append(stmt);
        m_items[i]->FSetState(ITEM_NEW);
    }

    // Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
    // the client auto counts down in real time after having received the initial played time on the first
    // SMSG_ITEM_REFUND_INFO_RESPONSE packet.
    // Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
    std::set<uint32>::iterator i_next;
    for (std::set<uint32>::iterator itr = m_refundableItems.begin(); itr!= m_refundableItems.end(); itr = i_next)
    {
        // use copy iterator because itr may be invalid after operations in this loop
        i_next = itr;
        ++i_next;

        Item* iPtr = GetItemByGuid(MAKE_NEW_GUID(*itr, 0, HIGHGUID_ITEM));
        if (iPtr)
        {
            iPtr->UpdatePlayedTime(this);
            continue;
        }
        else
        {
            TC_LOG_ERROR("entities.player", "Can't find item guid %u but is in refundable storage for player %u ! Removing.", *itr, GetGUIDLow());
            m_refundableItems.erase(itr);
        }
    }

    // update enchantment durations
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);

    // if no changes
    if (m_itemUpdateQueue.empty())
        return;

    uint32 lowGuid = GetGUIDLow();
    for (size_t i = 0; i < m_itemUpdateQueue.size(); ++i)
    {
        Item* item = m_itemUpdateQueue[i];
        if (!item)
            continue;

        Bag* container = item->GetContainer();
        uint32 bag_guid = container ? container->GetGUIDLow() : 0;

        if (item->GetState() != ITEM_REMOVED)
        {
            Item* test = GetItemByPos(item->GetBagSlot(), item->GetSlot());
            if (test == NULL)
            {
                uint32 bagTestGUID = 0;
                if (Item* test2 = GetItemByPos(INVENTORY_SLOT_BAG_0, item->GetBagSlot()))
                    bagTestGUID = test2->GetGUIDLow();
                TC_LOG_ERROR("entities.player", "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName().c_str(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
                // according to the test that was just performed nothing should be in this slot, delete
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT);
                stmt->setUInt32(0, bagTestGUID);
                stmt->setUInt8(1, item->GetSlot());
                stmt->setUInt32(2, lowGuid);
                trans->Append(stmt);

                // also THIS item should be somewhere else, cheat attempt
                item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
                DeleteRefundReference(item->GetGUIDLow());
                // don't skip, let the switch delete it
                //continue;
            }
            else if (test != item)
            {
                TC_LOG_ERROR("entities.player", "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u are incorrect, the item with guid %u is there instead!", lowGuid, GetName().c_str(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), test->GetGUIDLow());
                // save all changes to the item...
                if (item->GetState() != ITEM_NEW) // only for existing items, no dupes
                    item->SaveToDB(trans);
                // ...but do not save position in inventory
                continue;
            }
        }

        switch (item->GetState())
        {
            case ITEM_NEW:
                // Remove record about deleted item, if it was recovered from buyback slot after it has already been saved
                if (item->HasDeletedItemRecord())
                {
                    CharacterDatabase.PQuery("DELETE FROM item_deleted WHERE old_item_guid = '%u' AND owner_guid = '%u'", item->GetGUIDLow(), GetGUIDLow());
                    item->SetHasDeletedItemRecord(false);
                }
                // no break
            case ITEM_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_INVENTORY_ITEM);
                stmt->setUInt32(0, lowGuid);
                stmt->setUInt32(1, bag_guid);
                stmt->setUInt8 (2, item->GetSlot());
                stmt->setUInt32(3, item->GetGUIDLow());
                trans->Append(stmt);
                break;
            case ITEM_REMOVED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
                stmt->setUInt32(0, item->GetGUIDLow());
                trans->Append(stmt);
            case ITEM_UNCHANGED:
                break;
        }

        item->SaveToDB(trans);                                   // item have unchanged inventory record and can be save standalone
    }
    m_itemUpdateQueue.clear();
}

void Player::_SaveVoidStorage(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    uint32 lowGuid = GetGUIDLow();

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (!_voidStorageItems[i]) // unused item
        {
            // DELETE FROM void_storage WHERE slot = ? AND playerGuid = ?
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM_BY_SLOT);
            stmt->setUInt8(0, i);
            stmt->setUInt32(1, lowGuid);
        }
        else
        {
            // REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_VOID_STORAGE_ITEM);
            stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
            stmt->setUInt32(1, lowGuid);
            stmt->setUInt32(2, _voidStorageItems[i]->ItemEntry);
            stmt->setUInt8(3, i);
            stmt->setUInt32(4, _voidStorageItems[i]->CreatorGuid);
            stmt->setUInt32(5, _voidStorageItems[i]->ItemRandomPropertyId);
            stmt->setUInt32(6, _voidStorageItems[i]->ItemSuffixFactor);
            stmt->setUInt32(7, _voidStorageItems[i]->ItemUpgradeId);
        }

        trans->Append(stmt);
    }
}


void Player::_SaveCUFProfiles(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    uint32 lowGuid = GetGUIDLow();

    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
    {
        if (!_CUFProfiles[i]) // unused profile
        {
            // DELETE FROM character_cuf_profiles WHERE guid = ? and id = ?
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_CUF_PROFILES);
            stmt->setUInt32(0, lowGuid);
            stmt->setUInt8(1, i);
        }
        else
        {
            // REPLACE INTO character_cuf_profiles (guid, id, name, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_CUF_PROFILES);
            stmt->setUInt32(0, lowGuid);
            stmt->setUInt8(1, i);
            stmt->setString(2, _CUFProfiles[i]->ProfileName);
            stmt->setUInt16(3, _CUFProfiles[i]->FrameHeight);
            stmt->setUInt16(4, _CUFProfiles[i]->FrameWidth);
            stmt->setUInt8(5, _CUFProfiles[i]->SortBy);
            stmt->setUInt8(6, _CUFProfiles[i]->HealthText);
            stmt->setUInt32(7, _CUFProfiles[i]->BoolOptions.to_ulong()); // 27 of 32 fields used, fits in an int
            stmt->setUInt8(8, _CUFProfiles[i]->Unk146);
            stmt->setUInt8(9, _CUFProfiles[i]->Unk147);
            stmt->setUInt8(10, _CUFProfiles[i]->Unk148);
            stmt->setUInt16(11, _CUFProfiles[i]->Unk150);
            stmt->setUInt16(12, _CUFProfiles[i]->Unk152);
            stmt->setUInt16(13, _CUFProfiles[i]->Unk154);
        }

        trans->Append(stmt);
    }
}

void Player::_SaveMail(SQLTransaction& trans)
{
    if (!m_mailsLoaded)
        return;

    PreparedStatement* stmt = NULL;

    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        Mail* m = (*itr);
        if (m->state == MAIL_STATE_CHANGED)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
            stmt->setUInt32(1, uint32(m->expire_time));
            stmt->setUInt32(2, uint32(m->deliver_time));
            stmt->setUInt32(3, m->money);
            stmt->setUInt32(4, m->COD);
            stmt->setUInt32(5, uint32(m->checked));
            stmt->setUInt32(6, m->messageID);

            trans->Append(stmt);

            if (!m->removedItems.empty())
            {
                for (std::vector<uint32>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
                    stmt->setUInt32(0, *itr2);
                    trans->Append(stmt);
                }
                m->removedItems.clear();
            }
            m->state = MAIL_STATE_UNCHANGED;
        }
        else if (m->state == MAIL_STATE_DELETED)
        {
            if (m->HasItems())
            {
                for (MailItemInfoVec::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                    stmt->setUInt32(0, itr2->item_guid);
                    trans->Append(stmt);
                }
            }
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);
        }
    }

    //deallocate deleted mails...
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end();)
    {
        if ((*itr)->state == MAIL_STATE_DELETED)
        {
            Mail* m = *itr;
            m_mail.erase(itr);
            delete m;
            itr = m_mail.begin();
        }
        else
            ++itr;
    }

    m_mailsUpdated = false;
}

void Player::_SaveQuestStatus(SQLTransaction& trans)
{
    bool isTransaction = trans != nullptr;
    if (!isTransaction)
        trans = CharacterDatabase.BeginTransaction();

    QuestStatusSaveMap::iterator saveItr;
    QuestStatusMap::iterator statusItr;
    PreparedStatement* stmt = nullptr;

    for (saveItr = m_QuestStatusSave.begin(); saveItr != m_QuestStatusSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            statusItr = m_QuestStatus.find(saveItr->first);
            if (statusItr != m_QuestStatus.end() && statusItr->second.Status != QUEST_STATUS_NONE)
            {
                uint8 index = 0;
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);

                stmt->setUInt32(index++, GetGUIDLow());
                stmt->setUInt32(index++, statusItr->first);
                stmt->setUInt8(index++, uint8(statusItr->second.Status));
                stmt->setBool(index++, statusItr->second.Explored);
                stmt->setUInt32(index++, uint32(statusItr->second.Timer / IN_MILLISECONDS+ sWorld->GetGameTime()));

                trans->Append(stmt);
            }
        }
        else
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    m_QuestStatusSave.clear();

    for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
    {
        if (saveItr->second)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS_REWARDED);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);

        }
        else
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, saveItr->first);
            trans->Append(stmt);
        }
    }

    m_RewardedQuestsSave.clear();

    if (!isTransaction)
        CharacterDatabase.CommitTransaction(trans);
}

void Player::_SaveQuestObjectiveStatus(SQLTransaction& trans)
{
    for (auto&& it : m_questObjectiveStatusSave)
    {
        if (!sObjectMgr->GetQuestObjectiveQuestId(it.first))
            continue;

        if (it.second)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, it.first);
            stmt->setUInt32(2, GetQuestObjectiveCounter(it.first));
            trans->Append(stmt);
        }
        else
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVE);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, it.first);
            trans->Append(stmt);
        }
    }

    m_questObjectiveStatusSave.clear();
}

void Player::_SaveDailyQuestStatus(SQLTransaction& trans)
{
    if (!m_DailyQuestChanged)
        return;

    m_DailyQuestChanged = false;

    // save last daily quest time for all quests: we need only mostly reset time for reset check anyway

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_CHAR);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);
    for (auto&& it : m_dailyquests)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, it);
        stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
        trans->Append(stmt);
    }
}

void Player::_SaveWeeklyQuestStatus(SQLTransaction& trans)
{
    if (!m_WeeklyQuestChanged || m_weeklyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY_CHAR);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_weeklyquests.begin(); iter != m_weeklyquests.end(); ++iter)
    {
        uint32 quest_id  = *iter;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WEEKLYQUESTSTATUS);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_WeeklyQuestChanged = false;
}

void Player::_SaveSeasonalQuestStatus(SQLTransaction& trans)
{
    if (!m_SeasonalQuestChanged || m_seasonalquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL_CHAR);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (SeasonalEventQuestMap::const_iterator iter = m_seasonalquests.begin(); iter != m_seasonalquests.end(); ++iter)
    {
        uint16 event_id = iter->first;
        for (SeasonalQuestSet::const_iterator itr = iter->second.begin(); itr != iter->second.end(); ++itr)
        {
            uint32 quest_id = (*itr);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, quest_id);
            stmt->setUInt32(2, event_id);
            trans->Append(stmt);
        }
    }

    m_SeasonalQuestChanged = false;
}

void Player::_SaveMonthlyQuestStatus(SQLTransaction& trans)
{
    if (!m_MonthlyQuestChanged || m_monthlyquests.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_MONTHLY_CHAR);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (QuestSet::const_iterator iter = m_monthlyquests.begin(); iter != m_monthlyquests.end(); ++iter)
    {
        uint32 quest_id = *iter;
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_MONTHLYQUESTSTATUS);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, quest_id);
        trans->Append(stmt);
    }

    m_MonthlyQuestChanged = false;
}

void Player::_SaveSkills(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // we don't need transactions here.
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
    {
        if (itr->second.uState == SKILL_UNCHANGED)
        {
            ++itr;
            continue;
        }

        if (itr->second.uState == SKILL_DELETED)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, itr->first);
            trans->Append(stmt);

            mSkillStatus.erase(itr++);
            continue;
        }

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1;

        uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset);
        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset);

        switch (itr->second.uState)
        {
            case SKILL_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt16(1, uint16(itr->first));
                stmt->setUInt16(2, value);
                stmt->setUInt16(3, max);
                trans->Append(stmt);
                break;
            case SKILL_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
                stmt->setUInt16(0, value);
                stmt->setUInt16(1, max);
                stmt->setUInt32(2, GetGUIDLow());
                stmt->setUInt16(3, uint16(itr->first));
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.uState = SKILL_UNCHANGED;
        ++itr;
    }
}

void Player::_SaveSpells(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end();)
    {
        if (itr->second->state == PLAYERSPELL_TEMPORARY)
        {
            ++itr;
            continue;
        }

        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
        {
            if (SpellInfo const* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if ((spell->IsAbilityOfSkillType(SKILL_MOUNTS) && !(spell->AttributesEx10 & SPELL_ATTR10_MOUNT_CHARACTER))
                    || spell->IsAbilityOfSkillType(SKILL_COMPANIONS) || spell->Effects[EFFECT_0].Effect == SPELL_EFFECT_UNLOCK_BATTLE_PETS)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_SPELL_BY_SPELL);
                    stmt->setUInt32(1, GetSession()->GetAccountId());
                }
                else
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
                    stmt->setUInt32(1, GetGUIDLow());
                }
                stmt->setUInt32(0, itr->first);
                trans->Append(stmt);
            }
        }

        // add only changed/new not dependent spells
        if (!itr->second->dependent && (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED))
        {
            if (SpellInfo const* spell = sSpellMgr->GetSpellInfo(itr->first))
            {
                if (spell->IsAccountWide())
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ACCOUNT_SPELL);
                    stmt->setUInt32(0, GetSession()->GetAccountId());
                }
                else
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
                    stmt->setUInt32(0, GetGUIDLow());
                }

                stmt->setUInt32(1, itr->first);
                stmt->setBool(2, itr->second->active);
                stmt->setBool(3, itr->second->disabled);
                trans->Append(stmt);
            }
        }

        if (itr->second->state == PLAYERSPELL_REMOVED)
        {
            delete itr->second;
            m_spells.erase(itr++);
        }
        else
        {
            itr->second->state = PLAYERSPELL_UNCHANGED;
            ++itr;
        }
    }
}

// save player stats -- only for external usage
// real stats will be recalculated on player login
void Player::_SaveStats(SQLTransaction& trans)
{
    // check if stat saving is enabled and if char level is high enough
    if (!sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE) || getLevel() < sWorld->getIntConfig(CONFIG_MIN_LEVEL_STAT_SAVE))
        return;

    PreparedStatement* stmt = NULL;

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_STATS);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    uint8 index = 0;

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_STATS);
    stmt->setUInt32(index++, GetGUIDLow());
    stmt->setUInt32(index++, GetMaxHealth());

    for (uint8 i = 0; i < MAX_POWERS_PER_CLASS; ++i)
        stmt->setUInt32(index++, GetMaxPower(Powers(i)));

    for (uint8 i = 0; i < MAX_STATS; ++i)
        stmt->setUInt32(index++, GetStat(Stats(i)));

    for (int i = 0; i < MAX_SPELL_SCHOOL; ++i)
        stmt->setUInt32(index++, GetResistance(SpellSchools(i)));

    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE));
    stmt->setFloat(index++, GetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_ATTACK_POWER));
    stmt->setUInt32(index++, GetUInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER));
    stmt->setUInt32(index++, GetBaseSpellPowerBonus());
    stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + CR_RESILIENCE_PLAYER_DAMAGE_TAKEN));

    trans->Append(stmt);
}

void Player::outDebugValues() const
{
    if (!sLog->ShouldLog("entities.unit", LOG_LEVEL_DEBUG))
        return;

    TC_LOG_DEBUG("entities.unit", "HP is: \t\t\t%u\t\tMP is: \t\t\t%u", GetMaxHealth(), GetMaxPower(POWER_MANA));
    TC_LOG_DEBUG("entities.unit", "AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
    TC_LOG_DEBUG("entities.unit", "INTELLECT is: \t\t%f\t\tSPIRIT is: \t\t%f", GetStat(STAT_INTELLECT), GetStat(STAT_SPIRIT));
    TC_LOG_DEBUG("entities.unit", "STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
    TC_LOG_DEBUG("entities.unit", "Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    TC_LOG_DEBUG("entities.unit", "HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
    TC_LOG_DEBUG("entities.unit", "NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
    TC_LOG_DEBUG("entities.unit", "ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
    TC_LOG_DEBUG("entities.unit", "MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MIN_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_DAMAGE));
    TC_LOG_DEBUG("entities.unit", "MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE));
    TC_LOG_DEBUG("entities.unit", "MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE));
    TC_LOG_DEBUG("entities.unit", "ATTACK_TIME is: \t%u\t\tRANGE_ATTACK_TIME is: \t%u", GetAttackTime(BASE_ATTACK), GetAttackTime(RANGED_ATTACK));
}

/*********************************************************/
/***               FLOOD FILTER SYSTEM                 ***/
/*********************************************************/

void Player::UpdateSpeakTime()
{
    // ignore chat spam protection for GMs in any mode
    if (GetSession()->GetSecurity() > SEC_PLAYER)
        return;

    time_t current = time (NULL);
    if (m_speakTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_COUNT);
        if (!max_count)
            return;

        ++m_speakCount;
        if (m_speakCount >= max_count)
        {
            // prevent overwrite mute time, if message send just before mutes set, for example.
            time_t new_mute = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MUTE_TIME);
            if (GetSession()->m_muteTime < new_mute)
                GetSession()->m_muteTime = new_mute;

            m_speakCount = 0;
        }
    }
    else
        m_speakCount = 0;

    m_speakTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_DELAY);
}

bool Player::CanSpeak() const
{
    return GetSession()->m_muteTime <= time (NULL);
}

/*********************************************************/
/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
/*********************************************************/

void Player::SavePositionInDB(uint32 mapid, float x, float y, float z, float o, uint32 zone, uint64 guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);

    stmt->setFloat(0, x);
    stmt->setFloat(1, y);
    stmt->setFloat(2, z);
    stmt->setFloat(3, o);
    stmt->setUInt16(4, uint16(mapid));
    stmt->setUInt16(5, uint16(zone));
    stmt->setUInt32(6, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
}

void Player::SetUInt32ValueInArray(Tokenizer& Tokenizer, uint16 index, uint32 value)
{
    char buf[11];
    snprintf(buf, 11, "%u", value);

    if (index >= Tokenizer.size())
        return;

    Tokenizer[index] = buf;
}

void Player::Customize(uint64 guid, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PLAYERBYTES2);
    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return;

    Field* fields = result->Fetch();

    uint32 playerBytes2 = fields[0].GetUInt32();
    playerBytes2 &= ~0xFF;
    playerBytes2 |= facialHair;

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);

    stmt->setUInt8(0, gender);
    stmt->setUInt32(1, skin | (face << 8) | (hairStyle << 16) | (hairColor << 24));
    stmt->setUInt32(2, playerBytes2);
    stmt->setUInt32(3, GUID_LOPART(guid));

    CharacterDatabase.Execute(stmt);
}

void Player::SendAttackSwingResult(AttackSwingResult result) const
{
    WorldPacket data(SMSG_ATTACK_SWING_ERROR);
    data.WriteBits(result, 2);
    data.FlushBits();

    GetSession()->SendPacket(&data);
}

void Player::SendAttackSwingCancelAttack()
{
    WorldPacket data(SMSG_CANCEL_COMBAT, 0);
    GetSession()->SendPacket(&data);
}

void Player::SendAutoRepeatCancel(Unit* target)
{
    WorldPacket data(SMSG_CANCEL_AUTO_REPEAT, 8);
    ObjectGuid Guid = target->GetGUID();

    data.WriteBit(Guid[1]);
    data.WriteBit(Guid[3]);
    data.WriteBit(Guid[0]);
    data.WriteBit(Guid[4]);
    data.WriteBit(Guid[6]);
    data.WriteBit(Guid[7]);
    data.WriteBit(Guid[5]);
    data.WriteBit(Guid[2]);

    data.WriteByteSeq(Guid[7]);
    data.WriteByteSeq(Guid[6]);
    data.WriteByteSeq(Guid[2]);
    data.WriteByteSeq(Guid[5]);
    data.WriteByteSeq(Guid[0]);
    data.WriteByteSeq(Guid[4]);
    data.WriteByteSeq(Guid[1]);
    data.WriteByteSeq(Guid[3]);
    GetSession()->SendPacket(&data);
}

void Player::SendExplorationExperience(uint32 Area, uint32 Experience)
{
    WorldPacket data(SMSG_EXPLORATION_EXPERIENCE, 8);
    data << uint32(Area);
    data << uint32(Experience);
    GetSession()->SendPacket(&data);
}

void Player::SendDungeonDifficulty(uint32 difficulty)
{
    WorldPacket data(SMSG_SET_DUNGEON_DIFFICULTY, 4);
    data << uint32(difficulty);
    GetSession()->SendPacket(&data);
}

void Player::SendRaidDifficulty(uint32 difficulty)
{
    WorldPacket data(SMSG_SET_RAID_DIFFICULTY, 4);
    data << uint32(difficulty);
    GetSession()->SendPacket(&data);
}

void Player::SendResetFailedNotify(uint32 /*mapid*/)
{
    WorldPacket data(SMSG_RESET_FAILED_NOTIFY);
    GetSession()->SendPacket(&data);
}

/// Reset all solo instances and optionally send a message on success for each
void Player::ResetInstances(uint8 method, bool isRaid)
{
    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN

    // we assume that when the difficulty changes, all instances that can be reset will be
    Difficulty diff = GetDifficulty(isRaid);

    for (BoundInstancesMap::iterator itr = m_boundInstances[diff].begin(); itr != m_boundInstances[diff].end();)
    {
        InstanceSave* p = itr->second.save;
        const MapEntry* entry = sMapStore.LookupEntry(itr->first);
        if (!entry || entry->IsRaid() != isRaid || !p->CanReset())
        {
            ++itr;
            continue;
        }

        if (method == INSTANCE_RESET_ALL)
        {
            // the "reset all instances" method can only reset normal maps
            if (entry->map_type == MAP_RAID || diff > DUNGEON_DIFFICULTY_NORMAL && diff != DUNGEON_DIFFICULTY_CHALLENGE && diff != SCENARIO_DIFFICULTY_NORMAL)
            {
                ++itr;
                continue;
            }
        }

        // if the map is loaded, reset it
        Map* map = sMapMgr->FindMap(p->GetMapId(), p->GetInstanceId());
        if (map && map->IsDungeon())
            if (!((InstanceMap*)map)->Reset(method))
            {
                ++itr;
                continue;
            }

        // since this is a solo instance there should not be any players inside
        if (method == INSTANCE_RESET_ALL || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
            SendResetInstanceSuccess(p->GetMapId());

        p->DeleteFromDB();
        m_boundInstances[diff].erase(itr++);

        // the following should remove the instance save from the manager and delete it as well
        p->RemovePlayer(this);
    }
}

void Player::SendResetInstanceSuccess(uint32 MapId)
{
    WorldPacket data(SMSG_INSTANCE_RESET, 4);
    data << uint32(MapId);
    GetSession()->SendPacket(&data);
}

void Player::SendResetInstanceFailed(uint32 reason, uint32 MapId)
{
    /*reasons for instance reset failure:
    // 0: There are players inside the instance.
    // 1: There are players offline in your party.
    // 2>: There are players in your party attempting to zone into an instance.
    */
    WorldPacket data(SMSG_INSTANCE_RESET_FAILED, 1 + 4);
    data.WriteBits(reason, 2);
    data.FlushBits();
    data << uint32(MapId);
    GetSession()->SendPacket(&data);
}

/*********************************************************/
/***              Update timers                        ***/
/*********************************************************/

///checks the 15 afk reports per 5 minutes limit
void Player::UpdateAfkReport(time_t currTime)
{
    if (m_bgData.bgAfkReportedTimer <= currTime)
    {
        m_bgData.bgAfkReportedCount = 0;
        m_bgData.bgAfkReportedTimer = currTime+5*MINUTE;
    }
}

void Player::UpdateContestedPvP(uint32 diff)
{
    if (!m_contestedPvPTimer||IsInCombat())
        return;
    if (m_contestedPvPTimer <= diff)
    {
        ResetContestedPvP();
    }
    else
        m_contestedPvPTimer -= diff;
}

void Player::ResetContestedPvP()
{
    ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
    m_contestedPvPTimer = 0;
}

void Player::UpdatePvPFlag(time_t currTime)
{
    if (!IsPvP())
        return;

    if (pvpInfo.IsHostile)
        return;

    TimeValue now = Seconds(currTime);
    if (pvpInfo.LastPvPTime && now > pvpInfo.LastPvPTime + Seconds(5))
    {
        // We leave acive PvP
        pvpInfo.LastPvPTime = TimeValue::zero();
        // And player has disabled pvp
        if (!HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
            StartPvPOffTimer();
        return;
    }

    // Okay, now just countdown to complete disable pvp
    if (pvpInfo.OffTime && now > pvpInfo.OffTime)
        DisablePvP();
}

void Player::UpdateDuelFlag(time_t currTime)
{
    if (!duel || duel->startTimer == 0 ||currTime < duel->startTimer + 3)
        return;

    sScriptMgr->OnPlayerDuelStart(this, duel->opponent);

    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 1);
    duel->opponent->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 2);

    duel->startTimer = 0;
    duel->startTime  = currTime;
    duel->opponent->duel->startTimer = 0;
    duel->opponent->duel->startTime  = currTime;
}

Pet* Player::GetPet() const
{
    if (uint64 pet_guid = GetPetGUID())
    {
        if (!IS_PET_GUID(pet_guid))
            return NULL;

        Pet* pet = ObjectAccessor::GetPet(*this, pet_guid);

        if (!pet)
            return NULL;

        if (IsInWorld() && pet)
            return pet;

        //there may be a guardian in slot
        //TC_LOG_ERROR("entities.player", "Player::GetPet: Pet %u not exist.", GUID_LOPART(pet_guid));
        //const_cast<Player*>(this)->SetPetGUID(0);
    }

    return NULL;
}

void Player::RemovePet(PetRemoveMode mode, int32 flags)
{
    Pet* pet = GetPet();
    if (!pet || pet->m_removed)
        return;

    {
        if ((flags & PET_REMOVE_FLAG_RETURN_REAGENT) && !InBattleground())
        {
            // returning of reagents only for players, so best done here
            uint32 spellId = pet->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL);
            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
            {
                for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
                {
                    if (spellInfo->Reagent[i] <= 0)
                        continue;

                    ItemPosCountVec dest;
                    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, spellInfo->Reagent[i], spellInfo->ReagentCount[i]);
                    if (msg != EQUIP_ERR_OK)
                        continue;

                    Item* item = StoreNewItem(dest, spellInfo->Reagent[i], true);
                    if (IsInWorld())
                        SendNewItem(item, spellInfo->ReagentCount[i], true, false);
                    sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::Spell, spellInfo->Id);
                }
            }
        }

        if (mode == PET_REMOVE_DISMISS)
        {
            pet->SavePetToDB();
            if (flags & PET_REMOVE_FLAG_RESET_CURRENT)
            {
                SetCurrentPetId(0);
                // If pet was removed we need to clear last pet number
                if (!(flags & PET_REMOVE_FLAG_RETURN_REAGENT))
                    SetLastPetNumber((1 << 31) | pet->GetEntry());
            }

            // temporarily unsummon battle pet (2)
            if (TempSummon* tempSummon = GetBattlePetMgr().GetCurrentSummon())
                GetBattlePetMgr().UnSummonCurrentBattlePet(true);
        }
        else
        {
            pet->DeletePetFromDB();
            for (auto itr = m_petList.begin(); itr != m_petList.end(); ++itr)
            {
                if (itr->second.PetNumber == pet->GetCharmInfo()->GetPetNumber())
                {
                    m_petList.erase(itr);
                    break;
                }
            }
            // Updating data in DB is not required, it will be done by FK at delete
            SetCurrentPetId(0);
            SetLastPetNumber(0);
        }
    }

    pet->CombatStop();

    SetMinion(pet, false);

    pet->AddObjectToRemoveList();
    pet->m_removed = true;

    if (pet->isControlled() && !pet->IsTemporary())
    {
        ObjectGuid Guid;
        WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8);

        data.WriteBit(Guid[7]);
        data.WriteBit(Guid[4]);
        data.WriteBits(0, 21);     // cooldowns count
        data.WriteBits(0, 22);     // spells count
        data.WriteBit(Guid[2]);
        data.WriteBits(0, 20);     // CooldownCount
        data.WriteBit(Guid[5]);
        data.WriteBit(Guid[3]);
        data.WriteBit(Guid[6]);
        data.WriteBit(Guid[0]);
        data.WriteBit(Guid[1]);

        data.FlushBits();

        data.WriteByteSeq(Guid[2]);
        data.WriteByteSeq(Guid[7]);
        data.WriteByteSeq(Guid[0]);
        data.WriteByteSeq(Guid[3]);
        data << uint16(0);
        data << uint16(0);
        data.WriteByteSeq(Guid[1]);
        data.WriteByteSeq(Guid[4]);
        data.WriteByteSeq(Guid[6]);
        data << uint32(0);
        data.WriteByteSeq(Guid[5]);
        data << uint32(0);

        GetSession()->SendPacket(&data);

        if (GetGroup())
            SetGroupUpdateFlag(GROUP_UPDATE_PET);
    }
}

void Player::StopCastingCharm()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    if (charm->GetTypeId() == TYPEID_UNIT)
    {
        if (charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET))
            ((Puppet*)charm)->UnSummon();
        else if (charm->IsVehicle())
            ExitVehicle();
    }
    if (GetCharmGUID())
        charm->RemoveCharmAuras();

    if (GetCharmGUID())
    {
        TC_LOG_FATAL("entities.player", "Player %s (GUID: " UI64FMTD " is not able to uncharm unit (GUID: " UI64FMTD " Entry: %u, Type: %u)", GetName().c_str(), GetGUID(), GetCharmGUID(), charm->GetEntry(), charm->GetTypeId());
        if (charm->GetCharmerGUID())
        {
            TC_LOG_FATAL("entities.player", "Charmed unit has charmer guid " UI64FMTD, charm->GetCharmerGUID());
            ASSERT(false);
        }
        else
            SetCharm(charm, false);
    }
}

void Player::Say(const std::string& text, const uint32 language)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);

    WorldPacket data;
    ChatHandler::BuildChatPacket(data, CHAT_MSG_SAY, Language(language), this, this, text);
    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
}

void Player::Yell(const std::string& text, const uint32 language)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_YELL, language, _text);

    WorldPacket data;
    ChatHandler::BuildChatPacket(data, CHAT_MSG_YELL, Language(language), this, this, text);
    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL), true);
}

void Player::TextEmote(const std::string& text)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_EMOTE, LANG_UNIVERSAL, _text);

    WorldPacket data;
    ChatHandler::BuildChatPacket(data, CHAT_MSG_EMOTE, LANG_UNIVERSAL, this, this, text);
    SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE), true, !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT));
}

void Player::WhisperAddon(const std::string& text, const std::string& prefix, Player* receiver)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, LANG_UNIVERSAL, _text, receiver);

    if (!receiver->GetSession()->IsAddonRegistered(prefix))
        return;

    WorldPacket data;
    ChatHandler::BuildChatPacket(data, CHAT_MSG_WHISPER, LANG_ADDON, this, this, text, 0, "", DEFAULT_LOCALE, prefix);
    receiver->GetSession()->SendPacket(&data);
}

void Player::Whisper(const std::string& text, uint32 language, uint64 receiver)
{
    bool isAddonMessage = language == LANG_ADDON;

    if (!isAddonMessage) // if not addon data
        language = LANG_UNIVERSAL; // whispers should always be readable

    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);

    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, language, _text, rPlayer);

    WorldPacket data;
    ChatHandler::BuildChatPacket(data, CHAT_MSG_WHISPER, Language(language), this, this, text);
    rPlayer->GetSession()->SendPacket(&data);

    // rest stuff shouldn't happen in case of addon message
    if (isAddonMessage)
        return;

    ChatHandler::BuildChatPacket(data, CHAT_MSG_WHISPER_INFORM, Language(language), rPlayer, rPlayer, text);
    GetSession()->SendPacket(&data);

    if (!isAcceptWhispers() && !IsGameMaster() && !rPlayer->IsGameMaster())
    {
        SetAcceptWhispers(true);
        ChatHandler(GetSession()).SendSysMessage(LANG_COMMAND_WHISPERON);
    }

    // announce afk or dnd message
    if (rPlayer->isAFK())
        ChatHandler(GetSession()).PSendSysMessage(LANG_PLAYER_AFK, rPlayer->GetName().c_str(), rPlayer->autoReplyMsg.c_str());
    else if (rPlayer->isDND())
        ChatHandler(GetSession()).PSendSysMessage(LANG_PLAYER_DND, rPlayer->GetName().c_str(), rPlayer->autoReplyMsg.c_str());
}

void Player::SendPersonalMessage(std::string const& text, ChatMsg type, Language lang)
{
    WorldPacket data;
    ChatHandler::BuildChatPacket(data, type, lang, this, this, text);
    GetSession()->SendPacket(&data);
}

Item* Player::GetMItem(uint32 id)
{
    ItemMap::const_iterator itr = mMitems.find(id);
    return itr != mMitems.end() ? itr->second : NULL;
}

void Player::AddMItem(Item* it)
{
    ASSERT(it);
    //ASSERT deleted, because items can be added before loading
    mMitems[it->GetGUIDLow()] = it;
}

bool Player::RemoveMItem(uint32 id)
{
    return mMitems.erase(id) ? true : false;
}

void Player::SendOnCancelExpectedVehicleRideAura()
{
    WorldPacket data(SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA, 0);
    GetSession()->SendPacket(&data);
}

void Player::PetSpellInitialize()
{
    Pet* pet = GetPet();

    if (!pet || pet->IsTemporary())
        return;

    TC_LOG_DEBUG("entities.pet", "Pet Spells Groups");

    CharmInfo* charmInfo = pet->GetCharmInfo();
    ObjectGuid guid = pet->GetGUID();

    uint32 spellCount = 0;
    uint32 spellHistoryCount = 0;
    uint32 cooldownCount = 0;

    WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8 + 2 + 4 + 4 + 4 * MAX_UNIT_ACTION_BAR_INDEX + 1 + 1);

    data.WriteBit(guid[7]);
    data.WriteBit(guid[4]);
    data.WriteBits(spellHistoryCount, 21);
    size_t spellCountPos = data.bitwpos();
    data.WriteBits(spellCount, 22);               // Spell Count
    data.WriteBit(guid[2]);
    size_t cooldownCountPos = data.bitwpos();
    data.WriteBits(cooldownCount, 20);            // Cooldown Count
    data.WriteBit(guid[5]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[1]);

    data.FlushBits();

    // action bar loop
    charmInfo->BuildActionBar(&data);

    auto now = TimeValue::Now();

    for (auto&& itr : pet->GetSpellHistory()->GetCooldowns())
    {
        auto& entry = itr.second;

        auto cooldown = entry.CooldownEnd > now ? (entry.CooldownEnd - now).ToMilliseconds() : 0;
        auto categoryCooldown = entry.CategoryEnd > now ? (entry.CategoryEnd - now).ToMilliseconds() : 0;

        data << uint32(categoryCooldown);   // category cooldown
        data << uint32(entry.SpellId);      // spell ID
        data << uint16(entry.CategoryId);   // spell category
        data << uint32(cooldown);           // spell cooldown

        ++cooldownCount;
    }

    data.PutBits(cooldownCountPos, cooldownCount, 20);
    data.WriteByteSeq(guid[2]);

    // Spell data loop
    if (pet->IsPermanentPetFor(this))
    {
        for (auto&& itr : pet->m_spells)
        {
            if (itr.second.state == PETSPELL_REMOVED)
                continue;
            data << uint32(MAKE_UNIT_ACTION_BUTTON(itr.first, itr.second.active));
            ++spellCount;
        }
        data.PutBits(spellCountPos, spellCount, 22);
    }

    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[3]);
    data << uint16(pet->GetCreatureTemplate()->family); // Creature Family
    data << uint16(pet->GetSpecializationId());
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[6]);
    data << uint32(pet->GetDuration());
    data.WriteByteSeq(guid[5]);
    data << uint8(pet->GetReactState());
    data << uint8(pet->GetCharmInfo()->GetCommandState());
    data << uint16(0);                                  // flags ??

    GetSession()->SendPacket(&data);
}

void Player::PossessSpellInitialize()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    CharmInfo* charmInfo = charm->GetCharmInfo();

    if (!charmInfo)
    {
        TC_LOG_ERROR("entities.player", "Player::PossessSpellInitialize(): charm (" UI64FMTD ") has no charminfo!", charm->GetGUID());
        return;
    }

    ObjectGuid Guid = charm->GetGUID();
    WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+1);

    data.WriteBit(Guid[7]);
    data.WriteBit(Guid[4]);
    data.WriteBits(0, 21);     // cooldowns count
    data.WriteBits(0, 22);     // spells count
    data.WriteBit(Guid[2]);
    data.WriteBits(0, 20);     // CooldownCount
    data.WriteBit(Guid[5]);
    data.WriteBit(Guid[3]);
    data.WriteBit(Guid[6]);
    data.WriteBit(Guid[0]);
    data.WriteBit(Guid[1]);

    data.FlushBits();

    charmInfo->BuildActionBar(&data);
    data.WriteByteSeq(Guid[2]);
    data.WriteByteSeq(Guid[7]);
    data.WriteByteSeq(Guid[0]);
    data.WriteByteSeq(Guid[3]);
    data << uint16(0);
    data << uint16(0);
    data.WriteByteSeq(Guid[1]);
    data.WriteByteSeq(Guid[4]);
    data.WriteByteSeq(Guid[6]);
    data << uint32(0);
    data.WriteByteSeq(Guid[5]);
    data << uint32(0);
    
    GetSession()->SendPacket(&data);
}

void Player::VehicleSpellInitialize()
{
    Creature* vehicle = GetVehicleCreatureBase();
    if (!vehicle)
        return;

    uint8 cooldownCount = vehicle->m_CreatureSpellCooldowns.size();
    ObjectGuid VehicleGuid = vehicle->GetGUID();

    WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8 + 2 + 4 + 4 + 4 * 10 + 1 + 1 + cooldownCount * (4 + 2 + 4 + 4));

    data.WriteBit(VehicleGuid[7]);
    data.WriteBit(VehicleGuid[4]);
    data.WriteBits(0, 21);                     // spellHistoryCount
    data.WriteBits(0, 22);                     // spells count
    data.WriteBit(VehicleGuid[2]);
    data.WriteBits(cooldownCount, 20);         // CooldownCount
    data.WriteBit(VehicleGuid[5]);
    data.WriteBit(VehicleGuid[3]);
    data.WriteBit(VehicleGuid[6]);
    data.WriteBit(VehicleGuid[0]);
    data.WriteBit(VehicleGuid[1]);

    data.FlushBits();

    for (uint32 i = 0; i < CREATURE_MAX_SPELLS; ++i)
    {
        uint32 spellId = vehicle->m_spells[i];
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
        if (!spellInfo)
        {
            data << uint16(0) << uint8(0) << uint8(i + 8);
            continue;
        }

        ConditionList conditions = sConditionMgr->GetConditionsForVehicleSpell(vehicle->GetEntry(), spellId);
        if (!sConditionMgr->IsObjectMeetToConditions(this, vehicle, conditions))
        {
            TC_LOG_DEBUG("condition", "VehicleSpellInitialize: conditions not met for Vehicle entry %u spell %u", vehicle->ToCreature()->GetEntry(), spellId);
            data << uint16(0) << uint8(0) << uint8(i + 8);
            continue;
        }

        if (spellInfo->IsPassive())
            vehicle->CastSpell(vehicle, spellId, true);

        data << uint32(MAKE_UNIT_ACTION_BUTTON(spellId, i + 8));
    }

    for (uint32 i = CREATURE_MAX_SPELLS; i < MAX_SPELL_CONTROL_BAR; ++i)
        data << uint32(0);

    time_t now = sWorld->GetGameTime();

    for (CreatureSpellCooldowns::const_iterator itr = vehicle->m_CreatureSpellCooldowns.begin(); itr != vehicle->m_CreatureSpellCooldowns.end(); ++itr)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
        if (!spellInfo)
        {
            data << uint32(0);
            data << uint32(0);
            data << uint16(0);
            data << uint32(0);
            continue;
        }

        time_t cooldown = (itr->second > now) ? (itr->second - now) * IN_MILLISECONDS : 0;
        CreatureSpellCooldowns::const_iterator categoryitr = vehicle->m_CreatureCategoryCooldowns.find(spellInfo->GetCategory());
        if (categoryitr != vehicle->m_CreatureCategoryCooldowns.end())
        {
            time_t categoryCooldown = (categoryitr->second > now) ? (categoryitr->second - now) * IN_MILLISECONDS : 0;
            data << uint32(categoryCooldown);           // category cooldown
            data << uint32(itr->first);                 // spell ID
            data << uint16(spellInfo->GetCategory());   // spell category
            data << uint32(cooldown);                   // spell cooldown
        }
        else
        {
            data << uint32(0);                          // category cooldown
            data << uint32(itr->first);                 // spell ID
            data << uint16(0);                          // spell category
            data << uint32(cooldown);                   // spell cooldown
        }
    }

    data.WriteByteSeq(VehicleGuid[2]);
    data.WriteByteSeq(VehicleGuid[7]);
    data.WriteByteSeq(VehicleGuid[0]);
    data.WriteByteSeq(VehicleGuid[3]);
    data << uint16(0);                                  // Pet Family (0 for all vehicles)
    data << uint16(0);                                  // Creature Specialization need implementation
    data.WriteByteSeq(VehicleGuid[1]);
    data.WriteByteSeq(VehicleGuid[4]);
    data.WriteByteSeq(VehicleGuid[6]);
    data << uint32(vehicle->IsSummon() ? vehicle->ToTempSummon()->GetTimer() : 0); // Duration
    data.WriteByteSeq(VehicleGuid[5]);
    data << uint8(vehicle->GetReactState());                // React State
    data << uint8(0);                                       // Command State
    data << uint16(0x800);                                  // DisableActions (set for all vehicles)

    GetSession()->SendPacket(&data);
}

void Player::CharmSpellInitialize()
{
    Unit* charm = GetFirstControlled();
    if (!charm)
        return;

    CharmInfo* charmInfo = charm->GetCharmInfo();
    if (!charmInfo)
    {
        TC_LOG_ERROR("entities.player", "Player::CharmSpellInitialize(): the player's charm (" UI64FMTD ") has no charminfo!", charm->GetGUID());
        return;
    }

    uint8 addlist = 0;
    if (charm->GetTypeId() != TYPEID_PLAYER)
    {
        //CreatureInfo const* cinfo = charm->ToCreature()->GetCreatureTemplate();
        //if (cinfo && cinfo->type == CREATURE_TYPE_DEMON && getClass() == CLASS_WARLOCK)
        {
            for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
                if (charmInfo->GetCharmSpell(i)->GetAction())
                    ++addlist;
        }
    }

    ObjectGuid CharmGuid = charm->GetGUID();
    WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+4*addlist+1);
    data.WriteBit(CharmGuid[7]);
    data.WriteBit(CharmGuid[4]);
    data.WriteBits(0, 21);     // cooldowns count
    data.WriteBits(0, 22);     // spells count
    data.WriteBit(CharmGuid[2]);
    data.WriteBits(0, 20);     // CooldownCount
    data.WriteBit(CharmGuid[5]);
    data.WriteBit(CharmGuid[3]);
    data.WriteBit(CharmGuid[6]);
    data.WriteBit(CharmGuid[0]);
    data.WriteBit(CharmGuid[1]);

    data.FlushBits();

    charmInfo->BuildActionBar(&data);
    data.WriteByteSeq(CharmGuid[2]);
    data.WriteByteSeq(CharmGuid[7]);
    data.WriteByteSeq(CharmGuid[0]);
    data.WriteByteSeq(CharmGuid[3]);
    data << uint16(0);
    data << uint16(0);
    data.WriteByteSeq(CharmGuid[1]);
    data.WriteByteSeq(CharmGuid[4]);
    data.WriteByteSeq(CharmGuid[6]);
    data << uint32(0);
    data.WriteByteSeq(CharmGuid[5]);
    
    if (charm->GetTypeId() != TYPEID_PLAYER)
        data << uint8(charm->ToCreature()->GetReactState()) << uint8(charmInfo->GetCommandState()) << uint16(0);
    else
        data << uint32(0);
        
    GetSession()->SendPacket(&data);
}

void Player::SendRemoveControlBar()
{
    ObjectGuid Guid;
    WorldPacket data(SMSG_PET_SPELLS_MESSAGE, 8);

    data.WriteBit(Guid[7]);
    data.WriteBit(Guid[4]);
    data.WriteBits(0, 21);     // cooldowns count
    data.WriteBits(0, 22);     // spells count
    data.WriteBit(Guid[2]);
    data.WriteBits(0, 20);     // CooldownCount
    data.WriteBit(Guid[5]);
    data.WriteBit(Guid[3]);
    data.WriteBit(Guid[6]);
    data.WriteBit(Guid[0]);
    data.WriteBit(Guid[1]);

    data.FlushBits();

    data.WriteByteSeq(Guid[2]);
    data.WriteByteSeq(Guid[7]);
    data.WriteByteSeq(Guid[0]);
    data.WriteByteSeq(Guid[3]);
    data << uint16(0);
    data << uint16(0);
    data.WriteByteSeq(Guid[1]);
    data.WriteByteSeq(Guid[4]);
    data.WriteByteSeq(Guid[6]);
    data << uint32(0);
    data.WriteByteSeq(Guid[5]);

    GetSession()->SendPacket(&data);
}

bool Player::IsAffectedBySpellmod(SpellInfo const* spellInfo, SpellModifier* mod, Spell* spell)
{
    if (!mod || !spellInfo)
        return false;

    // Mod out of charges
    if (spell && mod->charges == -1 && spell->m_appliedMods.find(mod->ownerAura) == spell->m_appliedMods.end())
        return false;

    // +duration to infinite duration spells making them limited
    if (mod->op == SPELLMOD_DURATION && spellInfo->GetDuration() == -1)
        return false;

    if (spell && mod->op == SPELLMOD_COST)
        if (mod->effect->GetMiscValueB() && !(mod->effect->GetMiscValueB() & 1 << spell->GetPowerType()))
            return false;

    return spellInfo->IsAffectedBySpellMod(mod);
}

void Player::AddSpellMod(SpellModifier* mod, bool apply)
{
    TC_LOG_DEBUG("spells", "Player::AddSpellMod %d", mod->spellId);
    Opcodes opcode = Opcodes((mod->type == SPELLMOD_FLAT) ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);

    int i = 0;
    flag128 _mask = 0;
    uint32 modTypeCount = 0; // count of mods per one mod->op

    WorldPacket data(opcode);
    data.WriteBits(1, 22);  // count of different mod->op's in packet
    size_t writePos = data.bitwpos();
    data.WriteBits(modTypeCount, 21);

    if (mod->type == SPELLMOD_FLAT)
        data << uint8(mod->op);

    if (apply)
        m_spellMods[mod->op].push_back(mod);
    else
        m_spellMods[mod->op].remove(mod);

    for (int eff = 0; eff < 128; ++eff)
    {
        if (eff != 0 && (eff % 32) == 0)
            _mask[i++] = 0;

        _mask[i] = uint32(1) << (eff - (32 * i));
        if (mod->mask & _mask)
        {
            float val;
            if (mod->type == SPELLMOD_FLAT)
            {
                val = 0.0f;
                for (auto&& it : m_spellMods[mod->op])
                    if (it->type == mod->type && it->mask & _mask)
                        val += it->value;
            }
            else
            {
                val = 1.0f;
                for (auto&& it : m_spellMods[mod->op])
                    if (it->type == mod->type && it->mask & _mask)
                        AddPct(val, it->value);
            }
            data << float(val);
            data << uint8(eff);
            ++modTypeCount;
        }
    }

    if (mod->type == SPELLMOD_PCT)
        data << uint8(mod->op);

    data.PutBits(writePos, modTypeCount, 21);
    SendDirectMessage(&data);

    if (!apply)
    {
        // mods bound to aura will be removed in AuraEffect::~AuraEffect
        if (!mod->ownerAura)
            delete mod;
    }
}

// Restore spellmods in case of failed cast
void Player::RestoreSpellMods(Spell* spell, uint32 ownerAuraId, Aura* aura)
{
    if (!spell || spell->m_appliedMods.empty())
        return;

    std::vector<Aura*> toBeRemoved;
    for (uint8 i=0; i < MAX_SPELLMOD; ++i)
    {
        for (auto&& mod : m_spellMods[i])
        {
            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges() || !mod->charges)
                continue;

            // Restore only specific owner aura mods
            if (ownerAuraId && (ownerAuraId != mod->ownerAura->GetSpellInfo()->Id))
                continue;

            if (aura && mod->ownerAura != aura)
                continue;

            // check if mod affected this spell
            // first, check if the mod aura applied at least one spellmod to this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;
            // secondly, check if the current mod is one of the spellmods applied by the mod aura
            if (!(mod->mask & spell->m_spellInfo->SpellFamilyFlags))
                continue;

            toBeRemoved.push_back(mod->ownerAura);

            // add mod charges back to mod
            if (mod->charges == -1)
                mod->charges = 1;
            else
                mod->charges++;

            // Do not set more spellmods than avalible
            if (mod->ownerAura->GetCharges() < mod->charges)
                mod->charges = mod->ownerAura->GetCharges();

            // Skip this check for now - aura charges may change due to various reason
            /// @todo trac these changes correctly
            //ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
        }
    }

    for (auto&& aura : toBeRemoved)
        spell->m_appliedMods.erase(aura);
}

void Player::RestoreAllSpellMods(uint32 ownerAuraId, Aura* aura)
{
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (m_currentSpells[i])
            RestoreSpellMods(m_currentSpells[i], ownerAuraId, aura);
}

void Player::ApplyCostSpellMod(uint32 spellId, int32& basevalue)
{
    m_spellMods[SPELLMOD_COST].sort([](SpellModifier const* lhs, SpellModifier const* rhs)
    {
        if (rhs->type == SPELLMOD_PCT)
        {
            if (lhs->value > 0 && rhs->value < 0)
                return true;
            if (rhs->value > 0 && lhs->value < 0)
                return false;
            if (lhs->spellId == 135700) // Clearcasting (feral)
                    return false;
            if (rhs->spellId == 69369)  // Predatory Swiftness
                return true;
            if (int32(lhs->value) == -100)
                return true;
        }
        return false;
    });

    Spell* spell = m_spellModTakingSpell;
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    float totalmul = 1.0f;
    int32 totalflat = 0;
    bool free = false;

    for (auto&& mod : m_spellMods[SPELLMOD_COST])
    {
        // Charges can be set only for mods with auras
        if (!mod->ownerAura)
            ASSERT(mod->charges == 0);

        if (!IsAffectedBySpellmod(spellInfo, mod, spell))
            continue;

        if (mod->type == SPELLMOD_FLAT)
            totalflat += mod->value;
        else if (mod->type == SPELLMOD_PCT)
        {
            if (basevalue == 0)
                continue;

            AddPct(totalmul, mod->value);
        }

        DropModCharge(mod, spell);
        if (totalmul <= 0.0f)
            break;
    }
    basevalue = int32((basevalue + totalflat) * totalmul);
}

void Player::RemoveSpellMods(Spell* spell)
{
    if (!spell)
        return;

    if (spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i < MAX_SPELLMOD; ++i)
    {
        for (auto it = m_spellMods[i].begin(); it != m_spellMods[i].end();)
        {
            SpellModifier* mod = *it;
            ++it;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->IsUsingCharges() || !mod->charges)
                continue;

            // check if mod affected this spell
            Spell::UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;

            if (sSpellMgr->GetSpellProcEvent(mod->spellId))
                continue;

            bool prevented = mod->ownerAura->CallScriptAuraDropModChargeHandlers(spell);

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            if (prevented)
                continue;

            if (mod->ownerAura->DropCharge(AURA_REMOVE_BY_EXPIRE))
                it = m_spellMods[i].begin();
        }
    }
}

void Player::DropModCharge(SpellModifier* mod, Spell* spell)
{
    if (spell && mod->ownerAura)
    {
        if (spell->m_appliedMods.insert(mod->ownerAura).second)
        {
            if (mod->charges && !sSpellMgr->GetSpellProcEvent(mod->spellId))
            {
                if (--mod->charges == 0)
                    mod->charges = -1;
                if (mod->dropPhase == SpellModDropPhase::OnCast)
                    spell->m_dropModsPhase = SpellModDropPhase::OnCast;
            }
        }
    }
}

void Player::SetSpellModTakingSpell(Spell* spell, bool apply)
{
    if (!spell || (m_spellModTakingSpell && m_spellModTakingSpell != spell))
        return;

    if (apply && spell->getState() == SPELL_STATE_FINISHED)
        return;

    m_spellModTakingSpell = apply ? spell : NULL;
}

// send Proficiency
void Player::SendProficiency(ItemClass itemClass, uint32 itemSubclassMask)
{
    WorldPacket data(SMSG_SET_PROFICIENCY, 4 + 1);
    data << uint32(itemSubclassMask) << uint8(itemClass);
    GetSession()->SendPacket(&data);
}

void Player::RemovePetitionsAndSigns(uint64 guid, uint32 type)
{
    PreparedStatement* stmt;

    if (type == 10)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID_TYPE);
        stmt->setUInt8(1, uint8(type));
    }

    stmt->setUInt32(0, GUID_LOPART(guid));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
        do                                                  // this part effectively does nothing, since the deletion / modification only takes place _after_ the PetitionQuery. Though I don't know if the result remains intact if I execute the delete query beforehand.
        {                                                   // and SendPetitionQueryOpcode reads data from the DB
            Field* fields = result->Fetch();
            uint64 ownerguid   = MAKE_NEW_GUID(fields[0].GetUInt32(), 0, HIGHGUID_PLAYER);
            uint64 petitionguid = MAKE_NEW_GUID(fields[1].GetUInt32(), 0, HIGHGUID_ITEM);

            // send update if charter owner in game
            Player* owner = ObjectAccessor::FindPlayer(ownerguid);
            if (owner)
                owner->GetSession()->SendPetitionQueryOpcode(petitionguid);
        } while (result->NextRow());

        if (type == 10)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_PETITION_SIGNATURES);

            stmt->setUInt32(0, GUID_LOPART(guid));

            CharacterDatabase.Execute(stmt);
        }
        else
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE);

            stmt->setUInt32(0, GUID_LOPART(guid));
            stmt->setUInt8(1, uint8(type));

            CharacterDatabase.Execute(stmt);
        }
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    if (type == 10)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
        stmt->setUInt32(0, GUID_LOPART(guid));
        trans->Append(stmt);
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER_AND_TYPE);
        stmt->setUInt32(0, GUID_LOPART(guid));
        stmt->setUInt8(1, uint8(type));
        trans->Append(stmt);
    }
    CharacterDatabase.CommitTransaction(trans);
}

uint32 Player::GetArenaPersonalRating(uint8 slot) const
{
    auto info = RatedPvpMgr::Instance()->GetInfo(RatedPvpSlot(slot), GetGUID());
    if (!info)
        return 0;
    return info->Rating;
}

uint32 Player::GetMaxArenaRating() const
{
    uint32 max_value = 0;

    for (uint8 i = 0; i < PVP_SLOT_MAX; i++)
    {
        // Skip  5v5 arena
        if (i == PVP_SLOT_ARENA_5v5)
            continue;

        if (max_value < GetArenaPersonalRating(i))
            max_value = GetArenaPersonalRating(i);
    }

    return max_value;
}

void Player::SetRestBonus(float rest_bonus_new)
{
    // Prevent resting on max level
    if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        rest_bonus_new = 0;

    if (rest_bonus_new < 0)
        rest_bonus_new = 0;

    float rest_bonus_max = (float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)*1.5f/2;

    if (rest_bonus_new > rest_bonus_max)
        m_rest_bonus = rest_bonus_max;
    else
        m_rest_bonus = rest_bonus_new;

    // update data for client
    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetByteValue(PLAYER_FIELD_REST_STATE, 3, REST_STATE_RAF_LINKED);
    else if (m_rest_bonus > 10)
        SetByteValue(PLAYER_FIELD_REST_STATE, 3, REST_STATE_RESTED);              // Set Reststate = Rested
    else if (m_rest_bonus <= 1)
        SetByteValue(PLAYER_FIELD_REST_STATE, 3, REST_STATE_NOT_RAF_LINKED);              // Set Reststate = Normal

    //RestTickUpdate
    SetUInt32Value(PLAYER_FIELD_REST_STATE_BONUS_POOL, uint32(m_rest_bonus));
}

bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc /*= NULL*/, uint32 spellid /*= 0*/)
{
    if (nodes.size() < 2)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_NO_SUCH_PATH);
        return false;
    }

    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
    if (GetSession()->isLogingOut() || IsInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_PLAYER_BUSY);
        return false;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE))
        return false;

    // taximaster case
    if (npc)
    {
        // not let cheating with start flight mounted
        if (IsMounted())
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXI_PLAYER_ALREADY_MOUNTED);
            return false;
        }

        if (IsInDisallowedMountForm())
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXI_PLAYER_SHAPESHIFTED);
            return false;
        }

        // not let cheating with start flight in time of logout process || if casting not finished || while in combat || if not use Spell's with EffectSendTaxi
        if (IsNonMeleeSpellCasted(false))
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXI_PLAYER_BUSY);
            return false;
        }
    }
    // cast case or scripted call case
    else
    {
        RemoveAurasByType(SPELL_AURA_MOUNTED);

        if (IsInDisallowedMountForm())
            RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);

        if (Spell* spell = GetCurrentSpell(CURRENT_GENERIC_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_GENERIC_SPELL, false);

        InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);

        if (Spell* spell = GetCurrentSpell(CURRENT_CHANNELED_SPELL))
            if (spell->m_spellInfo->Id != spellid)
                InterruptSpell(CURRENT_CHANNELED_SPELL, true);
    }

    uint32 sourcenode = nodes[0];

    // starting node too far away (cheat?)
    TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(sourcenode);
    TaxiNodesEntry const* endNode = sTaxiNodesStore.LookupEntry(nodes[1]);
    if (!node || !endNode)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_NO_SUCH_PATH);
        return false;
    }

    // check node starting pos data set case if provided
    if ((node->x != 0.0f || node->y != 0.0f || node->z != 0.0f) && spellid != 34891) // Caverns of Time
    {
        float dx = node->x - endNode->x;
        float dy = node->y - endNode->y;
        float dz = node->z - endNode->z;
        float dist = dx * dx + dy * dy + dz * dz;

        if (node->map_id != GetMapId() || (dist > 1.5f &&  // don't check nodes with equal start and end points (like 433 and 434 or equal Ids, whats wrong with dbc?)
            !IsInDist(node->x, node->y, node->z, 2 * INTERACTION_DISTANCE)))
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXI_TOO_FAR_AWAY);
            return false;
        }
    }
    // node must have pos if taxi master case (npc != NULL)
    else if (npc)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_UNSPECIFIED_SERVER_ERROR);
        return false;
    }

    // Prepare to flight start now

    // stop combat at start taxi flight if any
    CombatStop();

    StopCastingCharm();
    StopCastingBindSight();
    ExitVehicle();

    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
    TradeCancel(true);

    // clean not finished taxi path if any
    m_taxi.ClearTaxiDestinations();

    // 0 element current node
    m_taxi.AddTaxiDestination(sourcenode);

    // fill destinations path tail
    uint32 sourcepath = 0;
    uint32 totalcost = 0;

    uint32 prevnode = sourcenode;
    uint32 lastnode = 0;

    for (uint32 i = 1; i < nodes.size(); ++i)
    {
        uint32 path, cost;

        lastnode = nodes[i];
        sObjectMgr->GetTaxiPath(prevnode, lastnode, path, cost);

        if (!path)
        {
            m_taxi.ClearTaxiDestinations();
            return false;
        }

        totalcost += cost;

        if (prevnode == sourcenode)
            sourcepath = path;

        m_taxi.AddTaxiDestination(lastnode);

        prevnode = lastnode;
    }

    // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
    //
    // Hack-Fix for Alliance not being able to use Acherus taxi. There is
    // only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
    // change but I couldn't find a suitable alternative. OK to use class because only DK
    // can use this taxi.
    uint32 mount_display_id = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetTeam(), npc == NULL || (sourcenode == 315 && getClass() == CLASS_DEATH_KNIGHT));

    // in spell case allow 0 model
    if ((mount_display_id == 0 && spellid == 0) || sourcepath == 0)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_UNSPECIFIED_SERVER_ERROR);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    uint64 money = GetMoney();

    if (npc)
        totalcost = (uint32)ceil(totalcost*GetReputationPriceDiscount(npc));

    if (money < totalcost)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_NOT_ENOUGH_MONEY);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    //Checks and preparations done, DO FLIGHT
    ModifyMoney(-int64(totalcost));
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, totalcost);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);

    // prevent stealth flight
    //RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);

    if (sWorld->getBoolConfig(CONFIG_INSTANT_TAXI))
    {
        TaxiNodesEntry const* lastPathNode = sTaxiNodesStore.LookupEntry(nodes[nodes.size()-1]);
        m_taxi.ClearTaxiDestinations();
        TeleportTo(lastPathNode->map_id, lastPathNode->x, lastPathNode->y, lastPathNode->z, GetOrientation());
        return false;
    }
    else
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXI_OK);
        GetSession()->SendDoFlight(mount_display_id, sourcepath);
    }
    return true;
}

bool Player::ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid /*= 0*/)
{
    TaxiPathEntry const* entry = sTaxiPathStore.LookupEntry(taxi_path_id);
    if (!entry)
        return false;

    std::vector<uint32> nodes;

    nodes.resize(2);
    nodes[0] = entry->from;
    nodes[1] = entry->to;

    return ActivateTaxiPathTo(nodes, NULL, spellid);
}

void Player::CleanupAfterTaxiFlight()
{
    m_taxi.ClearTaxiDestinations();        // not destinations, clear source node
    Dismount();
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE | UNIT_FLAG_TAXI_FLIGHT);
    getHostileRefManager().setOnlineOfflineState(true);
}

void Player::ContinueTaxiFlight()
{
    uint32 sourceNode = m_taxi.GetTaxiSource();
    if (!sourceNode)
        return;

    TC_LOG_DEBUG("entities.unit", "WORLD: Restart character %u taxi flight", GetGUIDLow());

    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourceNode, GetTeam(), true);
    if (!mountDisplayId)
        return;

    uint32 path = m_taxi.GetCurrentTaxiPath();

    TaxiPathNodeList const& nodeList = sTaxiPathNodesByPath[path];

    uint32 startNode = m_taxi.GetLastNodeIndex() + 1;
    if (startNode >= nodeList.size())
    {
        TC_LOG_ERROR("shitlog","Player::ContinueTaxiFlight node %u, path : %u", startNode, path);
        return;
    }

    GetSession()->SendDoFlight(mountDisplayId, path, startNode);
}

void Player::ProhibitSpellSchool(SpellSchoolMask schoolMask, uint32 unTimeMs)
{
    ObjectGuid guid = GetGUID();
    uint32 count = 0;

    WorldPacket data(SMSG_SPELL_COOLDOWN, 9 + 3 + m_spells.size() * 8);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[6]);
    data.WriteBit(1); // Missing flags
    data.WriteBit(guid[7]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[5]);
    size_t bitpos = data.bitwpos();
    data.WriteBits(0, 21);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[4]);
    data.FlushBits();

    auto prohibitSpell = [&](uint32 spellId)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
        if (!spellInfo)
            return;

        // Not send cooldown for this spells
        if (spellInfo->IsCooldownStartedOnEvent())
            return;

        if (!(spellInfo->PreventionType & SPELL_PREVENTION_TYPE_SILENCE))
            return;

        switch (spellId)
        {
            case 44614:  // Frostfire bolt
                if (!(schoolMask & SPELL_SCHOOL_MASK_FIRE) || !(schoolMask & SPELL_SCHOOL_MASK_FROST))
                    return;
                break;
            case 77799:  // Fel Flame
            case 105174: // Handl of Gul'dan
            case 123194: // Handl of Gul'dan
                if (!(schoolMask & SPELL_SCHOOL_MASK_FIRE))
                    return;
                break;
            case 124916: // Chaos Wave
            case 103964: // Touch of Chaos
            case 115422: // Void Ray
                if (!(schoolMask & SPELL_SCHOOL_MASK_SHADOW))
                    return;
                break;
        }

        if (schoolMask & spellInfo->GetSchoolMask())
        {
            // Don't send but call ProhibitSpell anyway
            if (GetSpellCooldownDelay(spellId) < unTimeMs)
            {
                data << uint32(spellId);
                data << uint32(unTimeMs);                       // in m.secs
                count++;
            }
            GetSpellHistory()->ProhibitSpell(spellId, Milliseconds(unTimeMs));
        }
    };

    for (auto&& itr : m_spells)
        if (itr.second->state != PLAYERSPELL_REMOVED)
            prohibitSpell(itr.first);
    for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS))
        prohibitSpell(itr->GetAmount());
    for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2))
        prohibitSpell(itr->GetAmount());

    data.PutBits(bitpos, count, 21);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[6]);

    GetSession()->SendPacket(&data);
}

void Player::InitDataForForm(bool reapplyMods)
{
    ShapeshiftForm form = GetShapeshiftForm();

    SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
    if (ssEntry && ssEntry->attackSpeed)
    {
        SetAttackTime(BASE_ATTACK, ssEntry->attackSpeed);
        SetAttackTime(OFF_ATTACK, ssEntry->attackSpeed);
        SetAttackTime(RANGED_ATTACK, BASE_ATTACK_TIME);
    }
    else
        SetRegularAttackTime();

    switch (form)
    {
        case FORM_GHOUL:
        case FORM_CAT:
        {
            if (GetPowerType() != POWER_ENERGY)
                SetPowerType(POWER_ENERGY);
            break;
        }
        case FORM_BEAR:
        {
            if (GetPowerType() != POWER_RAGE)
                SetPowerType(POWER_RAGE);
            break;
        }
        case FORM_WISE_SERPENT:
        {
            if (GetPowerType() != POWER_MANA)
            SetPowerType(POWER_MANA);
            break;
        }
        default:                                            // 0, for example
        {
            ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(getClass());
            if (cEntry && cEntry->powerType < MAX_POWERS && uint32(GetPowerType()) != cEntry->powerType)
                SetPowerType(Powers(cEntry->powerType));
            break;
        }
    }

    // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
    if (!reapplyMods)
        UpdateEquipSpellsAtFormChange();

    UpdateAttackPowerAndDamage();
    UpdateAttackPowerAndDamage(true);
}

void Player::InitDisplayIds()
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        TC_LOG_ERROR("entities.player", "Player %u has incorrect race/class pair. Can't init display ids.", GetGUIDLow());
        return;
    }

    uint8 gender = getGender();
    switch (gender)
    {
        case GENDER_FEMALE:
            SetDisplayId(info->displayId_f);
            SetNativeDisplayId(info->displayId_f);
            break;
        case GENDER_MALE:
            SetDisplayId(info->displayId_m);
            SetNativeDisplayId(info->displayId_m);
            break;
        default:
            TC_LOG_ERROR("entities.player", "Invalid gender %u for player", gender);
            return;
    }
}

inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int32 price, ItemTemplate const* pProto, Creature* pVendor, VendorItem const* crItem, bool bStore)
{
    uint32 stacks = count / pProto->BuyCount;
    ItemPosCountVec vDest;
    uint16 uiDest = 0;
    InventoryResult msg = bStore ?
        CanStoreNewItem(bag, slot, vDest, item, count) :
        CanEquipNewItem(slot, uiDest, item, false);
    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, NULL, NULL, item);
        return false;
    }

    ModifyMoney(-price);

    if (crItem->ExtendedCost) // case for new honor system
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequiredItem[i])
                DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks, true);
        }

        for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
                continue;

            if (iece->RequiredCurrency[i])
                ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i] * stacks), true, true);
        }
    }

    Item* it = bStore ?
        StoreNewItem(vDest, item, true) :
        EquipNewItem(uiDest, item, true);
    if (it)
    {
        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, count);
        ObjectGuid vGuid = pVendor->GetGUID();

        WorldPacket data(SMSG_BUY_ITEM, 1 + 8 + 4 + 4 + 4);
        data.WriteBit(vGuid[3]);
        data.WriteBit(vGuid[4]);
        data.WriteBit(vGuid[7]);
        data.WriteBit(vGuid[6]);
        data.WriteBit(vGuid[0]);
        data.WriteBit(vGuid[2]);
        data.WriteBit(vGuid[1]);
        data.WriteBit(vGuid[5]);

        data.WriteByteSeq(vGuid[6]);
        data.WriteByteSeq(vGuid[7]);
        data << uint32(count);
        data.WriteByteSeq(vGuid[1]);
        data.WriteByteSeq(vGuid[3]);
        data.WriteByteSeq(vGuid[5]);
        data.WriteByteSeq(vGuid[2]);
        data << int32(crItem->maxcount > 0 ? new_count : 0xFFFFFFFF);
        data.WriteByteSeq(vGuid[0]);
        data.WriteByteSeq(vGuid[4]);
        data << uint32(vendorslot + 1);                   // numbered from 1 at client

        GetSession()->SendPacket(&data);
        SendNewItem(it, count, true, false, false);

        if (!bStore)
            AutoUnequipOffhandIfNeed();

        if (pProto->Flags & ITEM_PROTO_FLAG_REFUNDABLE && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1)
        {
            it->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
            it->SetRefundRecipient(GetGUIDLow());
            it->SetPaidMoney(price);
            it->SetPaidExtendedCost(crItem->ExtendedCost);
            it->SaveRefundDataToDB();
            AddRefundReference(it->GetGUIDLow());
        }
        if (GetSession()->HasFlag(ACC_FLAG_ITEM_LOG))
            logs::ItemLog(this, it, it->GetCount(), "Buy at vendor %u (GUID: %u)", pVendor->GetEntry(), pVendor->GetGUIDLow());

        sScriptMgr->OnItemPickup(this, it, ItemPickupSourceType::Vendor, pVendor->GetEntry());
    }
    return true;
}

bool Player::BuyCurrencyFromVendorSlot(uint64 vendorGuid, uint32 vendorSlot, uint32 currency, uint32 count)
{
    // cheating attempt
    if (count < 1) count = 1;

    if (!IsAlive())
        return false;

    CurrencyTypesEntry const* proto = sCurrencyTypesStore.LookupEntry(currency);
    if (!proto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG("network", "WORLD: BuyCurrencyFromVendorSlot - Unit (GUID: %u) not found or you can't interact with him.", GUID_LOPART(vendorGuid));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, currency, 0);
        return false;
    }

    uint32 currentVendor = GetSession()->GetCurrentVendor();
	VendorItemData const* vItems = currentVendor ? sObjectMgr->GetNpcVendorItemList(currentVendor) : creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (vendorSlot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorSlot);
    // store diff item (cheating)
    if (!crItem || crItem->item != currency || crItem->Type != ITEM_VENDOR_TYPE_CURRENCY)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0);
        return false;
    }

    if (count % crItem->maxcount)
    {
        SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
        return false;
    }

    uint32 stacks = count / crItem->maxcount;
    ItemExtendedCostEntry const* iece = NULL;
    if (crItem->ExtendedCost)
    {
        iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            TC_LOG_ERROR("entities.player", "Currency %u have wrong ExtendedCost field value %u", currency, crItem->ExtendedCost);
            return false;
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], (iece->RequiredItemCount[i] * stacks)))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency, 0); // Find correct error
                return false;
            }

            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
            {
                // Not implemented
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
                return false;
            }
            else if (!HasCurrency(iece->RequiredCurrency[i], (iece->RequiredCurrencyCount[i] * stacks)))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }

        if (iece->RequiredFactionId && uint32(GetReputationRank(iece->RequiredFactionId)) < iece->RequiredFactionStanding)
        {
            SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, currency, 0);
            return false;
        }

        if (iece->RequirementFlags & ITEM_EXT_COST_FLAG_REQUIRE_GUILD && !GetGuildId())
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }

        if (iece->RequiredGuildLevel && iece->RequiredGuildLevel < GetGuildLevel())
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }

        if (iece->RequiredAchievement && !HasAchieved(iece->RequiredAchievement))
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }
    }
    else // currencies have no price defined, can only be bought with ExtendedCost
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency, 0);
        return false;
    }

    ModifyCurrency(currency, count, true, true);
    if (iece)
    {
        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (!iece->RequiredItem[i])
                continue;

            DestroyItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks, true);
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
                continue;

            ModifyCurrency(iece->RequiredCurrency[i], -int32(iece->RequiredCurrencyCount[i]) * stacks, false, true);
        }
    }

    return true;
}

// Return true is the bought item has a max count to force refresh of window by caller
bool Player::BuyItemFromVendorSlot(uint64 vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot)
{
    // cheating attempt
    if (count < 1) count = 1;

    // cheating attempt
    if (slot > MAX_BAG_SIZE && slot != NULL_SLOT)
        return false;

    if (!IsAlive())
        return false;

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (!pProto)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, 0);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG("network", "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(GUID_LOPART(vendorguid)));
        SendEquipError(EQUIP_ERR_OUT_OF_RANGE, NULL, NULL, 0);
        return false;
    }

    uint32 currentVendor = GetSession()->GetCurrentVendor();
	VendorItemData const* vItems = currentVendor ? sObjectMgr->GetNpcVendorItemList(currentVendor) : creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, 0);
        return false;
    }

    if (vendorslot >= vItems->GetItemCount())
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, 0);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorslot);
    // store diff item (cheating)
    if (!crItem || crItem->item != item)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, 0);
        return false;
    }

    // check current item amount if it limited
    if (crItem->maxcount != 0)
    {
        if (creature->GetVendorItemCurrentCount(crItem) < pProto->BuyCount * count)
        {
            SendEquipError(EQUIP_ERR_VENDOR_SOLD_OUT, NULL, NULL, 0);
            return false;
        }
    }

    if (pProto->RequiredReputationFaction && (uint32(GetReputationRank(pProto->RequiredReputationFaction)) < pProto->RequiredReputationRank))
    {
        SendEquipError(EQUIP_ERR_CANT_EQUIP_REPUTATION, NULL, NULL, 0);
        return false;
    }

    if (crItem->ExtendedCost)
    {
        // Can only buy full stacks for extended cost
        if (count % pProto->BuyCount)
        {
            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY, NULL, NULL);
            return false;
        }

        uint32 stacks = count / pProto->BuyCount;
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            TC_LOG_ERROR("entities.player", "Item %u have wrong ExtendedCost field value %u", pProto->ItemId, crItem->ExtendedCost);
            return false;
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->RequiredItem[i] && !HasItemCount(iece->RequiredItem[i], iece->RequiredItemCount[i] * stacks))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->RequiredCurrency[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
            if (!entry)
            {
                SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, 0);
                return false;
            }

            if (i == 1) // check season count
            {
                if ((iece->RequirementFlags & ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_2) && GetCurrencyOnSeason(iece->RequiredCurrency[i], false) < iece->RequiredCurrencyCount[i])
                {
                    SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
                    return false;
                }
            }
            else if (!HasCurrency(iece->RequiredCurrency[i], iece->RequiredCurrencyCount[i] * stacks))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL);
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalRatingRequirement(iece->RequiredArenaSlot) < iece->RequiredPersonalArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }

        if (iece->RequiredFactionId && uint32(GetReputationRank(iece->RequiredFactionId)) < iece->RequiredFactionStanding)
        {
            SendEquipError(EQUIP_ERR_CANT_EQUIP_REPUTATION, NULL, NULL, 0);

            return false;
        }

        if (iece->RequirementFlags & ITEM_EXT_COST_FLAG_REQUIRE_GUILD && !GetGuildId())
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }

        if (iece->RequiredGuildLevel && iece->RequiredGuildLevel < GetGuildLevel())
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }

        if (iece->RequiredAchievement && !HasAchieved(iece->RequiredAchievement))
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS, NULL, NULL); // Find correct error
            return false;
        }
    }

    uint32 price = 0;
    if (crItem->IsGoldRequired(pProto) && pProto->BuyPrice > 0) //Assume price cannot be negative (do not know why it is int32)
    {
        uint32 maxCount = MAX_MONEY_AMOUNT / pProto->BuyPrice;
        if ((uint32)count > maxCount)
        {
            TC_LOG_ERROR("entities.player", "Player %s tried to buy %u item id %u, causing overflow", GetName().c_str(), (uint32)count, pProto->ItemId);
            count = (uint8)maxCount;
        }
        price = pProto->BuyPrice * ceil((float)count / (float)pProto->BuyCount); //it should not exceed MAX_MONEY_AMOUNT

        // reputation discount
        price = uint32(floor(price * GetReputationPriceDiscount(creature)));

        if (int32 priceMod = GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES))
            price -= CalculatePct(price, priceMod);

        if (!HasEnoughMoney(uint64(price)))
        {
            SendEquipError(EQUIP_ERR_NOT_ENOUGH_MONEY, NULL, NULL, 0);
            return false;
        }
    }

    if ((bag == NULL_BAG && slot == NULL_SLOT) || IsInventoryPos(bag, slot))
    {
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, true))
            return false;
    }
    else if (IsEquipmentPos(bag, slot))
    {
        if (count != 1)
        {
            SendEquipError(EQUIP_ERR_NOT_EQUIPPABLE, NULL, NULL);
            return false;
        }
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, false))
            return false;
    }
    else
    {
        SendEquipError(EQUIP_ERR_WRONG_SLOT, NULL, NULL);
        return false;
    }

    if (crItem->maxcount != 0) // bought
    {
        if (pProto->Quality > ITEM_QUALITY_EPIC || (pProto->Quality == ITEM_QUALITY_EPIC && pProto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
            if (Guild* guild = GetGuild())
                guild->AddGuildNews(GUILD_NEWS_ITEM_PURCHASED, GetGUID(), 0, item);
        return true;
    }

    return false;
}

uint32 Player::GetMaxPersonalRatingRequirement(uint32 minarenaslot) const
{
    // returns the maximal personal arena rating that can be used to purchase items requiring this condition
    // the personal rating of the arena team must match the required limit as well
    // so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
    uint32 maxRating = 0;
    for (uint8 i = minarenaslot; i < PVP_SLOT_MAX; ++i)
    {
        if (i == PVP_SLOT_ARENA_5v5 && sWorld->getBoolConfig(CONFIG_SOLO_QUEUE_ENABLED) && !sWorld->getBoolConfig(CONFIG_SOLO_QUEUE_ALLOW_BUY_ARENA_STUFF))
            continue;

        uint32 rating = GetArenaPersonalRating(i);
        if (maxRating < rating)
            maxRating = rating;
    }
    return maxRating;
}

void Player::UpdateHomebindTime(uint32 time)
{
    // GMs never get homebind timer online
    if (m_InstanceValid || IsGameMaster())
    {
        if (m_HomebindTimer)                                 // instance valid, but timer not reset
        {
            // hide reminder
            WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
            data << uint32(0);
            data << uint32(0);
            GetSession()->SendPacket(&data);
        }
        // instance is valid, reset homebind timer
        m_HomebindTimer = 0;
    }
    else if (m_HomebindTimer > 0)
    {
        if (time >= m_HomebindTimer)
        {
            // teleport to nearest graveyard
            RepopAtGraveyard();
        }
        else
            m_HomebindTimer -= time;
    }
    else
    {
        // instance is invalid, start homebind timer
        m_HomebindTimer = 60000;
        // send message to player
        WorldPacket data(SMSG_RAID_GROUP_ONLY, 4+4);
        data << uint32(m_HomebindTimer);
        data << uint32(1);
        GetSession()->SendPacket(&data);
        TC_LOG_DEBUG("maps", "PLAYER: Player '%s' (GUID: %u) will be teleported to homebind in 60 seconds", GetName().c_str(), GetGUIDLow());
    }
}

void Player::UpdatePvPState(bool onlyFFA)
{
    /// @todo should we always synchronize UNIT_FIELD_SHAPESHIFT_FORM, 1 of controller and controlled?
    // no, we shouldn't, those are checked for affecting player by client
    if (!pvpInfo.IsInNoPvPArea && !IsGameMaster()
        && (pvpInfo.IsInFFAPvPArea || sWorld->IsFFAPvPRealm()))
    {
        if (!HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
        {
            SetByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
            for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
                (*itr)->SetByteValue(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        }
    }
    else if (HasByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP))
    {
        RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
        for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
            (*itr)->RemoveByteFlag(UNIT_FIELD_SHAPESHIFT_FORM, 1, UNIT_BYTE2_FLAG_FFA_PVP);
    }

    if (onlyFFA)
        return;

    if (pvpInfo.IsHostile)                               // in hostile area
    {
        if (!IsPvP() || pvpInfo.OffTime)
            UpdatePvP(true);
    }
    else                                                    // in friendly area
    {
        if (IsPvP() && !HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) && !pvpInfo.OffTime)
            UpdatePvP(false);
    }
}

void Player::SetPvP(bool state)
{
    Unit::SetPvP(state);
    for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        (*itr)->SetPvP(state);
}

void Player::StartPvPOffTimer()
{
    if (HasAura(148385)) // Censer of Eternal Agony
        return;

    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP);
    SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);
    pvpInfo.OffTime = TimeValue::Now() + Minutes(5);
}

void Player::StopPvPOffTimer()
{
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER);
    pvpInfo.OffTime = TimeValue::zero();
}

void Player::DisablePvP()
{
    StopPvPOffTimer();
    pvpInfo.LastPvPTime = TimeValue::zero();
    SetPvP(false);
}

void Player::UpdatePvP(bool state)
{
    if (state)
    {
        SetPvP(true);
        StopPvPOffTimer();
        if (!HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
            pvpInfo.LastPvPTime = TimeValue::Now();
    }
    else if (IsPvP())
    {
        AreaTableEntry const* zone = sAreaTableStore.LookupEntry(GetZoneId());
        if (zone && zone->IsSanctuary())
            DisablePvP();
        else if (!HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PVP_TIMER) && !HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP))
            StartPvPOffTimer();
    }
}

bool Player::HasSpellCooldown(uint32 spell_id) const
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return false;
    return !GetSpellHistory()->IsReady(spellInfo, 0, false);
}

uint32 Player::GetSpellCooldownDelay(uint32 spell_id) const
{
    return GetSpellHistory()->GetCooldownDelay(spell_id);
}

void Player::AddSpellCooldown(uint32 spellId, uint32 itemId, uint32 cooldown)
{
    GetSpellHistory()->AddCooldown(spellId, itemId, int64(cooldown), 0LL, 0LL);
}

void Player::AddSpellCooldown(uint32 spellId, TimeValue const& cooldown)
{
    GetSpellHistory()->AddCooldown(spellId, 0, cooldown.ToMilliseconds(), 0LL, 0LL);
}

void Player::AddCustomCooldown(uint32 spellId, TimeValue const& cooldown)
{
    AddSpellCooldown(spellId, cooldown);
    GetSpellHistory()->SendCooldown(spellId, cooldown.ToMilliseconds());
}

void Player::ModifySpellCooldown(uint32 spellId, int32 cooldown)
{
    GetSpellHistory()->ModifyCooldown(spellId, cooldown);

    TC_LOG_DEBUG("misc", "ModifySpellCooldown:: Player: %s (GUID: %u) Spell: %u cooldown: %u", GetName().c_str(), GetGUIDLow(), spellId, GetSpellCooldownDelay(spellId));
}

void Player::SendCooldownEvent(SpellInfo const* spellInfo, uint32 itemId, Spell* spell)
{
    GetSpellHistory()->SendCooldownEvent(spellInfo, itemId, spell);
}

void Player::UpdatePotionCooldown(Spell* spell)
{
    // no potion used i combat or still in combat
    if (!m_lastPotionId || IsInCombat())
        return;

    // Call not from spell cast, send cooldown event for item spells if no in combat
    if (!spell)
    {
        // spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(m_lastPotionId))
            for (uint8 idx = 0; idx < MAX_ITEM_SPELLS; ++idx)
                if (proto->Spells[idx].SpellId && proto->Spells[idx].SpellTrigger == ITEM_SPELLTRIGGER_ON_USE)
                    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[idx].SpellId))
                        SendCooldownEvent(spellInfo, m_lastPotionId);
    }
    // from spell cases (m_lastPotionId set in Spell::SendSpellCooldown)
    else
        SendCooldownEvent(spell->m_spellInfo, m_lastPotionId, spell);

    m_lastPotionId = 0;
}

void Player::SetResurrectRequestData(Unit* caster, uint32 health, uint32 mana, uint32 appliedAura)
{
    ASSERT(!IsRessurectRequested());
    _resurrectionData = new ResurrectionData();
    _resurrectionData->GUID = caster->GetGUID();
    _resurrectionData->Location.WorldRelocate(*caster);
    _resurrectionData->Health = health;
    _resurrectionData->Mana = mana;
    _resurrectionData->Aura = appliedAura;
}
                                                           //slot to be excluded while counting
bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
{
    if (!enchantmentcondition)
        return true;

    SpellItemEnchantmentConditionEntry const* Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);

    if (!Condition)
        return true;

    uint8 curcount[4] = {0, 0, 0, 0};

    //counting current equipped gem colors
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == slot)
            continue;
        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->IsBroken() && pItem2->GetTemplate()->Socket[0].Color)
        {
            for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
            {
                uint32 enchant_id = pItem2->GetEnchantmentId(EnchantmentSlot(enchant_slot));
                if (!enchant_id)
                    continue;

                SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
                if (!enchantEntry)
                    continue;

                uint32 gemid = enchantEntry->GemID;
                if (!gemid)
                    continue;

                ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemid);
                if (!gemProto)
                    continue;

                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GemProperties);
                if (!gemProperty)
                    continue;

                uint8 GemColor = gemProperty->color;

                for (uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
                {
                    if (tmpcolormask & GemColor)
                        ++curcount[b];
                }
            }
        }
    }

    bool activate = true;

    for (uint8 i = 0; i < 5; i++)
    {
        if (!Condition->Color[i])
            continue;

        uint32 _cur_gem = curcount[Condition->Color[i] - 1];

        // if have <CompareColor> use them as count, else use <value> from Condition
        uint32 _cmp_gem = Condition->CompareColor[i] ? curcount[Condition->CompareColor[i] - 1]: Condition->Value[i];

        switch (Condition->Comparator[i])
        {
            case 2:                                         // requires less <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem < _cmp_gem) ? true : false;
                break;
            case 3:                                         // requires more <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem > _cmp_gem) ? true : false;
                break;
            case 5:                                         // requires at least <color> than (<value> || <comparecolor>) gems
                activate &= (_cur_gem >= _cmp_gem) ? true : false;
                break;
        }
    }

    TC_LOG_DEBUG("entities.player.items", "Checking Condition %u, there are %u Meta Gems, %u Red Gems, %u Yellow Gems and %u Blue Gems, Activate:%s", enchantmentcondition, curcount[0], curcount[1], curcount[2], curcount[3], activate ? "yes" : "no");

    return activate;
}

void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
{
                                                            //cycle all equipped items
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        //enchants for the slot being socketed are handled by Player::ApplyItemMods
        if (slot == exceptslot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)
            continue;

        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            uint32 condition = enchantEntry->EnchantmentCondition;
            if (condition)
            {
                                                            //was enchant active with/without item?
                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
                                                            //should it now be?
                if (wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
                {
                    // ignore item gem conditions
                                                            //if state changed, (dis)apply enchant
                    ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), !wasactive, true, true);
                }
            }
        }
    }
}

                                                            //if false -> then toggled off if was on| if true -> toggled on if was off AND meets requirements
void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
{
    //cycle all equipped items
    for (int slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        //enchants for the slot being socketed are handled by WorldSession::HandleSocketOpcode(WorldPacket& recvData)
        if (slot == exceptslot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);

        if (!pItem || !pItem->GetTemplate()->Socket[0].Color)   //if item has no sockets or no item is equipped go to next item
            continue;

        //cycle all (gem)enchants
        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)                                 //if no enchant go to next enchant(slot)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            //only metagems to be (de)activated, so only enchants with condition
            uint32 condition = enchantEntry->EnchantmentCondition;
            if (condition)
                ApplyEnchantment(pItem, EnchantmentSlot(enchant_slot), apply);
        }
    }
}

void Player::SetBattlegroundEntryPoint()
{
    // Taxi path store
    if (!m_taxi.empty())
    {
        m_bgData.mountSpell  = 0;
        m_bgData.taxiPath[0] = m_taxi.GetTaxiSource();
        m_bgData.taxiPath[1] = m_taxi.GetTaxiDestination();
        m_bgData.taxiLastNode = m_taxi.GetLastNodeIndex();

        // On taxi we don't need check for dungeon
        m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }
    else
    {
        m_bgData.ClearTaxiPath();

        // Mount spell id storing
        if (IsMounted())
        {
            AuraEffectList const& auras = GetAuraEffectsByType(SPELL_AURA_MOUNTED);
            if (!auras.empty())
                m_bgData.mountSpell = (*auras.begin())->GetId();
        }
        else
            m_bgData.mountSpell = 0;

        // If map is dungeon find linked graveyard
        if (GetMap()->IsDungeon())
        {
            if (const WorldSafeLocsEntry* entry = sObjectMgr->GetClosestGraveYard(*this, GetTeam(), this))
                m_bgData.joinPos = WorldLocation(entry->map_id, entry->x, entry->y, entry->z, 0.0f);
            else
                TC_LOG_ERROR("entities.player", "SetBattlegroundEntryPoint: Dungeon map %u has no linked graveyard, setting home location as entry point.", GetMapId());
        }
        // If new entry point is not BG or arena set it
        else if (!GetMap()->IsBattlegroundOrArena())
            m_bgData.joinPos = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }

   if (m_bgData.joinPos.m_mapId == 37 && sWorld->getBoolConfig(CONFIG_ICORE_ROYALE_EVENT_ENABLED))
        m_bgData.joinPos.m_mapId = MAPID_INVALID;

    if (m_bgData.joinPos.m_mapId == MAPID_INVALID) // In error cases use homebind position
        m_bgData.joinPos = WorldLocation(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0.0f);
}

void Player::SetBGTeam(uint32 team)
{
    m_bgData.bgTeam = team;
    SetByteValue(PLAYER_FIELD_ARENA_FACTION, 3, uint8(team == ALLIANCE ? 1 : 0));
}

Team Player::GetBGTeam() const
{
    return Team(m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam());
}

void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    if (Battleground* bg = GetBattleground())
    {
        bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);

        // call after remove to be sure that player resurrected for correct cast
        if (!IsGameMaster())
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                // https://us.battle.net/forums/en/wow/topic/13242714145
                // a player who leaves an Arena or Rated Battleground before anyone in the match has entered combat will, at first, be given a 5-minute Deserter debuff.
                bool someoneInCombat = false;
                if (bg->IsRated() || bg->IsRatedBG())
                {
                    for (auto&& ref : GetMap()->GetPlayers())
                    {
                        if (ref.GetSource()->IsInCombat())
                        {
                            someoneInCombat = true;
                            break;
                        }
                    }
                }
                if (someoneInCombat)
                    return;

                // lets check if player was teleported from BG and schedule delayed Deserter spell cast
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                ApplyDeserter();
            }
        }
    }
}

bool Player::CanJoinToBattleground(Battleground const* bg) const
{
    // check Deserter debuff
    if (HasAura(26013))
        return false;

    return true;
}

bool Player::CanReportAfkDueToLimit()
{
    // a player can complain about 15 people per 5 minutes
    if (m_bgData.bgAfkReportedCount++ >= 15)
        return false;

    return true;
}

WorldLocation Player::GetStartPosition() const
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    uint32 mapId = info->mapId;
    float x = info->positionX;
    float y = info->positionY;
    float z = info->positionZ;
    if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
        mapId = 0;
    if (getRace() == RACE_GOBLIN && getClass() != CLASS_DEATH_KNIGHT && IsQuestRewarded(25266))
    {
        mapId = 1;
        x = 1469.29f;
        y = -5012.04f;
        z = 11.745f;
    }
    if (getRace() == RACE_WORGEN && getClass() != CLASS_DEATH_KNIGHT && IsQuestRewarded(26706))
    {
        mapId = 1;
        x = 8343.86f;
        y = 1165.28f;
        z = 4.40044f;
    }
    if (getRace() == RACE_PANDAREN_ALLIANCE && IsQuestRewarded(31450))
    {
        mapId = 0;
        x = -8960.02f;
        y = 516.10f;
        z = 96.36f;
    }
    if (getRace() == RACE_PANDAREN_HORDE && IsQuestRewarded(31450))
    {
        mapId = 1;
        x = 1357.62f;
        y = -4373.55f;
        z = 26.13f;
    }
    return WorldLocation(mapId, x, y, z, 0);
}

bool Player::IsNeverVisible() const
{
    if (Unit::IsNeverVisible())
        return true;

    if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
        return true;

    return false;
}

bool Player::CanAlwaysSee(WorldObject const* obj) const
{
    // Always can see self
    if (m_mover == obj)
        return true;

    if (uint64 guid = GetUInt64Value(PLAYER_FIELD_FARSIGHT_OBJECT))
        if (obj->GetGUID() == guid)
            return true;

    // Exploiting our visibility system to make summoned .premium NPCs only visible to the summoner
    if (obj->GetEntry() >= 190000)
        if (Unit const* unit = obj->ToUnit())
            if (TempSummon const* summon = unit->ToTempSummon())
                if (summon->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_project_NPC && summon->GetSummonerGUID() == GetGUID())
                    return true;

    return false;
}

bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
{
    if (Unit::IsAlwaysDetectableFor(seer))
        return true;

    if (const Player* seerPlayer = seer->ToPlayer())
        if (IsGroupVisibleFor(seerPlayer))
            return !(seerPlayer->duel && seerPlayer->duel->startTime != 0 && seerPlayer->duel->opponent == this);

    return false;
}

bool Player::IsVisibleGloballyFor(Player const* u) const
{
    if (!u)
        return false;

    // Always can see self
    if (u == this)
        return true;

    // Visible units, always are visible for all players
    if (IsVisible())
        return true;

    // GMs are visible for higher gms (or players are visible for gms)
    if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
        return GetSession()->GetSecurity() <= u->GetSession()->GetSecurity();

    // non faction visibility non-breakable for non-GMs
    if (!IsVisible())
        return false;

    // non-gm stealth/invisibility not hide from global player lists
    return true;
}

template<class T>
inline void UpdateVisibilityOf_helper(Player::ClientGUIDs& s64, T* target, std::set<Unit*>& /*v*/)
{
    s64.insert(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(Player::ClientGUIDs& s64, Creature* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<>
inline void UpdateVisibilityOf_helper(Player::ClientGUIDs& s64, Player* target, std::set<Unit*>& v)
{
    s64.insert(target->GetGUID());
    v.insert(target);
}

template<class T>
inline void BeforeVisibilityDestroy(T* /*t*/, Player* /*p*/) { }

template<>
inline void BeforeVisibilityDestroy<Creature>(Creature* t, Player* p)
{
    if (p->GetPetGUID() == t->GetGUID() && t->ToCreature()->IsPet())
        p->RemovePet(PET_REMOVE_DISMISS, PET_REMOVE_FLAG_RETURN_REAGENT | PET_REMOVE_FLAG_RESET_CURRENT);
}

void Player::UpdateVisibilityOf(WorldObject* target)
{
    if (HaveAtClient(target))
    {
        if (!CanSeeOrDetect(target, false, true))
        {
            if (Unit* unit = target->ToUnit())
            {
                if (Creature* vehicle = unit->GetVehicleCreatureBase())
                {
                    if (HaveAtClient(vehicle))
                    {
                        UpdateVisibilityOf(vehicle);
                        if (HaveAtClient(vehicle))
                            return;
                    }
                }
            }

            if (target->GetTypeId() == TYPEID_UNIT)
                BeforeVisibilityDestroy<Creature>(target->ToCreature(), this);

            target->DestroyForPlayer(this);
            m_clientGUIDs.erase(target->GetGUID());
            m_VignetteMgr.OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG("maps", "Object %u (Type: %u) out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else
    {
        if (CanSeeOrDetect(target, false, true))
        {
            if (Unit* unit = target->ToUnit())
            {
                if (Creature* vehicle = unit->GetVehicleCreatureBase())
                {
                    if (!HaveAtClient(vehicle))
                    {
                        UpdateVisibilityOf(vehicle);
                        if (!HaveAtClient(vehicle))
                            return;
                    }
                }
            }

            target->SendUpdateToPlayer(this);
            m_clientGUIDs.insert(target->GetGUID());
            m_VignetteMgr.OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG("maps", "Object %u (Type: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif

            // target aura duration for caster show only if target exist at caster client
            // send data at target visibility change (adding to client)
            if (target->isType(TYPEMASK_UNIT))
                SendInitialVisiblePackets((Unit*)target);
        }
    }
}

void Player::UpdateTriggerVisibility()
{
    if (m_clientGUIDs.empty())
        return;

    if (!IsInWorld())
        return;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (ClientGUIDs::iterator itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_CREATURE_GUID(*itr))
        {
            Creature* creature = GetMap()->GetCreature(*itr);
            // Update fields of triggers, transformed units or unselectable units (values dependent on GM state)
            if (!creature || (!creature->IsTrigger() && !creature->HasAuraType(SPELL_AURA_TRANSFORM) && !creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE)))
                continue;

            creature->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            creature->BuildValuesUpdateBlockForPlayer(&udata, this);
            creature->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
        else if (IS_GAMEOBJECT_GUID((*itr)))
        {
            GameObject* go = GetMap()->GetGameObject(*itr);
            if (!go)
                continue;

            go->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            go->BuildValuesUpdateBlockForPlayer(&udata, this);
            go->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
    }

    if (!udata.HasData())
        return;

    udata.BuildPacket(&packet);
    GetSession()->SendPacket(&packet);
}

void Player::SendInitialVisiblePackets(Unit* target)
{
    SendAurasForTarget(target);
    if (target->IsAlive())
    {
        if (target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && target->GetVictim())
            target->SendMeleeAttackStart(target->GetVictim());
    }
}

template<class T>
void Player::UpdateVisibilityOf(T* target, UpdateData& data, std::set<Unit*>& visibleNow)
{
    if (HaveAtClient(target))
    {
        if (!CanSeeOrDetect(target, false, true))
        {
            if (Unit* unit = target->ToUnit())
            {
                if (Creature* vehicle = unit->GetVehicleCreatureBase())
                {
                    if (HaveAtClient(vehicle))
                    {
                        UpdateVisibilityOf(vehicle, data, visibleNow);
                        if (HaveAtClient(vehicle))
                            return;
                    }
                }
            }

            BeforeVisibilityDestroy<T>(target, this);

            target->BuildOutOfRangeUpdateBlock(&data);
            m_clientGUIDs.erase(target->GetGUID());
            m_VignetteMgr.OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG("maps", "Object %u (Type: %u, Entry: %u) is out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else //if (visibleNow.size() < 30 || target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsVehicle())
    {
        if (CanSeeOrDetect(target, false, true))
        {
            if (Unit* unit = target->ToUnit())
            {
                if (Creature* vehicle = unit->GetVehicleCreatureBase())
                {
                    if (!HaveAtClient(vehicle))
                    {
                        UpdateVisibilityOf(vehicle, data, visibleNow);
                        if (!HaveAtClient(vehicle))
                            return;
                    }
                }
            }

            target->BuildCreateUpdateBlockForPlayer(&data, this);
            UpdateVisibilityOf_helper(m_clientGUIDs, target, visibleNow);
            m_VignetteMgr.OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG("maps", "Object %u (Type: %u, Entry: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
}

template void Player::UpdateVisibilityOf(Player*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Creature*      target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Corpse*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(GameObject*    target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(DynamicObject* target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(AreaTrigger*   target, UpdateData& data, std::set<Unit*>& visibleNow);

void Player::UpdateVisibilityForPlayer()
{
    // updates visibility of all objects around point of view for current player
    Trinity::VisibleNotifier notifier(*this);
    m_seer->VisitNearbyObject(GetSightRange(), notifier, true, true);
    if (m_seer->IsInWorld())
    {
        notifier.VisitSet(m_seer->GetMap()->GetCustomVisibilityObjects());
        notifier.VisitSet(m_seer->GetMap()->GetCustomVisibilityObjects(m_seer == this ? m_zoneUpdateId : m_seer->GetZoneId()));
    }
    notifier.SendToSelf();   // send gathered data
}

void Player::InitPrimaryProfessions()
{
    SetFreePrimaryProfessions(sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL));
}

bool Player::ModifyMoney(int64 amount, bool sendError /*= true*/)
{
    if (!amount)
        return true;

    sScriptMgr->OnPlayerMoneyChanged(this, amount);

    if (amount < 0)
        SetMoney(GetMoney() > uint64(-amount) ? GetMoney() + amount : 0);
    else
    {
        if (GetMoney() < uint64(MAX_MONEY_AMOUNT - amount))
            SetMoney(GetMoney() + amount);
        else
        {
            if (sendError)
                SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD, NULL, NULL);
            return false;
        }
    }

    return true;
}

bool Player::HasEnoughMoney(int64 amount) const
{
    if (amount > 0)
        return (GetMoney() >= (uint64) amount);
    return true;
}

void Player::SetMoney(uint64 value)
{
    SetUInt64Value(PLAYER_FIELD_COINAGE, value);
    MoneyChanged(value);
    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HIGHEST_GOLD_VALUE_OWNED);
}

bool Player::IsQuestRewarded(uint32 quest_id) const
{
    if (m_RewardedQuests.find(quest_id) == m_RewardedQuests.end())
        return false;

    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest_id);
    if (!qInfo)
        return false;

    return !qInfo->IsSeasonal() || !const_cast<Player*>(this)->SatisfyQuestSeasonal(qInfo, false);
}

Unit* Player::GetSelectedUnit() const
{
    if (uint64 selectionGUID = GetUInt64Value(UNIT_FIELD_TARGET))
        return ObjectAccessor::GetUnit(*this, selectionGUID);
    return NULL;
}

Player* Player::GetSelectedPlayer() const
{
    if (uint64 selectionGUID = GetUInt64Value(UNIT_FIELD_TARGET))
        return ObjectAccessor::GetPlayer(*this, selectionGUID);
    return NULL;
}

void Player::SendComboPoints()
{
    Unit* combotarget = ObjectAccessor::GetUnit(*this, m_comboTarget);
    if (combotarget)
    {
        WorldPacket data;
        ObjectGuid guid = combotarget->GetGUID();
        if (m_mover != this)
        {
            ObjectGuid mover = m_mover->GetGUID();
            data.Initialize(SMSG_PET_UPDATE_COMBO_POINTS, m_mover->GetPackGUID().size() + combotarget->GetPackGUID().size() + 1);
            data.WriteGuidMask(mover, 1, 7);
            data.WriteGuidMask(guid, 6, 3, 7);
            data.WriteGuidMask(mover, 3, 4);
            data.WriteGuidMask(guid, 0, 4);
            data.WriteGuidMask(mover, 0);
            data.WriteGuidMask(guid, 5);
            data.WriteGuidMask(mover, 2, 5, 6);
            data.WriteGuidMask(guid, 1, 2);

            data.WriteGuidBytes(guid, 5, 4);
            data.WriteGuidBytes(mover, 3, 0, 5);
            data.WriteGuidBytes(guid, 0);
            data.WriteGuidBytes(mover, 2);
            data.WriteGuidBytes(guid, 1, 7, 6, 2);
            data.WriteGuidBytes(mover, 1, 6);
            data << uint8(m_comboPoints);
            data.WriteGuidBytes(mover, 4, 7);
            data.WriteGuidBytes(guid, 3);
        }
        else
        {
            data.Initialize(SMSG_UPDATE_COMBO_POINTS, combotarget->GetPackGUID().size() + 1);
            data.WriteGuidMask(guid, 0, 5, 6, 3, 7, 4, 1, 2);
            data.WriteGuidBytes(guid, 5, 6, 4, 7, 3, 0);
            data << uint8(m_comboPoints);
            data.WriteGuidBytes(guid, 2, 1);
        }
        GetSession()->SendPacket(&data);
    }
}

void Player::AddComboPoints(Unit* target, int8 count, Spell* spell)
{
    if (!count)
        return;

    if (spell)
    {
        int32 charges = m_comboPoints + count - 5;
        if (charges > 0 && HasAura(114015)) // Anticipation
            CastCustomSpell(115189, SPELLVALUE_AURA_STACK, charges, this, true);    // TODO: Check this shit, possible error in SPELLVALUE_AURA_STACK mechanic
    }

    // without combo points lost (duration checked in aura)
    RemoveAurasByType(SPELL_AURA_RETAIN_COMBO_POINTS);

    if (target->GetGUID() == m_comboTarget)
        m_comboPoints += count;
    else
    {
        if (m_comboTarget)
            if (Unit* target2 = ObjectAccessor::GetUnit(*this, m_comboTarget))
                target2->RemoveComboPointHolder(GetGUIDLow());

        m_comboTarget = target->GetGUID();
        m_comboPoints = count;

        target->AddComboPointHolder(GetGUIDLow());
    }

    if (m_comboPoints > 5)
        m_comboPoints = 5;
    else if (m_comboPoints < 0)
        m_comboPoints = 0;

    SendComboPoints();
}

void Player::ClearComboPoints()
{
    if (!m_comboTarget)
        return;

    // without combopoints lost (duration checked in aura)
    RemoveAurasByType(SPELL_AURA_RETAIN_COMBO_POINTS);

    m_comboPoints = 0;

    SendComboPoints();

    if (Unit* target = ObjectAccessor::GetUnit(*this, m_comboTarget))
        target->RemoveComboPointHolder(GetGUIDLow());

    m_comboTarget = 0;
}

void Player::SetGroup(GroupSlot slot, Group* group, int8 subgroup)
{
    auto& ref = m_group[uint32(slot)];
    if (!group)
        ref.unlink();
    else
    {
        // never use SetGroup without a subgroup unless you specify NULL for group
        ASSERT(!GetGroup(slot));
        ASSERT(subgroup >= 0);
        ref.link(group, this);
        ref.setSubGroup((uint8)subgroup);
    }

    UpdateObjectVisibility(false);
}

void Player::SendInitialPacketsBeforeAddToMap()
{
    /// Pass 'this' as argument because we're not stored in ObjectAccessor yet
    GetSocial()->SendSocialList(this);

    // guild bank list wtf?

    // Homebind
    WorldPacket data(SMSG_BINDPOINTUPDATE, 4 + 4 + 4 + 4 + 4);
    data << m_homebindX;
    data << m_homebindZ;
    data << m_homebindY;
    data << (uint32) m_homebindAreaId;
    data << (uint32) m_homebindMapId;
    GetSession()->SendPacket(&data);

    SendTalentsInfoData(); // SMSG_TALENTS_INFO
    SendInitialSpells();   // SMSG_INITIAL_SPELLS
    SendUnlearnSpells();   // SMSG_SEND_UNLEARN_SPELLS
    GetSpellHistory()->SendSpellHistory();  // SMSG_SEND_SPELL_HISTORY and SMSG_SEND_SPELL_CHARGES 

    SendInitialActionButtons();
    m_reputationMgr->SendInitialReputations();
    GetAchievementMgr().SendAllAchievementData();

    SendEquipmentSetList();

    data.Initialize(SMSG_LOGIN_SETTIMESPEED, 20);
    data << uint32(0);
    data.AppendPackedTime(sWorld->GetGameTime());
    data << uint32(0);
    data.AppendPackedTime(sWorld->GetGameTime());
    data << float(0.01666667f);                             // game speed
    GetSession()->SendPacket(&data);

    GetSession()->SendServerWorldInfo();
    SendInitialSetup(); // SMSG_INITIAL_SETUP

    // SMSG_TALENTS_INFO x 2 for pet (unspent points and talents in separate packets...)
    // SMSG_PET_GUIDS
    // SMSG_UPDATE_WORLD_STATE
    // SMSG_POWER_UPDATE

    SendCurrencies();
    SetMover(this);
}

void Player::SendInitialPacketsAfterAddToMap()
{
    UpdateVisibilityForPlayer();

    // update zone
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea);
    UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();

    ResetTimeSync();
    SendTimeSync();

    GetSession()->SendLoadCUFProfiles();

    CastSpell(this, 836, true);                             // LOGINEFFECT

    // set some aura effects that send packet to player client after add player to map
    // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
    // same auras state lost at far teleport, send it one more time in this case also
    static const AuraType auratypes[] =
    {
        SPELL_AURA_MOD_FEAR,     SPELL_AURA_TRANSFORM,                 SPELL_AURA_WATER_WALK,
        SPELL_AURA_FEATHER_FALL, SPELL_AURA_HOVER,                     SPELL_AURA_SAFE_FALL,
        SPELL_AURA_FLY,          SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED, SPELL_AURA_NONE
    };
    for (AuraType const* itr = &auratypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        Unit::AuraEffectList const& auraList = GetAuraEffectsByType(*itr);
        if (!auraList.empty())
            auraList.front()->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
    }

    if (HasAuraType(SPELL_AURA_MOD_STUN))
        SetRooted(true);

    // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
    if (HasAuraType(SPELL_AURA_MOD_ROOT))
        SetRooted(true, true);

    SendAurasForTarget(this);
    SendEnchantmentDurations();                             // must be after add to map
    SendItemDurations();                                    // must be after add to map

                                                            // Send difficulties on login.

    SendDungeonDifficulty(GetDungeonDifficulty() < DUNGEON_DIFFICULTY_NORMAL ? DUNGEON_DIFFICULTY_NORMAL : GetDungeonDifficulty());

    // Raid downscaling.
    if (GetMap()->IsRaid())
    {
        if (GetMap()->GetDifficulty() != GetRaidDifficulty())
        {
            StoreRaidMapDifficulty();
            SendRaidDifficulty(GetStoredRaidDifficulty());
        }
    }
    else if (GetRaidDifficulty() != GetStoredRaidDifficulty())
        SendRaidDifficulty(GetRaidDifficulty() < RAID_DIFFICULTY_10MAN_NORMAL ? RAID_DIFFICULTY_10MAN_NORMAL : GetRaidDifficulty());

    m_battlePetMgr->SendBattlePetJournalLock();

    std::vector<SpellModifier*> spellmods;
    spellmods.reserve(MAX_SPELLMOD * 2);
    for (auto&& mods : m_spellMods)
        for (auto&& itr : mods)
            spellmods.push_back(itr);

    for (auto&& itr : spellmods)
    {
        AddSpellMod(itr, false);
        AddSpellMod(itr, true);
    }

    if (getClass() == CLASS_DEATH_KNIGHT)
    {
        for (auto&& effect : GetAuraEffectsByType(SPELL_AURA_CONVERT_RUNE))
        {
            uint32 runes = effect->GetAmount();
            for (uint32 i = 0; i < MAX_RUNES && runes; ++i)
                if (effect->GetMiscValue() == GetBaseRune(i))
                    ConvertRune(i, RuneType(effect->GetMiscValueB()));
        }
    }

    UpdateAllowedItemLevel();

    ReapplyItemsBonuses();

    for (auto&& powerType : { POWER_SOUL_SHARDS, POWER_BURNING_EMBERS })
    {
        // Re-trigger visuals
        if (GetPowerIndex(powerType) != MAX_POWERS)
        {
            int32 power = GetPower(powerType);
            SetPower(powerType, 0);
            SetPower(powerType, power);
        }
    }

    if (!GetGroup() || !GetGroup()->IsLeader(GetGUID()))
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);

    UpdateValorOfTheAncients();
    UpdatePromotionAuras();

    if (GetSkillValue(SKILL_COOKING) >= 600 && HasAchieved(7306, true) && GetQuestStatus(33020) == QUEST_STATUS_NONE)
        if (Quest const* quest = sObjectMgr->GetQuestTemplate(33020))
        {
            AddQuest(quest, this);
            PlayerTalkClass->SendQuestGiverQuestDetails(quest, GetGUID(), true, true);
        }
}

void Player::SendUpdateToOutOfRangeGroupMembers()
{
    if (m_groupUpdateMask == GROUP_UPDATE_FLAG_NONE)
        return;
    if (Group* group = GetGroup())
        group->UpdatePlayerOutOfRange(this);

    m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;
    m_auraRaidUpdateMask = 0;
    if (Pet* pet = GetPet())
        pet->ResetAuraUpdateMaskForRaid();
}

void Player::SendTransferAborted(uint32 mapid, TransferAbortReason reason, uint8 arg)
{
    WorldPacket data(SMSG_TRANSFER_ABORTED, 4 + 2);
    data.WriteBit(!arg);
    data.WriteBits(reason, 5); // transfer abort reason
    if (arg)
        data << uint8(arg);
    data << uint32(mapid);
    GetSession()->SendPacket(&data);
}

void Player::SendGameError(GameError error, uint32 arg1, uint32 arg2)
{
    WorldPacket data(SMSG_DISPLAY_GAME_ERROR);
    data << uint32(error);
    data.WriteBit(arg1 ? true : false);
    data.WriteBit(arg2 ? true : false);

    if (arg1)
        data << uint32(arg1);
    if (arg2)
        data << uint32(arg2);

    GetSession()->SendPacket(&data);
}

void Player::SendAreaTriggerDenied(uint32 trigger, bool entered)
{
    WorldPacket data(SMSG_AREA_TRIGGER_DENIED, 5);
    data << uint32(trigger);
    data.WriteBit(entered);
    GetSession()->SendPacket(&data);
}

void Player::SendInstanceResetWarning(uint32 mapid, Difficulty difficulty, uint32 time)
{
    // type of warning, based on the time remaining until reset
    uint32 type;
    if (time > 3600)
        type = RAID_INSTANCE_WELCOME;
    else if (time > 900 && time <= 3600)
        type = RAID_INSTANCE_WARNING_HOURS;
    else if (time > 300 && time <= 900)
        type = RAID_INSTANCE_WARNING_MIN;
    else
        type = RAID_INSTANCE_WARNING_MIN_SOON;

    WorldPacket data(SMSG_RAID_INSTANCE_MESSAGE, 4 + 4 + 4 + 4);
    data.WriteBit(0);                                   // is locked
    data.WriteBit(0);                                   // is extended, ignored if prev field is 0
    data << uint32(mapid);
    data << uint8(type);
    data << uint32(time);
    data << uint32(difficulty);                         // difficulty
    GetSession()->SendPacket(&data);
}

void Player::ApplyEquipCooldown(Item* pItem)
{
    if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_PROTO_FLAG_NO_EQUIP_COOLDOWN))
        return;

    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
    {
        _Spell const& spellData = pItem->GetTemplate()->Spells[i];

        // no spell
        if (!spellData.SpellId)
            continue;

        // wrong triggering type (note: ITEM_SPELLTRIGGER_ON_NO_DELAY_USE not have cooldown)
        if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        // Don't replace longer cooldowns by equip cooldown if we have any.
        if (GetSpellHistory()->GetCooldownDelay(spellData.SpellId, pItem->GetEntry()) > 30 * IN_MILLISECONDS)
            continue;

        AddSpellCooldown(spellData.SpellId, pItem->GetEntry(), 30 * IN_MILLISECONDS);

        WorldPacket data(SMSG_ITEM_COOLDOWN, 12);
        data << pItem->GetGUID();
        data << uint32(spellData.SpellId);
        GetSession()->SendPacket(&data);
    }
}

void Player::ResetSpells(bool myClassOnly)
{
    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_SPELLS, true);

    // make full copy of map (spells removed and marked as deleted at another spell remove
    // and we can't use original map for safe iterative with visit each spell at loop end
    PlayerSpellMap smap = GetSpellMap();

    uint32 family;

    if (myClassOnly)
    {
        ChrClassesEntry const* clsEntry = sChrClassesStore.LookupEntry(getClass());
        if (!clsEntry)
            return;
        family = clsEntry->spellfamily;

        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(iter->first);
            if (!spellInfo)
                continue;

            // skip server-side/triggered spells
            if (spellInfo->SpellLevel == 0)
                continue;

            // skip wrong class/race skills
            if (!IsSpellFitByClassAndRace(spellInfo->Id))
                continue;

            // skip other spell families
            if (spellInfo->SpellFamilyName != family)
                continue;

            // skip spells with first rank learned as talent (and all talents then also)
            uint32 firstRank = spellInfo->GetFirstRankSpell()->Id;
            if (GetTalentSpellCost(firstRank) > 0)
                continue;

            // skip broken spells
            if (!SpellMgr::IsSpellValid(spellInfo, this, false))
                continue;
        }
    }
    else
        for (PlayerSpellMap::const_iterator iter = smap.begin(); iter != smap.end(); ++iter)
            RemoveSpell(iter->first, false, false);           // only iter->first can be accessed, object by iter->second can be deleted already

    LearnDefaultSkills();
    learnQuestRewardedSpells();
}

void Player::LearnDefaultSkills()
{
    // learn default race/class spells
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    for (auto&& id : info->skills)
    {
        auto entry = sSkillRaceClassInfoStore.LookupEntry(id);
        if (!entry || entry->ReqLevel > getLevel())
            continue;

        if (HasSkill(entry->SkillId))
            continue;

        LearnDefaultSkill(entry);
    }
}

void Player::LearnDefaultSkill(SkillRaceClassInfoEntry const* entry)
{
    uint32 skillId = entry->SkillId;
    auto skillLine = sSkillLineStore.LookupEntry(skillId);
    if (!skillLine)
        return;
    
    switch (GetSkillRangeType(skillLine, false))
    {
        case SKILL_RANGE_LANGUAGE:
            SetSkill(skillId, 0, 300, 300);
            break;
        case SKILL_RANGE_LEVEL:
        {
            uint16 skillValue = 1;
            uint16 maxValue = GetMaxSkillValueForLevel();
            if (entry->Flags & 0x10)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT)
                skillValue = std::min(std::max<uint16>({ 1, uint16((getLevel() - 1) * 5) }), maxValue);
            else if (skillId == SKILL_FIST_WEAPONS)
                skillValue = std::max<uint16>(1, GetSkillValue(SKILL_UNARMED));

            SetSkill(skillId, 0, skillValue, maxValue);
            break;
        }
        case SKILL_RANGE_MONO:
            SetSkill(skillId, 0, 1, 1);
            break;
        case SKILL_RANGE_RANK:
        {
            uint16 rank = 1;
            if (getClass() == CLASS_DEATH_KNIGHT && skillId == SKILL_FIRST_AID)
                rank = 4;

            //SkillTiersEntry const* tier = sObjectMgr->GetSkillTier(rcInfo->SkillTierID);
            uint16 maxValue = rank * 75;
            uint16 skillValue = 1;
            if (entry->Flags & 0x10)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT)
                skillValue = std::min(std::max(uint16(1), uint16((getLevel() - 1) * 5)), maxValue);

            SetSkill(skillId, GetSkillStep(skillLine->id), skillValue, maxValue);
            break;
        }
        default:
            break;
    }
}

void Player::LearnSpecializationSpells()
{
    auto spells = dbc::GetSpecializetionSpells(GetTalentSpecialization());
    if (!spells)
        return;

    uint8 level = getLevel();
    for (auto&& spell : *spells)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
        if (!spellInfo)
            continue;

        if (spellInfo->SpellLevel > level)
            continue;

        LearnSpell(spellInfo->Id, true);
    }
}

void Player::learnQuestRewardedSpells(Quest const* quest)
{
    int32 spell_id = quest->GetRewSpellCast();
    uint32 src_spell_id = quest->GetSrcSpell();

    // skip quests without rewarded spell
    if (!spell_id)
        return;

    // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
    if (spell_id == -1 && src_spell_id)
    {
        RemoveAurasDueToSpell(src_spell_id);
        return;
    }

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return;

    // check learned spells state
    bool found = false;
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (spellInfo->Effects[i].Effect == SPELL_EFFECT_LEARN_SPELL && !HasSpell(spellInfo->Effects[i].TriggerSpell))
        {
            found = true;
            break;
        }
    }

    // skip quests with not teaching spell or already known spell
    if (!found)
        return;

    // prevent learn non first rank unknown profession and second specialization for same profession)
    uint32 learned_0 = spellInfo->Effects[0].TriggerSpell;
    if (sSpellMgr->GetSpellRank(learned_0) > 1 && !HasSpell(learned_0))
    {
        SpellInfo const* learnedInfo = sSpellMgr->GetSpellInfo(learned_0);
        if (!learnedInfo)
            return;

        // not have first rank learned (unlearned prof?)
        if (!HasSpell(learnedInfo->GetFirstRankSpell()->Id))
            return;

        SpellsRequiringSpellMapBounds spellsRequired = sSpellMgr->GetSpellsRequiredForSpellBounds(learned_0);
        for (SpellsRequiringSpellMap::const_iterator itr2 = spellsRequired.first; itr2 != spellsRequired.second; ++itr2)
        {
            uint32 profSpell = itr2->second;

            // specialization
            if (learnedInfo->Effects[0].Effect == SPELL_EFFECT_TRADE_SKILL && learnedInfo->Effects[1].Effect == 0 && profSpell)
            {
                // search other specialization for same prof
                for (PlayerSpellMap::const_iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
                {
                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->first == learned_0)
                        continue;

                    SpellInfo const* itrInfo = sSpellMgr->GetSpellInfo(itr->first);
                    if (!itrInfo)
                        return;

                    // compare only specializations
                    if (itrInfo->Effects[0].Effect != SPELL_EFFECT_TRADE_SKILL || itrInfo->Effects[1].Effect != 0)
                        continue;

                    // compare same chain spells
                    if (sSpellMgr->IsSpellRequiringSpell(itr->first, profSpell))
                        return;
                }
            }
        }
    }

    CastSpell(this, spell_id, true);
}

void Player::learnQuestRewardedSpells()
{
    // learn spells received from quest completing
    for (RewardedQuestSet::const_iterator itr = m_RewardedQuests.begin(); itr != m_RewardedQuests.end(); ++itr)
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(*itr);
        if (!quest)
            continue;

        learnQuestRewardedSpells(quest);
    }
}

void Player::LearnSkillRewardedSpells(uint32 id, uint32 value)
{
    uint32 raceMask  = getRaceMask();
    uint32 classMask = getClassMask();
    auto abilities = GetAbilitiesBySkill(id);
    if (!abilities)
        return;
    for (auto&& ability : *abilities)
    {
        SpellInfo const* spell = sSpellMgr->GetSpellInfo(ability->spellId);
        if (!spell)
            continue;

        // Check race if set
        if (ability->racemask && !(ability->racemask & raceMask))
            continue;
        // Check class if set
        if (ability->classmask && !(ability->classmask & classMask))
            continue;

        if (getLevel() < spell->SpellLevel)
            continue;

        // need unlearn spell
        if (value < ability->req_skill_value && ability->learnOnGetSkill == ABILITY_LEARNED_ON_GET_PROFESSION_SKILL)
            RemoveSpell(ability->spellId);
        // need learn
        else if (!IsInWorld())
            AddSpell(ability->spellId, true, true, true, false);
        else
            LearnSpell(ability->spellId, true);
    }

    if (id == SKILL_JEWELCRAFTING)
        if (!HasSpell(55534))
            LearnSpell(55534, false);
}

void Player::SendAurasForTarget(Unit* target)
{
    if (!target || target->GetVisibleAuras()->empty())                  // speedup things
        return;

    /*! Blizz sends certain movement packets sometimes even before CreateObject
        These movement packets are usually found in SMSG_COMPRESSED_MOVES
    */
    if (target->HasAuraType(SPELL_AURA_FEATHER_FALL))
        target->SetFeatherFall(true, true);

    if (target->HasAuraType(SPELL_AURA_WATER_WALK))
        target->SetWaterWalking(true, true);

    if (target->HasAuraType(SPELL_AURA_HOVER))
        target->SetHover(true, true);

    ObjectGuid targetGuid = target->GetGUID();
    Unit::VisibleAuraMap const* visibleAuras = target->GetVisibleAuras();

    WorldPacket data(SMSG_AURA_UPDATE);
    data.WriteBit(targetGuid[7]);
    data.WriteBit(1);                                   // Is AURA_UPDATE_ALL
    data.WriteBits(visibleAuras->size(), 24);           // Aura Count
    data.WriteBit(targetGuid[6]);
    data.WriteBit(targetGuid[1]);
    data.WriteBit(targetGuid[3]);
    data.WriteBit(targetGuid[0]);
    data.WriteBit(targetGuid[4]);
    data.WriteBit(targetGuid[2]);
    data.WriteBit(targetGuid[5]);

    for (Unit::VisibleAuraMap::const_iterator itr = visibleAuras->begin(); itr != visibleAuras->end(); ++itr)
    {
        AuraApplication * auraApp = itr->second;
        Aura const* aura = auraApp->GetBase();
        uint32 flags = auraApp->GetFlags();
        if (aura->GetMaxDuration() > 0 && !(aura->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_HIDE_DURATION))
            flags |= AFLAG_DURATION;

        data.WriteBit(1);                               // Not remove

        uint32 effCount = 0;
        if (flags & AFLAG_ANY_EFFECT_AMOUNT_SENT)
            for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
                if ((auraApp->GetEffectMask() & (1 <<  i)) && aura->HasEffect(i))
                    effCount = i + 1;

        data.WriteBits(effCount, 22);                   // Effect Count

        data.WriteBit(!(flags & AFLAG_CASTER));         // HasCasterGuid

        if (!(flags & AFLAG_CASTER))
        {
            ObjectGuid casterGuid = aura->GetCasterGUID();
            data.WriteBit(casterGuid[3]);
            data.WriteBit(casterGuid[4]);
            data.WriteBit(casterGuid[6]);
            data.WriteBit(casterGuid[1]);
            data.WriteBit(casterGuid[5]);
            data.WriteBit(casterGuid[2]);
            data.WriteBit(casterGuid[0]);
            data.WriteBit(casterGuid[7]);
        }

        data.WriteBits(0, 22);                          // Unk effect count
        data.WriteBit(flags & AFLAG_DURATION);          // HasDuration
        data.WriteBit(flags & AFLAG_DURATION);          // HasMaxDuration
    }

    data.FlushBits();

    for (Unit::VisibleAuraMap::const_iterator itr = visibleAuras->begin(); itr != visibleAuras->end(); ++itr)
    {
        AuraApplication * auraApp = itr->second;
        Aura const* aura = auraApp->GetBase();
        uint32 flags = auraApp->GetFlags();
        if (aura->GetMaxDuration() > 0 && !(aura->GetSpellInfo()->AttributesEx5 & SPELL_ATTR5_HIDE_DURATION))
            flags |= AFLAG_DURATION;

        if (!(flags & AFLAG_CASTER))
        {
            ObjectGuid casterGuid = aura->GetCasterGUID();
            data.WriteByteSeq(casterGuid[3]);
            data.WriteByteSeq(casterGuid[2]);
            data.WriteByteSeq(casterGuid[1]);
            data.WriteByteSeq(casterGuid[6]);
            data.WriteByteSeq(casterGuid[4]);
            data.WriteByteSeq(casterGuid[0]);
            data.WriteByteSeq(casterGuid[5]);
            data.WriteByteSeq(casterGuid[7]);
        }

        data << uint8(flags);
        data << uint16(aura->GetCasterLevel());
        data << uint32(aura->GetId());

        if (flags & AFLAG_DURATION)
            data << uint32(aura->GetMaxDuration());

        if (flags & AFLAG_DURATION)
            data << uint32(aura->GetDuration());

        // send stack amount for aura which could be stacked (never 0 - causes incorrect display) or charges
        // stack amount has priority over charges (checked on retail with spell 50262)
        data << uint8(aura->GetSpellInfo()->StackAmount ? aura->GetStackAmount() : aura->GetCharges());
        data << uint32(auraApp->GetEffectMask());

        if (flags & AFLAG_ANY_EFFECT_AMOUNT_SENT)
        {
            for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
            {
                if (auraApp->GetEffectMask() < (1U << i))
                    break;

                float amount = 0.0f;
                if (auraApp->GetEffectMask() & (1 << i))
                    if (AuraEffect const* eff = aura->GetEffect(i))
                        amount = eff->GetFloatAmount();
                data << float(amount);
            }
        }

        data << uint8(auraApp->GetSlot());
    }

    data.WriteByteSeq(targetGuid[2]);
    data.WriteByteSeq(targetGuid[6]);
    data.WriteByteSeq(targetGuid[7]);
    data.WriteByteSeq(targetGuid[1]);
    data.WriteByteSeq(targetGuid[3]);
    data.WriteByteSeq(targetGuid[4]);
    data.WriteByteSeq(targetGuid[0]);
    data.WriteByteSeq(targetGuid[5]);

    GetSession()->SendPacket(&data);

    target->SendResumeCastBar(this);
}

void Player::SetDailyQuestStatus(uint32 quest_id)
{
    if (Quest const* qQuest = sObjectMgr->GetQuestTemplate(quest_id))
    {
        m_dailyquests.insert(quest_id);

        m_lastDailyQuestTime = time(nullptr);              // last daily quest time
        m_DailyQuestChanged = true;
    }
}

bool Player::IsDailyQuestDone(uint32 quest_id) const
{
    if (!sObjectMgr->GetQuestTemplate(quest_id))
        return false;

    for (auto&& dailyQuestId : m_dailyquests)
        if (dailyQuestId == quest_id)
            return true;

    return false;
}

void Player::SetWeeklyQuestStatus(uint32 quest_id)
{
    m_weeklyquests.insert(quest_id);
    m_WeeklyQuestChanged = true;
}

bool Player::IsWeeklyQuestDone(uint32 quest_id) const
{
    if (!sObjectMgr->GetQuestTemplate(quest_id))
        return false;

    for (auto&& weeklyQuestId : m_weeklyquests)
        if (weeklyQuestId == quest_id)
            return true;

    return false;
}

void Player::SetSeasonalQuestStatus(uint32 quest_id)
{
    Quest const* quest = sObjectMgr->GetQuestTemplate(quest_id);
    if (!quest)
        return;

    m_seasonalquests[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
    m_SeasonalQuestChanged = true;
}

void Player::SetMonthlyQuestStatus(uint32 quest_id)
{
    m_monthlyquests.insert(quest_id);
    m_MonthlyQuestChanged = true;
}

bool Player::IsMonthlyQuestDone(uint32 quest_id) const
{
    if (!sObjectMgr->GetQuestTemplate(quest_id))
        return false;

    for (auto&& monthlyQuestId : m_monthlyquests)
        if (monthlyQuestId == quest_id)
            return true;

    return false;
}

void Player::ResetDailyQuestStatus()
{
    SendClearQuestCompletedBits(m_dailyquests);

    m_dailyquests.clear();

    // DB data deleted in caller
    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;
}

void Player::ResetWeeklyQuestStatus()
{
    if (m_weeklyquests.empty())
        return;

    SendClearQuestCompletedBits(m_weeklyquests);

    m_weeklyquests.clear();
    // DB data deleted in caller
    m_WeeklyQuestChanged = false;

}

void Player::ResetSeasonalQuestStatus(uint16 event_id)
{
    auto eventItr = m_seasonalquests.find(event_id);
    if (eventItr == m_seasonalquests.end())
        return;

    if (eventItr->second.empty())
        return;

    QuestSet m_seasonalquestsBits;
    for (auto quest_id : m_seasonalquests[event_id])
        m_seasonalquestsBits.insert(quest_id);

    SendClearQuestCompletedBits(m_seasonalquestsBits);
    m_seasonalquestsBits.clear();

    m_seasonalquests.erase(event_id);
    // DB data deleted in caller
    m_SeasonalQuestChanged = false;
}

void Player::ResetMonthlyQuestStatus()
{
    if (m_monthlyquests.empty())
        return;

    SendClearQuestCompletedBits(m_monthlyquests);

    m_monthlyquests.clear();
    // DB data deleted in caller
    m_MonthlyQuestChanged = false;
}

void Player::SendClearQuestCompletedBits(QuestSet quests)
{
    if (quests.empty())
        return;

    uint32 count = 0;
    WorldPacket data(SMSG_CLEAR_QUEST_COMPLETED_BITS);
    size_t bitPos = data.bitwpos();
    data.WriteBits(count, 22);
    data.FlushBits();
    for (auto&& questId : quests)
    {
        if (uint32 questBit = GetQuestUniqueBitFlag(questId))
        {
            if (!questBit)
                continue;

            data << uint32(questBit);
            count++;

            _completedQuestBits.reset(questBit - 1);
        }
    }
    data.PutBits(bitPos, count, 22);

    SendDirectMessage(&data);
}

Battleground* Player::GetBattleground() const
{
    if (GetBattlegroundId() == 0)
        return NULL;

    return sBattlegroundMgr->GetBattleground(GetBattlegroundId(), m_bgData.bgTypeID);
}

bool Player::InBattlegroundQueue() const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId != BATTLEGROUND_QUEUE_NONE)
            return true;
    return false;
}

BattlegroundQueueTypeId Player::GetBattlegroundQueueTypeId(uint32 index) const
{
    return m_bgBattlegroundQueueID[index].bgQueueTypeId;
}

uint32 Player::GetBattlegroundQueueIndex(BattlegroundQueueTypeId bgQueueTypeId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            return i;
    return PLAYER_MAX_BATTLEGROUND_QUEUES;
}

bool Player::IsInvitedForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            return m_bgBattlegroundQueueID[i].invitedToInstance != 0;
    return false;
}

bool Player::InBattlegroundQueueForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId) const
{
    return GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES;
}

void Player::SetBattlegroundId(uint32 val, BattlegroundTypeId bgTypeId)
{
    m_bgData.bgInstanceID = val;
    m_bgData.bgTypeID = bgTypeId;
}

uint32 Player::AddBattlegroundQueueId(BattlegroundQueueTypeId val)
{
    for (uint8 i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
    {
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == BATTLEGROUND_QUEUE_NONE || m_bgBattlegroundQueueID[i].bgQueueTypeId == val)
        {
            m_bgBattlegroundQueueID[i].bgQueueTypeId = val;
            m_bgBattlegroundQueueID[i].invitedToInstance = 0;
            return i;
        }
    }
    return PLAYER_MAX_BATTLEGROUND_QUEUES;
}

bool Player::HasFreeBattlegroundQueueId()
{
    for (uint8 i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == BATTLEGROUND_QUEUE_NONE)
            return true;
    return false;
}

void Player::RemoveBattlegroundQueueId(BattlegroundQueueTypeId val)
{
    for (uint8 i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
    {
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == val)
        {
            m_bgBattlegroundQueueID[i].bgQueueTypeId = BATTLEGROUND_QUEUE_NONE;
            m_bgBattlegroundQueueID[i].invitedToInstance = 0;
            return;
        }
    }
}

void Player::SetInviteForBattlegroundQueueType(BattlegroundQueueTypeId bgQueueTypeId, uint32 instanceId)
{
    for (uint8 i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            m_bgBattlegroundQueueID[i].invitedToInstance = instanceId;
}

bool Player::IsInvitedForBattlegroundInstance(uint32 instanceId) const
{
    for (uint8 i=0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].invitedToInstance == instanceId)
            return true;
    return false;
}

bool Player::InArena() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->IsArena())
        return false;

    return true;
}

bool Player::GetBGAccessByLevel(BattlegroundTypeId bgTypeId) const
{
    // get a template bg instead of running one
    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
    if (!bg)
        return false;

    // limit check leel to dbc compatible level range
    uint32 level = getLevel();
    if (level > DEFAULT_MAX_LEVEL)
        level = DEFAULT_MAX_LEVEL;

    if (level < bg->GetMinLevel() || level > bg->GetMaxLevel())
        return false;

    return true;
}

float Player::GetReputationPriceDiscount(Creature const* creature) const
{
    FactionTemplateEntry const* vendor_faction = creature->GetFactionTemplateEntry();
    if (!vendor_faction || !vendor_faction->faction)
        return 1.0f;

    ReputationRank rank = GetReputationRank(vendor_faction->faction);
    if (rank <= REP_NEUTRAL)
        return 1.0f;

    return 1.0f - 0.05f* (rank - REP_NEUTRAL);
}

bool Player::IsSpellFitByClassAndRace(uint32 spell_id) const
{
    uint32 racemask  = getRaceMask();
    uint32 classmask = getClassMask();

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo)
        return false;

    if (spellInfo->AttributesEx7 & SPELL_ATTR7_HORDE_ONLY && racemask & RACEMASK_ALLIANCE)
        return false;

    if (spellInfo->AttributesEx7 & SPELL_ATTR7_ALLIANCE_ONLY && racemask & RACEMASK_HORDE)
        return false;

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);
    if (bounds.first == bounds.second)
        return true;

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        // skip wrong race skills
        if (_spell_idx->second->racemask && (_spell_idx->second->racemask & racemask) == 0)
            continue;

        // skip wrong class skills
        if (_spell_idx->second->classmask && (_spell_idx->second->classmask & classmask) == 0)
            continue;

        return true;
    }

    return false;
}

bool Player::HasQuestForGO(int32 goId) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questId = GetQuestSlotQuestId(i);
        if (questId == 0)
            continue;

        QuestStatusMap::const_iterator qs_itr = m_QuestStatus.find(questId);
        if (qs_itr == m_QuestStatus.end())
            continue;

        QuestStatusData const& qs = qs_itr->second;
        if (qs.Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qInfo = sObjectMgr->GetQuestTemplate(questId);
            if (!qInfo)
                continue;

            if (GetGroup() && GetGroup()->isRaidGroup() && !qInfo->IsAllowedInRaid(GetMap()->GetDifficulty()))
                continue;

            if (!qInfo->GetQuestObjectiveCountType(QUEST_OBJECTIVE_TYPE_GO))
                continue;

            for (QuestObjectiveSet::const_iterator citr = qInfo->m_questObjectives.begin(); citr != qInfo->m_questObjectives.end(); citr++)
                if ((*citr)->Type == QUEST_OBJECTIVE_TYPE_GO)
                    if (goId == (*citr)->ObjectId && GetQuestObjectiveCounter((*citr)->Id) < uint32((*citr)->Amount))
                        return true;
        }
    }

    return false;
}

void Player::UpdateForQuestWorldObjects()
{
    if (m_clientGUIDs.empty())
        return;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (ClientGUIDs::iterator itr=m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if (IS_GAMEOBJECT_GUID(*itr))
        {
            if (GameObject* obj = HashMapHolder<GameObject>::Find(*itr))
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
        else if (IS_CRE_OR_VEH_GUID(*itr))
        {
            Creature* obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, *itr);
            if (!obj)
                continue;

            // check if this unit requires quest specific flags
            if (!obj->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
                continue;

            SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(obj->GetEntry());
            for (SpellClickInfoContainer::const_iterator _itr = clickPair.first; _itr != clickPair.second; ++_itr)
            {
                //! This code doesn't look right, but it was logically converted to condition system to do the exact
                //! same thing it did before. It definitely needs to be overlooked for intended functionality.
                ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(obj->GetEntry(), _itr->second.spellId);
                bool buildUpdateBlock = false;
                for (ConditionList::const_iterator jtr = conds.begin(); jtr != conds.end() && !buildUpdateBlock; ++jtr)
                    if ((*jtr)->ConditionType == CONDITION_QUESTREWARDED || (*jtr)->ConditionType == CONDITION_QUESTTAKEN)
                        buildUpdateBlock = true;

                if (buildUpdateBlock)
                {
                    obj->BuildCreateUpdateBlockForPlayer(&udata, this);
                    break;
                }
            }
        }
    }
    udata.BuildPacket(&packet);
    GetSession()->SendPacket(&packet);
}

void Player::SetSummonPoint(uint32 mapid, float x, float y, float z)
{
    m_summon_expire = time(NULL) + MAX_PLAYER_SUMMON_DELAY;
    m_summon_mapid = mapid;
    m_summon_x = x;
    m_summon_y = y;
    m_summon_z = z;
}

void Player::SummonIfPossible(bool agree)
{
    if (!agree)
    {
        m_summon_expire = 0;
        return;
    }

    // expire and auto declined
    if (m_summon_expire < time(NULL))
        return;

    // stop taxi flight at summon
    if (IsInFlight())
    {
        GetMotionMaster()->MovementExpired();
        CleanupAfterTaxiFlight();
    }

    // drop flag at summon
    // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
    if (Battleground* bg = GetBattleground())
        bg->EventPlayerDroppedFlag(this);

    m_summon_expire = 0;

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ACCEPTED_SUMMONINGS, 1);

    TeleportTo(m_summon_mapid, m_summon_x, m_summon_y, m_summon_z, GetOrientation());
}

void Player::RemoveItemDurations(Item* item)
{
    for (ItemDurationList::iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
    {
        if (*itr == item)
        {
            m_itemDuration.erase(itr);
            break;
        }
    }
}

void Player::AddItemDurations(Item* item)
{
    if (item->GetUInt32Value(ITEM_FIELD_EXPIRATION))
    {
        m_itemDuration.push_back(item);
        item->SendTimeUpdate(this);
    }
}

void Player::AutoUnequipOffhandIfNeed(bool force /*= false*/)
{
    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!offItem)
        return;

     // unequip offhand weapon if player doesn't have dual wield anymore
     if (!CanDualWield() && (offItem->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND || offItem->GetTemplate()->InventoryType == INVTYPE_WEAPON))
          force = true;

    // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
    if (!force && (CanTitanGrip() || (offItem->GetTemplate()->InventoryType != INVTYPE_2HWEAPON && !IsTwoHandUsed())))
        return;

    ItemPosCountVec off_dest;
    uint8 off_msg = CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false);
    if (off_msg == EQUIP_ERR_OK)
    {
        RemoveItem(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        StoreItem(off_dest, offItem, true);
    }
    else
    {
        MoveItemFromInventory(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        offItem->DeleteFromInventoryDB(trans);                   // deletes item from character's inventory
        offItem->SaveToDB(trans);                                // recursive and not have transaction guard into self, item not in inventory and can be save standalone

        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
        MailDraft(subject, "There were problems with equipping one or several items").AddItem(offItem).SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);

        CharacterDatabase.CommitTransaction(trans);
    }
}

OutdoorPvP* Player::GetOutdoorPvP() const
{
    return sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetZoneId());
}

bool Player::HasItemFitToSpellRequirements(SpellInfo const* spellInfo, Item const* ignoreItem) const
{
    if (spellInfo->EquippedItemClass < 0)
        return true;

    // scan other equipped items for same requirements (mostly 2 daggers/etc)
    // for optimize check 2 used cases only
    switch (spellInfo->EquippedItemClass)
    {
        case ITEM_CLASS_WEAPON:
        {
            for (uint8 i = EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;
            break;
        }
        case ITEM_CLASS_ARMOR:
        {
            // tabard not have dependent spells
            for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_MAINHAND; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;

            // shields can be equipped to offhand slot
            if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;

            // ranged slot can have some armor subclasses
            /*if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
                if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                    return true;*/

            break;
        }
        default:
            TC_LOG_ERROR("entities.player", "HasItemFitToSpellRequirements: Not handled spell requirement for item class %u", spellInfo->EquippedItemClass);
            break;
    }

    return false;
}

bool Player::CanNoReagentCast(SpellInfo const* spellInfo) const
{
    // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
    if (spellInfo->AttributesEx5 & SPELL_ATTR5_NO_REAGENT_WHILE_PREP &&
        HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION))
        return true;

    // Check no reagent use mask
    flag128 noReagentMask;
    noReagentMask[0] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK);
    noReagentMask[1] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+1);
    noReagentMask[2] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+2);
    // NEED FLAG CONFIRMATION
    noReagentMask[3] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK+3);
    if (spellInfo->SpellFamilyFlags  & noReagentMask)
        return true;

    return false;
}

void Player::RemoveItemDependentAurasAndCasts(Item* pItem)
{
    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* aura = itr->second;

        // skip passive (passive item dependent spells work in another way) and not self applied auras
        SpellInfo const* spellInfo = aura->GetSpellInfo();
        if (aura->IsPassive() ||  aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        // skip if not item dependent or have alternative item
        if (HasItemFitToSpellRequirements(spellInfo, pItem))
        {
            ++itr;
            continue;
        }

        // no alt item, remove aura, restart check
        RemoveOwnedAura(itr);
    }

    // currently casted spells can be dependent from item
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
            if (spell->getState() != SPELL_STATE_DELAYED && !HasItemFitToSpellRequirements(spell->m_spellInfo, pItem))
                InterruptSpell(CurrentSpellTypes(i));
}

uint32 Player::GetResurrectionSpellId()
{
    // search priceless resurrection possibilities
    uint32 prio = 0;
    uint32 spellId = 0;
    AuraEffectList const& dummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
    for (AuraEffectList::const_iterator itr = dummyAuras.begin(); itr != dummyAuras.end(); ++itr)
    {
        // Soulstone Resurrection                           // prio: 3 (max, non death persistent)
        if (prio < 2 && (*itr)->GetSpellInfo()->SpellVisual[0] == 99 && (*itr)->GetSpellInfo()->SpellIconID == 92)
        {
            switch ((*itr)->GetId())
            {
                case 20707: spellId =  3026; break;        // rank 1
                case 20762: spellId = 20758; break;        // rank 2
                case 20763: spellId = 20759; break;        // rank 3
                case 20764: spellId = 20760; break;        // rank 4
                case 20765: spellId = 20761; break;        // rank 5
                case 27239: spellId = 27240; break;        // rank 6
                case 47883: spellId = 47882; break;        // rank 7
                default:
                    TC_LOG_ERROR("entities.player", "Unhandled spell %u: S.Resurrection", (*itr)->GetId());
                    continue;
            }

            prio = 3;
        }
        // Twisting Nether                                  // prio: 2 (max)
        else if ((*itr)->GetId() == 23701 && roll_chance_i(10))
        {
            prio = 2;
            spellId = 23700;
        }
    }

    if (prio < 1 && HasAura(148623)) // Cauterizing Core
    {
        spellId = 148624;
        prio = 1;
    }

    // Reincarnation (passive spell)  // prio: 1                  // Glyph of Renewed Life
    if (prio < 1 && HasSpell(20608) && !HasSpellCooldown(21169))
        spellId = 21169;

    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
        if (spellInfo->HasAttribute(SPELL_ATTR8_BATTLE_RESURRECTION))
            if (InstanceScript* instance = GetInstanceScript())
                if (!instance->CanUseResurrection())
                    return 0;

    return spellId;
}

// Used in triggers for check "Only to targets that grant experience or honor" req
bool Player::IsHonorOrXPTarget(Unit const* victim)
{
    uint8 v_level = victim->getLevel();
    uint8 k_grey  = Trinity::XP::GetGrayLevel(getLevel());

    // Victim level less gray level
    if (v_level <= k_grey)
        return false;

    if (Creature const* const creature = victim->ToCreature())
    {
        if (creature->IsTotem() ||
            (creature->GetAffectingPlayer() && !creature->IsPet()) || // Procs must work from killing pets but not for other summons
            creature->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL)
                return false;
    }
    return true;
}

bool Player::GetsRecruitAFriendBonus(bool forXP)
{
    bool recruitAFriend = false;
    if (getLevel() <= sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL) || !forXP)
    {
        if (Group* group = this->GetGroup())
        {
            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
            {
                Player* player = itr->GetSource();
                if (!player)
                    continue;

                if (!player->IsAtRecruitAFriendDistance(this))
                    continue;                               // member (alive or dead) or his corpse at req. distance

                if (forXP)
                {
                    // level must be allowed to get RaF bonus
                    if (player->getLevel() > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
                        continue;

                    // level difference must be small enough to get RaF bonus, UNLESS we are lower level
                    if (player->getLevel() < getLevel())
                        if (uint8(getLevel() - player->getLevel()) > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE))
                            continue;
                }

                bool ARecruitedB = (player->GetSession()->GetRecruiterId() == GetSession()->GetAccountId());
                bool BRecruitedA = (GetSession()->GetRecruiterId() == player->GetSession()->GetAccountId());
                if (ARecruitedB || BRecruitedA)
                {
                    recruitAFriend = true;
                    break;
                }
            }
        }
    }
    return recruitAFriend;
}

void Player::RewardPersonalLootAndCurrency(Unit* victim, uint32 lootId)
{
    if (!lootId)
        lootId = victim->GetEntry();

    Difficulty difficulty = victim->GetMap()->GetDifficulty();
    PersonalLoot loot{ lootId };
    CreatureLootCurrencySet const* currency = sLootMgr->GetCreatureLootCurrency(lootId);
    BonusLootTemplate const* bonusLoot = sLootMgr->GetBonusLoot(lootId);
    bool aoe = false;
    if (bonusLoot)
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(bonusLoot->Spell))
            aoe = spellInfo->Effects[EFFECT_0].TargetA.GetTarget() == TARGET_UNIT_RECIPIENT_RAID;

    auto process = [&](Player* player)
    {
        // LFR, flex and world bosses. Obviously world bosses couldn't be encountered in LFR and flex. So, whatever.
        bool personal = difficulty == RAID_DIFFICULTY_25MAN_LFR || difficulty == RAID_DIFFICULTY_1025MAN_FLEX || difficulty == REGULAR_DIFFICULTY;
        bool lockout = player->HasLootLockout(LootLockoutType::PersonalLoot, lootId, difficulty);
        if (personal && !lockout)
        {
            if (loot)
                loot.Reward(player);
            player->AddLootLockout(LootLockoutType::PersonalLoot, lootId, difficulty, false);
        }
        // Save difficulty to the effect value becasue corpse can be removed from the world
        if (bonusLoot && !aoe && !player->HasLootLockout(LootLockoutType::BonusLoot, lootId, difficulty) && player->HasCurrency(bonusLoot->Currency, 1))
            victim->CastCustomSpell(bonusLoot->Spell, SPELLVALUE_BASE_POINT0, difficulty, player, true);

        if (difficulty != RAID_DIFFICULTY_25MAN_LFR && currency && (difficulty != RAID_DIFFICULTY_1025MAN_FLEX || !lockout))
        {
            for (auto&& it : *currency)
            {
                if (!it.Lootmode || (it.Lootmode & (1 << difficulty)))
                {
                    player->ModifyCurrency(it.Currency, it.Count);

                    if (it.Currency == CURRENCY_TYPE_VALOR_POINTS || it.Currency == CURRENCY_TYPE_LESSER_CHARM_OF_GOOD_FORTUNE)
                        player->SendDisplayToast(nullptr, it.Currency, it.Count, TOAST_TYPE_CURRENCY, TOAST_DISPLAY_TYPE_CURRENCY);
                }
            }
        }
        sLootMgr->RewardLegendaryQuestLoot(player, lootId);
    };

    if (loot || bonusLoot || currency)
    {
        if (aoe)
            victim->CastSpell(victim, bonusLoot->Spell, true);

        if (!victim->ToCreature()->HasNormalLootMode())
        {
            for (auto&& guid : victim->ToCreature()->GetLootRecipients())
                if (Player* player = ObjectAccessor::GetPlayer(*victim, guid))
                    if (player->IsAtGroupRewardDistance(victim) && player->IsInMap(victim))
                        process(player);
        }
        else if (Group* group = GetGroup())
        {
            for (auto&& member : *group)
                if (member->IsAtGroupRewardDistance(victim) && member->IsInMap(victim))
                    process(member);
        }
        else
            process(this);
    }
}

void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
{
    if (Creature* creature = victim->ToCreature())
        if (sLootMgr->IsRewardOnKill(creature->GetEntry()))
            RewardPersonalLootAndCurrency(creature, creature->GetEntry());

    KillRewarder(this, victim, isBattleGround).Reward();
}

void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource, bool noGuid)
{
    if (!pRewardSource)
        return;
    uint64 creature_guid = (pRewardSource->GetTypeId() == TYPEID_UNIT) ? pRewardSource->GetGUID() : uint64(0);

    // prepare data for near group iteration
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* player = itr->GetSource();
            if (!player)
                continue;

            if (!player->IsAtGroupRewardDistance(pRewardSource))
                continue;                               // member (alive or dead) or his corpse at req. distance

            // quest objectives updated only for alive group member or dead but with not released body
            if (player->IsAlive()|| !player->GetCorpse())
                player->KilledMonsterCredit(creature_id, noGuid ? 0 : creature_guid);
        }
    }
    else                                                    // if (!group)
        KilledMonsterCredit(creature_id, noGuid ? 0 : creature_guid);
}

bool Player::IsAtGroupRewardDistance(WorldObject const* pRewardSource) const
{
    if (!pRewardSource)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || IsAlive())
        player = this;

    if (player->GetMapId() != pRewardSource->GetMapId() || player->GetInstanceId() != pRewardSource->GetInstanceId())
        return false;

    // When we're in dungeon - only allow receive reward if the player is alive and in the same map, disregarding the distance
    if (pRewardSource->GetInstanceId() && player->IsInMap(pRewardSource))
        return player == this;

    return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE);
}

bool Player::IsAtRecruitAFriendDistance(WorldObject const* pOther) const
{
    if (!pOther)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || IsAlive())
        player = this;

    if (player->GetMapId() != pOther->GetMapId() || player->GetInstanceId() != pOther->GetInstanceId())
        return false;

    return pOther->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE);
}

void Player::ResurrectUsingRequestData()
{
    /// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
    float x, y, z, o;
    _resurrectionData->Location.GetPosition(x, y, z, o);
    TeleportTo(_resurrectionData->Location.GetMapId(), x, y, z, o);

    if (IsBeingTeleported())
    {
        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
        return;
    }

    ResurrectPlayer(0.0f, false);

    uint32 health = _resurrectionData->Health;
    AddPct(health, GetResurrectHealthBonus());
    SetHealth(health);

    if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
        SetPower(POWER_MANA, _resurrectionData->Mana);
    else
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

    SetPower(POWER_RAGE, 0);
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    SetPower(POWER_FOCUS, GetMaxPower(POWER_FOCUS));
    SetPower(POWER_ECLIPSE, 0);

    if (uint32 aura = _resurrectionData->Aura)
        CastSpell(this, aura, true, nullptr, nullptr, _resurrectionData->GUID);

    if (IS_PLAYER_GUID(_resurrectionData->GUID))
        RestoreCombatWithPlayer(ObjectAccessor::GetPlayer(*this, _resurrectionData->GUID));

    SpawnCorpseBones();
}

void Player::SetClientControl(Unit* target, uint8 allowMove)
{
    ObjectGuid guid = target->GetGUID();

    WorldPacket data(SMSG_CLIENT_CONTROL_UPDATE, 9 + 1);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[7]);
    data.WriteBit(allowMove);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[6]);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[4]);

    data.WriteByteSeq(guid[1]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[0]);
    GetSession()->SendPacket(&data);

    if (target == this && allowMove == 1)
        SetMover(this);
    if (!allowMove)
        m_clientMoverGuid = 0;
}

void Player::SetMover(Unit* target)
{
    m_mover->m_movedPlayer = NULL;
    m_mover = target;
    m_mover->m_movedPlayer = this;
    m_clientMoverGuid = target->GetGUID();

    ObjectGuid guid = target->GetGUID();

    WorldPacket data(SMSG_MOVE_SET_ACTIVE_MOVER, 9);
    data.WriteBit(guid[5]);
    data.WriteBit(guid[1]);
    data.WriteBit(guid[4]);
    data.WriteBit(guid[2]);
    data.WriteBit(guid[3]);
    data.WriteBit(guid[7]);
    data.WriteBit(guid[0]);
    data.WriteBit(guid[6]);

    data.WriteByteSeq(guid[4]);
    data.WriteByteSeq(guid[6]);
    data.WriteByteSeq(guid[2]);
    data.WriteByteSeq(guid[0]);
    data.WriteByteSeq(guid[3]);
    data.WriteByteSeq(guid[7]);
    data.WriteByteSeq(guid[5]);
    data.WriteByteSeq(guid[1]);

    SendDirectMessage(&data);
}

void Player::ShowNeutralPlayerFactionSelectUI()
{
    WorldPacket data(SMSG_SHOW_NEURTRAL_PLAYER_FACTION_SELECT_UI);
    GetSession()->SendPacket(&data);
}

void Player::UpdateZoneDependentAuras(uint32 newZone)
{
    // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newZone);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);
}

void Player::UpdateAreaDependentAuras(uint32 newArea)
{
    // remove auras from spells with area limitations
    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
    {
        // use m_zoneUpdateId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneUpdateId up-to-date
        if (iter->second->GetSpellInfo()->CheckLocation(GetMapId(), m_zoneUpdateId, newArea, this) != SPELL_CAST_OK)
            RemoveOwnedAura(iter);
        else
            ++iter;
    }

    // some auras applied at subzone enter
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newArea);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, m_zoneUpdateId, newArea))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);

    if (newArea == 4273 && GetVehicleCreatureBase() && GetPositionX() > 400) // Ulduar
    {
        switch (GetVehicleBase()->GetEntry())
        {
            case 33062:
            case 33109:
            case 33060:
                GetVehicleCreatureBase()->DespawnOrUnsummon();
                break;
        }
    }
}

uint32 Player::GetCorpseReclaimDelay(bool pvp) const
{
    if (pvp)
    {
        if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP))
            return copseReclaimDelay[0];
    }
    else if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE))
        return 0;

    time_t now = time(NULL);
    // 0..2 full period
    // should be ceil(x)-1 but not floor(x)
    uint64 count = (now < m_deathExpireTime - 1) ? (m_deathExpireTime - 1 - now)/DEATH_EXPIRE_STEP : 0;
    return copseReclaimDelay[count];
}

void Player::UpdateCorpseReclaimDelay()
{
    bool pvp = m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH;

    if ((pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
        (!pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        return;

    time_t now = time(NULL);
    if (now < m_deathExpireTime)
    {
        // full and partly periods 1..3
        uint64 count = (m_deathExpireTime - now)/DEATH_EXPIRE_STEP +1;
        if (count < MAX_DEATH_COUNT)
            m_deathExpireTime = now+(count+1)*DEATH_EXPIRE_STEP;
        else
            m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP;
    }
    else
        m_deathExpireTime = now+DEATH_EXPIRE_STEP;
}

void Player::SendCorpseReclaimDelay(bool load)
{
    Corpse* corpse = GetCorpse();
    if (load && !corpse)
        return;

    bool pvp;
    if (corpse)
        pvp = (corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
    else
        pvp = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH);

    time_t delay;
    if (load)
    {
        if (corpse->GetGhostTime() > m_deathExpireTime)
            return;

        uint64 count;
        if ((pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
           (!pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        {
            count = (m_deathExpireTime-corpse->GetGhostTime())/DEATH_EXPIRE_STEP;
            if (count >= MAX_DEATH_COUNT)
                count = MAX_DEATH_COUNT-1;
        }
        else
            count=0;

        time_t expected_time = corpse->GetGhostTime()+copseReclaimDelay[count];

        time_t now = time(NULL);
        if (now >= expected_time)
            return;

        delay = expected_time-now;
    }
    else
        delay = GetCorpseReclaimDelay(pvp);

    if (!delay)
        return;

    //! corpse reclaim delay 30 * 1000ms or longer at often deaths
    WorldPacket data(SMSG_CORPSE_RECLAIM_DELAY, 4);
    data.WriteBit(delay == 0);

    if (delay)
        data << uint32(delay * IN_MILLISECONDS);

    GetSession()->SendPacket(&data);
}

Player* Player::GetNextRandomRaidMember(float radius)
{
    Group* group = GetGroup();
    if (!group)
        return NULL;

    std::vector<Player*> nearMembers;
    nearMembers.reserve(group->GetMembersCount());

    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
    {
        Player* Target = itr->GetSource();

        // IsHostileTo check duel and controlled by enemy
        if (Target && Target != this && IsWithinDistInMap(Target, radius) &&
            !Target->HasInvisibilityAura() && !IsHostileTo(Target))
            nearMembers.push_back(Target);
    }

    if (nearMembers.empty())
        return NULL;

    uint32 randTarget = urand(0, nearMembers.size()-1);
    return nearMembers[randTarget];
}

PartyResult Player::CanUninviteFromGroup(std::string const* membername, uint64* memberguid, uint32& val) const
{
    Group const* grp = GetGroup();
    if (!grp)
        return ERR_NOT_IN_GROUP;

    if (grp->isLFGGroup())
    {
        if (grp->IsFlex() && grp->IsLeader(GetGUID()))
            return ERR_PARTY_RESULT_OK;

        if (grp->IsFlex() && !grp->IsLeader(GetGUID()))
            return ERR_NOT_LEADER;

        uint64 gguid = grp->GetGUID();
        if (!sLFGMgr->GetKicksLeft(gguid))
            return ERR_PARTY_LFG_BOOT_LIMIT;

        lfg::LfgState state = sLFGMgr->GetActiveState(gguid);
        if (state == lfg::LFG_STATE_BOOT)
            return ERR_PARTY_LFG_BOOT_IN_PROGRESS;

        if (grp->GetMembersCount() <= sLFGMgr->GetBootVotesNeeded(gguid))
            return ERR_PARTY_LFG_BOOT_TOO_FEW_PLAYERS;

        if (state == lfg::LFG_STATE_FINISHED_DUNGEON)
            return ERR_PARTY_LFG_BOOT_DUNGEON_COMPLETE;

        if (state != lfg::LFG_STATE_DUNGEON)        // Disallow boot while in a queue. Causes bugs
            return ERR_PARTY_LFG_BOOT_IN_COMBAT;    // Can't find a better error...

        if (grp->isRollLootActive())
            return ERR_PARTY_LFG_BOOT_LOOT_ROLLS;

        /// @todo Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
        for (GroupReference const* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
            if (itr->GetSource() && itr->GetSource()->IsInCombat())
                return ERR_PARTY_LFG_BOOT_IN_COMBAT;

        if (uint64 guid = memberguid ? *memberguid : membername ? grp->GetMemberGUID(*membername) : 0)
        {
            uint32 timeLeft;
            PartyResult lfgResult = sLFGMgr->CanBoot(GetGUID(), guid, timeLeft);
            if (lfgResult != ERR_PARTY_RESULT_OK)
            {
                val = uint32(ceil(timeLeft / 1000.0));
                return lfgResult;
            }
        }
    }
    else
    {
        if (!grp->IsLeader(GetGUID()) && !grp->IsAssistant(GetGUID()))
            return ERR_NOT_LEADER;

        if (InBattleground())
            return ERR_INVITE_RESTRICTED;
    }

    return ERR_PARTY_RESULT_OK;
}

bool Player::IsUsingLfg(bool inProgressOnly)
{
    uint32 queueId = sLFGMgr->GetActiveQueueId(GetGUID());
    if (!queueId)
        return false;
    if (!inProgressOnly)
        return true;
    return sLFGMgr->GetOldState(GetGUID(), queueId) == lfg::LFG_STATE_DUNGEON;
}

bool Player::inRandomLfgDungeon()
{
    if (sLFGMgr->IsSelectedRandomLfgDungeon(GetGUID()))
    {
        Map const* map = GetMap();
        return sLFGMgr->InLfgDungeonMap(GetGUID(), map->GetId(), map->GetDifficulty());
    }

    return false;
}

void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
{
    LiquidData liquid_status;
    ZLiquidStatus res = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
    if (!res)
    {
        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWARER_INDARKWATER);
        if (_lastLiquid && _lastLiquid->SpellId)
            RemoveAurasDueToSpell(_lastLiquid->SpellId);

        _lastLiquid = NULL;
        return;
    }

    if (uint32 liqEntry = liquid_status.entry)
    {
        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
        if (_lastLiquid && _lastLiquid->SpellId && _lastLiquid->Id != liqEntry)
            RemoveAurasDueToSpell(_lastLiquid->SpellId);

        if (liquid && liquid->SpellId)
        {
            if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
            {
                if (!HasAura(liquid->SpellId))
                    CastSpell(this, liquid->SpellId, true);
            }
            else
                RemoveAurasDueToSpell(liquid->SpellId);
        }

        _lastLiquid = liquid;
    }
    else if (_lastLiquid && _lastLiquid->SpellId)
    {
        RemoveAurasDueToSpell(_lastLiquid->SpellId);
        _lastLiquid = NULL;
    }


    // All liquids type - check under water position
    if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
    {
        if (res & LIQUID_MAP_UNDER_WATER)
            m_MirrorTimerFlags |= UNDERWATER_INWATER;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
    }

    // Allow travel in dark water on taxi or transport
    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !IsInFlight() && !GetTransport())
        m_MirrorTimerFlags |= UNDERWARER_INDARKWATER;
    else
        m_MirrorTimerFlags &= ~UNDERWARER_INDARKWATER;

    // in lava check, anywhere in lava level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
    }
    // in slime check, anywhere in slime level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
    {
        if (res & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
    }
}

void Player::SetCanParry(bool value)
{
    if (m_canParry == value)
        return;

    m_canParry = value;
    UpdateParryPercentage();
}

void Player::SetCanBlock(bool value)
{
    if (m_canBlock == value)
        return;

    m_canBlock = value;
    UpdateBlockPercentage();
}

bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
{
    for (ItemPosCountVec::const_iterator itr = vec.begin(); itr != vec.end(); ++itr)
        if (itr->pos == pos)
            return true;
    return false;
}

void Player::StopCastingBindSight()
{
    if (WorldObject* target = GetViewpoint())
    {
        if (target->isType(TYPEMASK_UNIT))
        {
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_BIND_SIGHT, GetGUID());
            ((Unit*)target)->RemoveAurasByType(SPELL_AURA_MOD_POSSESS, GetGUID());
        }
    }
}

void Player::SetViewpoint(WorldObject* target, bool apply)
{
    if (apply)
    {
        TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName().c_str(), target->GetEntry(), target->GetTypeId());

        if (!AddUInt64Value(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            TC_LOG_FATAL("entities.player", "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName().c_str());
            return;
        }

        // farsight dynobj or puppet may be very far away
        UpdateVisibilityOf(target);

        if (target->isType(TYPEMASK_UNIT) && !IsOnVehicle((Unit*)target))
            ((Unit*)target)->AddPlayerToVision(this);
    }
    else
    {
        TC_LOG_DEBUG("maps", "Player::CreateViewpoint: Player %s remove seer", GetName().c_str());

        if (!RemoveUInt64Value(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            TC_LOG_FATAL("entities.player", "Player::CreateViewpoint: Player %s cannot remove current viewpoint!", GetName().c_str());
            return;
        }

        if (target->isType(TYPEMASK_UNIT) && !IsOnVehicle((Unit*)target))
            ((Unit*)target)->RemovePlayerFromVision(this);

        //must immediately set seer back otherwise may crash
        m_seer = this;

        //WorldPacket data(SMSG_CLEAR_FAR_SIGHT_IMMEDIATE, 0);
        //GetSession()->SendPacket(&data);
    }
}

WorldObject* Player::GetViewpoint() const
{
    if (uint64 guid = GetUInt64Value(PLAYER_FIELD_FARSIGHT_OBJECT))
        return (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_SEER);
    return NULL;
}

bool Player::CanUseBattlegroundObject(GameObject* gameobject)
{
    // It is possible to call this method with a null pointer, only skipping faction check.
    if (gameobject)
    {
        FactionTemplateEntry const* playerFaction = GetFactionTemplateEntry();
        FactionTemplateEntry const* faction = sFactionTemplateStore.LookupEntry(gameobject->GetUInt32Value(GAMEOBJECT_FIELD_FACTION_TEMPLATE));

        if (playerFaction && faction && !playerFaction->IsFriendlyTo(*faction))
            return false;
    }

    // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
    // Note: Mount, stealth and invisibility will be removed when used
    return (!isTotalImmune() &&                            // Damage immune
            GetTotalAuraModifier(SPELL_AURA_DEFLECT_SPELLS) < 100 && // Deterence
            !HasAura(SPELL_RECENTLY_DROPPED_FLAG) &&       // Still has recently held flag debuff
            IsAlive());                                    // Alive
}

bool Player::CanCaptureTowerPoint()
{
    return (!HasStealthAura() &&                            // not stealthed
            !HasInvisibilityAura() &&                       // not invisible
            IsAlive());                                     // live player
}

uint32 Player::GetBarberShopCost(uint8 newhairstyle, uint8 newhaircolor, uint8 newfacialhair, BarberShopStyleEntry const* newSkin)
{
    uint8 level = getLevel();

    if (level > GT_MAX_LEVEL)
        level = GT_MAX_LEVEL;                               // max level in this dbc

    uint8 hairstyle = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, 2);
    uint8 haircolor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, 3);
    uint8 facialhair = GetByteValue(PLAYER_FIELD_REST_STATE, 0);
    uint8 skincolor = GetByteValue(PLAYER_FIELD_HAIR_COLOR_ID, 0);

    if ((hairstyle == newhairstyle) && (haircolor == newhaircolor) && (facialhair == newfacialhair) && (!newSkin || (newSkin->hair_id == skincolor)))
        return 0;

    GtBarberShopCostBaseEntry const* bsc = sGtBarberShopCostBaseStore.LookupEntry(level - 1);

    if (!bsc)                                                // shouldn't happen
        return 0xFFFFFFFF;

    float cost = 0;

    if (hairstyle != newhairstyle)
        cost += bsc->cost;                                  // full price

    if ((haircolor != newhaircolor) && (hairstyle == newhairstyle))
        cost += bsc->cost * 0.5f;                           // +1/2 of price

    if (facialhair != newfacialhair)
        cost += bsc->cost * 0.75f;                          // +3/4 of price

    if (newSkin && skincolor != newSkin->hair_id)
        cost += bsc->cost * 0.75f;                          // +5/6 of price

    return uint32(cost);
}

void Player::InitGlyphsForLevel()
{
    uint32 slot = 0;
    uint32 const glyphsOrder[6] = { 22, 21, 23, 24, 25, 26 };

    for (uint32 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
        if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(glyphsOrder[i]))
            SetGlyphSlot(slot++, gs->Id);

    uint8 level = getLevel();
    uint32 slotMask = 0;

    if (level >= 25)
        slotMask |= 0x01 | 0x02;
    if (level >= 50)
        slotMask |= 0x04 | 0x08;
    if (level >= 75)
        slotMask |= 0x10 | 0x20;

    if (level >= 25)
        SetUInt32Value(PLAYER_FIELD_GLYPH_SLOTS_ENABLED, slotMask);
}

void Player::SetGlyph(uint8 slot, uint32 glyph)
{
    UnapplyGlyph(slot);
    _talentMgr->SpecInfo[GetActiveSpec()].Glyphs[slot] = glyph;
    if (glyph)
        ApplyGlyph(slot, glyph);
}

void Player::ApplyGlyph(uint8 slot, uint32 glyph)
{
    if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
    {
        LearnSpell(gp->SpellId, true);
        SetUInt32Value(PLAYER_FIELD_GLYPHS + slot, glyph);
    }
}

void Player::UnapplyGlyph(uint8 slot)
{
    uint32 old = GetGlyph(GetActiveSpec(), slot);
    if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(old))
        RemoveSpell(gp->SpellId);
    SetUInt32Value(PLAYER_FIELD_GLYPHS + slot, 0);
}

bool Player::isTotalImmune()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    uint32 immuneMask = 0;
    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        immuneMask |= (*itr)->GetMiscValue();
        if (immuneMask & SPELL_SCHOOL_MASK_ALL)            // total immunity
            return true;
    }
    return false;
}

bool Player::HasTitle(uint32 bitIndex) const
{
    if (bitIndex > MAX_TITLE_INDEX)
        return false;

    uint32 fieldIndexOffset = bitIndex / 32;
    uint32 flag = 1 << (bitIndex % 32);
    return HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
}

void Player::SetTitle(CharTitlesEntry const* title, bool lost)
{
    uint32 fieldIndexOffset = title->bit_index / 32;
    uint32 flag = 1 << (title->bit_index % 32);

    if (lost)
    {
        if (!HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        RemoveFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
        GetSession()->SendTitleLost(title->bit_index);

        if (GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE) == title->bit_index)
            SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        SetFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
        GetSession()->SendTitleEarned(title->bit_index);
    }

}

bool Player::isTotalImmunity()
{
    AuraEffectList const& immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);

    for (AuraEffectList::const_iterator itr = immune.begin(); itr != immune.end(); ++itr)
    {
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_ALL) !=0)   // total immunity
        {
            return true;
        }
        if (((*itr)->GetMiscValue() & SPELL_SCHOOL_MASK_NORMAL) !=0)   // physical damage immunity
        {
            for (AuraEffectList::const_iterator i = immune.begin(); i != immune.end(); ++i)
            {
                if (((*i)->GetMiscValue() & SPELL_SCHOOL_MASK_MAGIC) !=0)   // magic immunity
                {
                    return true;
                }
            }
        }
    }
    return false;
}

void Player::ConsumeRune(uint8 index)
{
    auto& thisRune = m_runes->runes[index];
    auto& otherRune = m_runes->runes[GetOtherRune(index)];

    ASSERT(thisRune.State == RuneState::Ready);
    thisRune.Readiness = 0;
    if (otherRune.State == RuneState::NormalCooldown)
        thisRune.State = RuneState::FullyDepleted;
    else
        thisRune.State = RuneState::NormalCooldown;
    m_runes->SetRuneState(index, false);
}

void Player::ActivateRune(uint8 index)
{
    auto& thisRune = m_runes->runes[index];
    auto& otherRune = m_runes->runes[GetOtherRune(index)];

    thisRune.Readiness = RUNE_READINESS_FULL;
    thisRune.State = RuneState::Ready;
    if (otherRune.State == RuneState::FullyDepleted)
        otherRune.State = RuneState::NormalCooldown;

    m_runes->SetRuneState(index, true);
}

void Player::SetRuneConvertSpell(uint8 index, uint32 spellId)
{
    m_runes->runes[index].SpellId = spellId;
    if (!spellId)
        m_runes->runes[index].Permanently = false;
}

void Player::RemoveRunesBySpell(uint32 spellid)
{
    for (uint8 i = 0; i < MAX_RUNES; ++i)
    {
        if (m_runes->runes[i].SpellId == spellid)
        {
            ConvertRune(i, GetBaseRune(i));
            SetRuneConvertSpell(i, 0);
        }
    }
}

void Player::RestoreBaseRune(uint8 index)
{
    ConvertRune(index, GetBaseRune(index));
    SetRuneConvertSpell(index, 0);
}

void Player::ConvertRune(uint8 index, RuneType newType)
{
    SetCurrentRune(index, newType);

    WorldPacket data(SMSG_CONVERT_RUNE, 2);
    data << uint8(newType);
    data << uint8(index);
    GetSession()->SendPacket(&data);
}

void Player::ResyncRunes(uint8 count)
{
    WorldPacket data(SMSG_RESYNC_RUNES, 4 + count * 2);
    data.WriteBits(count, 23);
    data.FlushBits();

    for (uint32 i = 0; i < count; ++i)
    {
        data << uint8(GetRune(i).Readiness * 255.f / RUNE_READINESS_FULL);
        data << uint8(GetCurrentRune(i));                   // rune type
    }

    GetSession()->SendPacket(&data);
}

void Player::AddRunePower(uint8 index)
{
    WorldPacket data(SMSG_ADD_RUNE_POWER, 4);
    data << uint32(1 << index);                             // mask (0x00-0x3F probably)
    GetSession()->SendPacket(&data);
}

static RuneType runeSlotTypes[MAX_RUNES] =
{
    /*0*/ RUNE_BLOOD,
    /*1*/ RUNE_BLOOD,
    /*2*/ RUNE_UNHOLY,
    /*3*/ RUNE_UNHOLY,
    /*4*/ RUNE_FROST,
    /*5*/ RUNE_FROST
};

void Player::InitRunes()
{
    if (getClass() != CLASS_DEATH_KNIGHT)
        return;

    m_runes = new Runes;

    m_runes->runeState = 0;
    m_runes->lastUsedRuneMask = 0;

    for (uint8 i = 0; i < MAX_RUNES; ++i)
    {
        SetBaseRune(i, runeSlotTypes[i]);                              // init base types
        SetCurrentRune(i, runeSlotTypes[i]);                           // init current types
        ActivateRune(i);                                               // reset cooldowns
        SetRuneConvertSpell(i, 0);
        m_runes->SetRuneState(i);
    }

    for (uint8 i = 0; i < NUM_RUNE_TYPES; ++i)
        SetFloatValue(PLAYER_FIELD_RUNE_REGEN + i, 0.1f);                  // set a base regen timer equal to 10 sec
}

bool Player::IsBaseRuneSlotsOnCooldown(RuneType runeType) const
{
    for (uint8 i = 0; i < MAX_RUNES; ++i)
        if (GetBaseRune(i) == runeType && !HasRuneCooldown(i))
            return false;

    return true;
}

void Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, ItemPickupSourceType sourceType, uint32 sourceId, bool broadcast, uint32 guildPeckChance)
{
    Loot loot;
    loot.guildPerkChance = guildPeckChance;
    if (&store == &LootTemplates_Disenchant)
        loot.loot_type = LOOT_DISENCHANTING;
    loot.sourceEntry = sourceId;
    loot.FillLoot(nullptr, loot_id, store, this, true);

    uint32 max_slot = loot.GetMaxSlotInLootFor(this);
    for (uint32 i = 0; i < max_slot; ++i)
    {
        LootItem* lootItem = loot.LootItemInSlot(i, this);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(bag, slot, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && slot != NULL_SLOT)
            msg = CanStoreNewItem(bag, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK && bag != NULL_BAG)
            msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, lootItem->itemid, lootItem->count);
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, NULL, NULL, lootItem->itemid);
            continue;
        }

        Item* pItem = StoreNewItem(dest, lootItem->itemid, true, lootItem->randomPropertyId);
        SendNewItem(pItem, lootItem->count, false, false, broadcast);
        sScriptMgr->OnItemPickup(this, pItem, sourceType, sourceId);
    }
}

void Player::StoreLootItem(uint8 lootSlot, Loot* loot, Object* src, AELootResult* lootResult)
{
    QuestItem* qitem    = nullptr;
    QuestItem* ffaitem  = nullptr;
    QuestItem* conditem = nullptr;
    QuestItem* currency = nullptr;
    QuestItem* personal = nullptr;

    LootItem* item = loot->LootItemInSlot(lootSlot, this, &qitem, &ffaitem, &conditem, &currency, &personal);

    if (!item)
    {
        SendEquipError(EQUIP_ERR_LOOT_GONE, NULL, NULL);
        return;
    }

    // questitems use the blocked field for other purposes
    if (!qitem && item->is_blocked)
    {
        if (!GetGroup() || GetGroup()->GetLootMethod() != MASTER_LOOT) // Temporary hack
            SendLootReleaseAll();
        return;
    }

    if (currency)
    {
        if (CurrencyTypesEntry const * currencyEntry = sCurrencyTypesStore.LookupEntry(item->itemid))
        {
            uint32 precision = (currencyEntry->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;
            ModifyCurrency(item->itemid, int32(item->count * precision));
            if (item->itemid == CURRENCY_TYPE_VALOR_POINTS || item->itemid == CURRENCY_TYPE_LESSER_CHARM_OF_GOOD_FORTUNE)
                SendDisplayToast(nullptr, item->itemid, int32(item->count * precision), TOAST_TYPE_CURRENCY, TOAST_DISPLAY_TYPE_CURRENCY);
        }

        SendNotifyLootItemRemoved(lootSlot, loot->GetGUID());
        currency->is_looted = true;
        --loot->unlootedCount;
        return;
    }

    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count);
    if (msg == EQUIP_ERR_OK)
    {
        Item* newitem = StoreNewItem(dest, item->itemid, true, item->randomPropertyId, item->GetAllowedLooters());

        if (GetZoneId() == 6757 && newitem->GetTemplate()->Quality == ITEM_QUALITY_EPIC)
            SendDisplayToast(newitem, 0, 0, TOAST_TYPE_ITEM, TOAST_DISPLAY_TYPE_UNK);

        if (qitem)
        {
            qitem->is_looted = true;
            //freeforall is 1 if everyone's supposed to get the quest item.
            if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
                SendNotifyLootItemRemoved(lootSlot, loot->GetGUID());
            else
                loot->NotifyQuestItemRemoved(qitem->index);
        }
        else
        {
            if (ffaitem)
            {
                //freeforall case, notify only one player of the removal
                ffaitem->is_looted = true;
                SendNotifyLootItemRemoved(lootSlot, loot->GetGUID());
            }
            else
            {
                //not freeforall, notify everyone
                if (personal)
                    personal->is_looted = true;
                if (conditem)
                    conditem->is_looted = true;
                loot->NotifyItemRemoved(lootSlot);
            }
        }

        //if only one person is supposed to loot the item, then set it to looted
        if (!item->freeforall && !item->personal)
            item->is_looted = true;

        --loot->unlootedCount;

        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->itemid))
            if (proto->Quality > ITEM_QUALITY_EPIC || (proto->Quality == ITEM_QUALITY_EPIC && proto->ItemLevel >= MinNewsItemLevel[sWorld->getIntConfig(CONFIG_EXPANSION)]))
                if (Guild* guild = GetGuild())
                    guild->AddGuildNews(GUILD_NEWS_ITEM_LOOTED, GetGUID(), 0, item->itemid);

        if (!lootResult)
        {
            SendNewItem(newitem, uint32(item->count), false, false, true);
            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_TYPE, item->itemid, item->count, loot->loot_type, this);

            bool gathering = false;
            GameObject* go = loot->GetSource() ? loot->GetSource()->ToGameObject() : nullptr;
            if (go && go->GetGOInfo()->GetLockId())
            {
                if (auto entry = sLockStore.LookupEntry(go->GetGOInfo()->GetLockId()))
                {
                    for (uint32 i = 0; i < MAX_LOCK_CASE; ++i)
                    {
                        if (entry->Type[i] == LOCK_KEY_SKILL && (entry->Index[i] == LOCKTYPE_HERBALISM || entry->Index[i] == LOCKTYPE_MINING))
                        {
                            gathering = true;
                            break;
                        }
                    }
                }
            }

            if (gathering)
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_GATHER_ITEM, item->itemid, item->count);
            else
                UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
        }
        else
            lootResult->Add(newitem, item->count, loot->loot_type);

        // LootItem is being removed (looted) from the container, delete it from the DB.
        if (loot->containerID > 0)
            loot->DeleteLootItemFromContainerItemDB(item->itemid);

        if (Group* group = GetGroup())
            if (group->IsLogging() && newitem)
                group->LogEvent("Item looted: %s by %s", Group::Format(newitem).c_str(), Group::Format(this).c_str());

        if (newitem && GetSession()->HasFlag(ACC_FLAG_ITEM_LOG) && src)
        {
            std::string str;
            switch (src->GetTypeId())
            {
                case TYPEID_CONTAINER:
                case TYPEID_ITEM:
                    str = "item";
                    break;
                case TYPEID_GAMEOBJECT:
                    str = "game object";
                    break;
                case TYPEID_UNIT:
                    str = "creature";
                    break;
            }

            logs::ItemLog(this, newitem, item->count, "Loot from %s: %u (GUID: %u)", str.c_str(), src->GetEntry(), src->GetGUIDLow());
        }

        ItemPickupSourceType sourceType = ItemPickupSourceType::Unknown;
        uint32 sourceId = 0;
        if (src)
        {
            switch (src->GetTypeId())
            {
                case TYPEID_ITEM:       sourceType = ItemPickupSourceType::ItemLoot; break;
                case TYPEID_CONTAINER:  sourceType = ItemPickupSourceType::ItemLoot; break;
                case TYPEID_UNIT:       sourceType = ItemPickupSourceType::CreatureLoot; break;
                case TYPEID_PLAYER:     sourceType = ItemPickupSourceType::PlayerLoot; break;
                case TYPEID_GAMEOBJECT: sourceType = ItemPickupSourceType::GameObjectLoot; break;
                case TYPEID_CORPSE:     sourceType = ItemPickupSourceType::PlayerLoot; break;
                default:                sourceType = ItemPickupSourceType::Unknown; break;
            }
            sourceId = src->GetTypeId() == TYPEID_PLAYER ? src->GetGUIDLow() : src->GetEntry();
        }

        sScriptMgr->OnItemPickup(this, newitem, sourceType, sourceId);
    }
    else
        SendEquipError(msg, NULL, NULL, item->itemid);
}

uint32 Player::CalculateTalentsPoints() const
{
    // 1 talent point for every 15 levels
    return uint32(floor(getLevel() / 15.f));
}

bool Player::IsKnowHowFlyIn(uint32 mapid, uint32 zone) const
{
    if (IsGameMaster())
        return true;

    if (IsNoFlyZone(zone))
        return false;

    // Eye of the Storm is always allowed in Throne of the Four Winds
    if (zone == 5638 && HasAura(82724))
        return true;

    // Wings of Flame is always allowed in Firelands
    if (zone == 5723 && HasAura(98619))
        return true;

    // continent checked in SpellInfo::CheckLocation at cast and area update
    uint32 v_map = GetVirtualMapForMapAndZone(mapid, zone);
    switch (v_map)
    {
        case 0:   // Eastern Kingdoms
        case 1:   // Kalimdor
        case 646: // Deepholm
            return HasSpell(90267); // Flight Master's License
        case 571: // Northrend
            return HasSpell(54197); // Cold Weather Flying
        case 530: // Outland
            return true;
        case 870: // Pandaria
            return HasSpell(115913);
    }
    return false;
}

void Player::learnSpellHighRank(uint32 spellid)
{
    LearnSpell(spellid, false);

    if (uint32 next = sSpellMgr->GetNextSpellInChain(spellid))
        learnSpellHighRank(next);
}

void Player::_LoadSkills(PreparedQueryResult result)
{
    //                                                           0      1      2
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));

    uint32 count = 0;
    uint8 professionCount = 0;
    std::map<uint32, uint32> learnReward;
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint16 skill    = fields[0].GetUInt16();
            uint16 value    = fields[1].GetUInt16();
            uint16 max      = fields[2].GetUInt16();

            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(skill);
            if (!pSkill)
            {
                TC_LOG_ERROR("entities.player", "Character %u has skill %u that does not exist.", GetGUIDLow(), skill);
                continue;
            }

            // set fixed skill ranges
            switch (GetSkillRangeType(pSkill, false))
            {
                case SKILL_RANGE_LANGUAGE:                      // 300..300
                    value = max = 300;
                    break;
                case SKILL_RANGE_MONO:                          // 1..1, grey monolite bar
                    value = max = 1;
                    break;
                default:
                    break;
            }
            if (value == 0)
            {
                TC_LOG_ERROR("entities.player", "Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);

                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);

                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt16(1, skill);

                CharacterDatabase.Execute(stmt);

                continue;
            }

            uint16 field = count / 2;
            uint8 offset = count & 1;

            SetUInt16Value(PLAYER_FIELD_SKILL_LINEIDS + field, offset, skill);
            uint16 step = 0;

            if (pSkill->categoryId == SKILL_CATEGORY_SECONDARY)
                step = max / 75;

            if (pSkill->categoryId == SKILL_CATEGORY_PROFESSION)
            {
                step = max / 75;

                if (professionCount < 2)
                    SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + professionCount++, skill);
            }

            SetUInt16Value(PLAYER_FIELD_SKILL_STEPS + field, offset, step);
            SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, value);
            SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, max);
            SetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset, 0);

            mSkillStatus.insert(SkillStatusMap::value_type(skill, SkillStatusData(count, SKILL_UNCHANGED)));
            learnReward.emplace(skill, value);

            ++count;

            if (count >= PLAYER_MAX_SKILLS)                      // client limit
            {
                TC_LOG_ERROR("entities.player", "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
                break;
            }
        }
        while (result->NextRow());
    }

    for (auto&& it : learnReward)
        LearnSkillRewardedSpells(it.first, it.second);

    for (; count < PLAYER_MAX_SKILLS; ++count)
    {
        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL_LINEIDS + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL_STEPS + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL_RANKS + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL_MAX_RANKS + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL_MODIFIERS + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL_TALENTS + field, offset, 0);
    }

    // special settings
    if (getClass() == CLASS_DEATH_KNIGHT)
    {
        uint8 base_level = std::min(getLevel(), uint8(sWorld->getIntConfig(CONFIG_START_HEROIC_PLAYER_LEVEL)));
        if (base_level < 1)
            base_level = 1;
        uint16 base_skill = (base_level-1)*5;               // 270 at starting level 55
        if (base_skill < 1)
            base_skill = 1;                                 // skill mast be known and then > 0 in any case

        if (GetPureSkillValue(SKILL_FIRST_AID) < base_skill)
            SetSkill(SKILL_FIRST_AID, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_AXES) < base_skill)
            SetSkill(SKILL_AXES, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_DEFENSE) < base_skill)
            SetSkill(SKILL_DEFENSE, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_POLEARMS) < base_skill)
            SetSkill(SKILL_POLEARMS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_SWORDS) < base_skill)
            SetSkill(SKILL_SWORDS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_2H_AXES) < base_skill)
            SetSkill(SKILL_2H_AXES, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_2H_SWORDS) < base_skill)
            SetSkill(SKILL_2H_SWORDS, 0, base_skill, base_skill);
        if (GetPureSkillValue(SKILL_UNARMED) < base_skill)
            SetSkill(SKILL_UNARMED, 0, base_skill, base_skill);
    }
}

InventoryResult Player::CanEquipUniqueItem(Item* pItem, uint8 eslot, uint32 limit_count) const
{
    ItemTemplate const* pProto = pItem->GetTemplate();

    // proto based limitations
    if (InventoryResult res = CanEquipUniqueItem(pProto, eslot, limit_count))
        return res;

    // check unique-equipped on gems
    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
    {
        uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
        if (!enchant_id)
            continue;
        SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!enchantEntry)
            continue;

        ItemTemplate const* pGem = sObjectMgr->GetItemTemplate(enchantEntry->GemID);
        if (!pGem)
            continue;

        // include for check equip another gems with same limit category for not equipped item (and then not counted)
        uint32 gem_limit_count = !pItem->IsEquipped() && pGem->ItemLimitCategory
            ? pItem->GetGemCountWithLimitCategory(pGem->ItemLimitCategory) : 1;

        if (InventoryResult res = CanEquipUniqueItem(pGem, eslot, gem_limit_count))
            return res;
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanEquipUniqueItem(ItemTemplate const* itemProto, uint8 except_slot, uint32 limit_count) const
{
    // check unique-equipped on item
    if (itemProto->Flags & ITEM_PROTO_FLAG_UNIQUE_EQUIPPED)
    {
        // there is an equip limit on this item
        if (HasItemOrGemWithIdEquipped(itemProto->ItemId, 1, except_slot))
            return EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE;
    }

    // check unique-equipped limit
    if (itemProto->ItemLimitCategory)
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(itemProto->ItemLimitCategory);
        if (!limitEntry)
            return EQUIP_ERR_NOT_EQUIPPABLE;

        // NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case

        if (limit_count > limitEntry->maxCount)
            return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS;

        // there is an equip limit on this item
        if (HasItemOrGemWithLimitCategoryEquipped(itemProto->ItemLimitCategory, limitEntry->maxCount - limit_count + 1, except_slot))
            return EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED;
    }

    return EQUIP_ERR_OK;
}

void Player::SetFallInformation(uint32 time, float z)
{
    m_lastFallTime = time;
    m_lastFallZ = z;
}

void Player::HandleFall(MovementInfo const& movementInfo)
{
    // At first remove auras to execute Meteor Slam (124315) to prevent damage
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LANDING);

    // calculate total z distance of the fall
    float z_diff = m_lastFallZ - movementInfo.pos.GetPositionZ();
    m_lastFallAbsoluteTime = getMSTime();
    //TC_LOG_DEBUG("misc", "zDiff = %f", z_diff);

    //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
    // 14.57 can be calculated by resolving damageperc formula below to 0
    if (z_diff >= 14.57f && !isDead() && !IsGameMaster() &&
        !HasAuraType(SPELL_AURA_HOVER) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
        !HasAuraType(SPELL_AURA_FLY) && !IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
    {
        //Safe fall, fall height reduction
        int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);

        float damageperc = 0.018f*(z_diff-safe_fall)-0.2426f;

        if (damageperc > 0)
        {
            uint32 damage = (uint32)(damageperc * GetMaxHealth()*sWorld->getRate(RATE_DAMAGE_FALL));

            float height = movementInfo.pos.m_positionZ;
            UpdateGroundPositionZ(movementInfo.pos.m_positionX, movementInfo.pos.m_positionY, height);

            if (damage > 0)
            {
                // Percentage from SPELL_AURA_MODIFY_FALL_DAMAGE_PCT
                for (auto&& itr : GetAuraEffectsByType(SPELL_AURA_MODIFY_FALL_DAMAGE_PCT))
                    AddPct(damage, itr->GetAmount());

                //Prevent fall damage from being more than the player maximum health
                if (damage > GetMaxHealth())
                    damage = GetMaxHealth();

                // Gust of Wind
                if (HasAura(43621))
                    damage = GetMaxHealth()/2;

                uint32 original_health = GetHealth();
                uint32 final_damage = EnvironmentalDamage(DAMAGE_FALL, damage);

                // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
                if (IsAlive() && final_damage < original_health)
                    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_FALL_WITHOUT_DYING, uint32(z_diff*100));
            }

            //Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
            TC_LOG_DEBUG("entities.player", "FALLDAMAGE z=%f sz=%f pZ=%f FallTime=%d mZ=%f damage=%d SF=%d", movementInfo.pos.GetPositionZ(), height, GetPositionZ(), movementInfo.jump.fallTime, height, damage, safe_fall);
        }
    }
}

void Player::ResetAchievements()
{
    m_achievementMgr->Reset();
}

void Player::SendRespondInspectAchievements(Player* player) const
{
    m_achievementMgr->SendAchievementInfo(player);
}

uint32 Player::GetAchievementPoints() const
{
    return m_achievementMgr->GetAchievementPoints();    // Account achievements already included.
}

bool Player::HasAchieved(uint32 achievementId, bool playerOnly) const
{
    if (m_achievementMgr->HasAchieved(achievementId))
        return true;
    if (playerOnly)
        return false;
    return GetSession()->GetAchievementMgr().HasAchieved(achievementId);
}

void Player::StartCriteria(CriteriaStartTypes type, uint32 entry, uint32 timeLost/* = 0*/)
{
    m_achievementMgr->StartCriteria(type, entry, timeLost);
}

void Player::RemoveTimedAchievement(CriteriaStartTypes type, uint32 entry)
{
    m_achievementMgr->RemoveCriteriaTimer(type, entry);
}

void Player::ResetAchievementCriteria(AchievementCriteriaTypes type, uint64 miscValue1 /*= 0*/, uint64 miscValue2 /*= 0*/, bool evenIfCriteriaComplete /* = false*/)
{
    m_achievementMgr->ResetAchievementCriteria(type, miscValue1, miscValue2, evenIfCriteriaComplete);
    GetSession()->GetAchievementMgr().ResetAchievementCriteria(type, miscValue1, miscValue2, evenIfCriteriaComplete);
}

void Player::ResetCriterias(CriteriaResetTypes type, uint32 asset)
{
    m_achievementMgr->ResetCriterias(type, asset);
    GetSession()->GetAchievementMgr().ResetCriterias(type, asset);
}

void Player::ResetCriterias(CriteriaStartTypes type, uint32 asset)
{
    m_achievementMgr->ResetCriterias(type, asset);
    GetSession()->GetAchievementMgr().ResetCriterias(type, asset);
}

void Player::UpdateAchievementCriteria(AchievementCriteriaTypes type, uint64 miscValue1 /*= 0*/, uint64 miscValue2 /*= 0*/, uint64 miscValue3 /*= 0*/, Unit* unit /*= NULL*/)
{
    // Also include Account achievements.
    m_achievementMgr->UpdateAchievementCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
    Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
    if (!guild)
        return;

    guild->UpdateMemberData(this, GUILD_MEMBER_DATA_ACHIEVEMENT_POINTS, GetAchievementPoints());

    // Update only individual achievement criteria here, otherwise we may get multiple updates
    // from a single boss kill
    if (sAchievementMgr->IsGroupCriteriaType(type))
        return;

    guild->UpdateAchievementCriteria(type, miscValue1, miscValue2, miscValue3, unit, this);
}

void Player::CompletedAchievement(AchievementEntry const* entry)
{
    if (entry->Flags & ACHIEVEMENT_FLAG_ACCOUNT)
        GetSession()->GetAchievementMgr().CompletedAchievement(entry, this);
    else
        m_achievementMgr->CompletedAchievement(entry, this);
}

void Player::RemoveAchievement(AchievementEntry const* entry)
{
    if (entry->Flags & ACHIEVEMENT_FLAG_ACCOUNT)
        GetSession()->GetAchievementMgr().RemoveAchievement(entry);
    else
        m_achievementMgr->RemoveAchievement(entry);
}

bool Player::LearnTalent(uint16 talentId)
{
    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);

    if (!talentInfo)
        return false;

    uint32 maxTalentRow = GetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS);

    // prevent learn talent for different class (cheating)
    if (talentInfo->PlayerClass != getClass())
        return false;

    // check if we have enough talent points
    if (talentInfo->Row > maxTalentRow)
        return false;

    // Check if player doesnt have any spell in selected collumn
    for (uint32 i = 0; i < sTalentStore.GetNumRows(); i++)
    {
        if (TalentEntry const* talent = sTalentStore.LookupEntry(i))
        {
            if (talentInfo->Row == talent->Row && HasSpell(talent->SpellId))
                return false;
        }
    }

    // spell not set in talent.dbc
    uint32 spellid = talentInfo->SpellId;
    if (spellid == 0)
    {
        TC_LOG_ERROR("entities.player", "Talent.dbc have for talent: %u spell id = 0", talentId);
        return false;
    }

    // already known
    if (HasSpell(spellid))
        return false;

    if (!AddTalent(spellid, GetActiveSpec(), true))
        return false;

    LearnSpell(spellid, false);

    TC_LOG_INFO("misc", "TalentID: %u Spell: %u Spec: %u\n", talentId, spellid, GetActiveSpec());
    return true;
}

void Player::AddKnownCurrency(uint32 itemId)
{
    if (CurrencyTypesEntry const* ctEntry = sCurrencyTypesStore.LookupEntry(itemId))
        SetFlag64(0, (1LL << (ctEntry->ID-1)));
}

void Player::UpdateFallInformationIfNeed(MovementInfo const& minfo, uint16 opcode)
{
    if (m_lastFallTime >= minfo.jump.fallTime || m_lastFallZ <= minfo.pos.GetPositionZ() || opcode == MSG_MOVE_FALL_LAND)
        SetFallInformation(minfo.jump.fallTime, minfo.pos.GetPositionZ());
}

void Player::UnsummonPetTemporaryIfAny()
{
    Pet* pet = GetPet();
    if (!pet)
        return;

    if (!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned())
        m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetPetNumber();

    RemovePet(PET_REMOVE_DISMISS);
}

void Player::ResummonPetTemporaryUnSummonedIfAny()
{
    if (!m_temporaryUnsummonedPetNumber)
        return;

    // not resummon in not appropriate state
    if (IsPetNeedBeTemporaryUnsummoned())
        return;

    if (GetPetGUID())
        return;

    Pet* NewPet = new Pet(this);
    if (!NewPet->LoadPetFromDB(PET_LOAD_BY_ID, m_temporaryUnsummonedPetNumber))
        delete NewPet;

    m_temporaryUnsummonedPetNumber = 0;
}

bool Player::IsPetNeedBeTemporaryUnsummoned() const
{
    return !IsInWorld() || !IsAlive() || IsMounted(); /*+in flight*/
}

bool Player::CanSeeSpellClickOn(Creature const* c) const
{
    if (!c->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
        return false;

    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(c->GetEntry());
    if (clickPair.first == clickPair.second)
        return true;

    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
    {
        if (!itr->second.IsFitToRequirements(this, c))
            continue;

        ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(c->GetEntry(), itr->second.spellId);
        ConditionSourceInfo info = ConditionSourceInfo(const_cast<Player*>(this), const_cast<Creature*>(c));
        if (!sConditionMgr->IsObjectMeetToConditions(info, conds))
            continue;

        return true;
    }

    return false;
}

void Player::BuildPlayerTalentsInfoData(WorldPacket* data)
{
    std::vector<size_t> wpos;
    wpos.resize(GetSpecsCount());

    *data << uint8(GetActiveSpec());                        // talent group index (0 or 1)
    data->WriteBits(GetSpecsCount(), 19);

    for (size_t i = 0; i < wpos.size(); i++)
    {
        wpos[i] = data->bitwpos();
        data->WriteBits(0, 23);
    }

    data->FlushBits();

    for (size_t i = 0; i < wpos.size(); i++)
    {
        for (uint8 j = 0; j < MAX_GLYPH_SLOT_INDEX; ++j)
            *data << uint16(GetGlyph(i, j));               // GlyphProperties.dbc

        int32 talentCount = 0;
        for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
        {
            TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
            if (!talentInfo)
                continue;

            if (talentInfo->PlayerClass != getClass())
                continue;

            if (!HasTalent(talentInfo->SpellId, i))
                continue;

            *data << uint16(talentInfo->TalentID);  // Talent.dbc

            talentCount++;
        }

        data->PutBits(wpos[i], talentCount, 23);
        *data << uint32(GetTalentSpecialization(i));
    }
}

void Player::SendTalentsInfoData()
{
    WorldPacket data(SMSG_TALENTS_INFO, 50);
    BuildPlayerTalentsInfoData(&data);
    GetSession()->SendPacket(&data);
}

void Player::BuildEnchantmentsInfoData(WorldPacket* data)
{
    uint32 slotUsedMask = 0;
    size_t slotUsedMaskPos = data->wpos();
    *data << uint32(slotUsedMask);                          // slotUsedMask < 0x80000

    for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i);

        if (!item)
            continue;

        slotUsedMask |= (1 << i);

        *data << uint32(item->GetEntry());                  // item entry

        uint16 enchantmentMask = 0;
        size_t enchantmentMaskPos = data->wpos();
        *data << uint16(enchantmentMask);                   // enchantmentMask < 0x1000

        for (uint32 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
        {
            uint32 enchId = item->GetEnchantmentId(EnchantmentSlot(j));

            if (!enchId)
                continue;

            enchantmentMask |= (1 << j);

            *data << uint16(enchId);                        // enchantmentId?
        }

        data->put<uint16>(enchantmentMaskPos, enchantmentMask);

        *data << uint16(0);                                 // unknown
        data->appendPackGUID(item->GetUInt64Value(ITEM_FIELD_CREATOR)); // item creator
        *data << uint32(0);                                 // seed?
    }

    data->put<uint32>(slotUsedMaskPos, slotUsedMask);
}

void Player::SendEquipmentSetList()
{
    uint32 count = 0;
    ByteBuffer equipmentData;

    WorldPacket data(SMSG_LOAD_EQUIPMENT_SET);

    size_t writePos = data.bitwpos();
    data.WriteBits(count, 19);

    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
    {
        if (itr->second.state == EQUIPMENT_SET_DELETED)
            continue;

        ObjectGuid setGuid = itr->second.Guid;

        data.WriteBit(setGuid[4]);

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
        {
            // 0 if slot must be unequipped, 1 if item must be ignored
            ObjectGuid itemGuid;
            if (itr->second.IgnoreMask & (1 << i))
                itemGuid = 1;
            else if (itr->second.Items[i])
                itemGuid = MAKE_NEW_GUID(itr->second.Items[i], 0, HIGHGUID_ITEM);

            data.WriteGuidMask(itemGuid, 3, 5, 7, 2, 6, 0, 4, 1);
            equipmentData.WriteGuidBytes(itemGuid, 2, 3, 7, 1, 6, 5, 0, 4);
        }

        data.WriteBit(setGuid[5]);
        data.WriteBits(itr->second.IconName.size(), 9);
        data.WriteBit(setGuid[1]);
        data.WriteBit(setGuid[7]);
        data.WriteBits(itr->second.Name.size(), 8);
        data.WriteBit(setGuid[3]);
        data.WriteBit(setGuid[2]);
        data.WriteBit(setGuid[6]);
        data.WriteBit(setGuid[0]);

        equipmentData.WriteByteSeq(setGuid[7]);
        equipmentData << uint32(itr->first);
        equipmentData.WriteString(itr->second.Name.c_str());
        equipmentData.WriteByteSeq(setGuid[2]);
        equipmentData.WriteByteSeq(setGuid[6]);
        equipmentData.WriteByteSeq(setGuid[0]);
        equipmentData.WriteByteSeq(setGuid[3]);
        equipmentData.WriteByteSeq(setGuid[1]);
        equipmentData.WriteByteSeq(setGuid[5]);
        equipmentData.WriteByteSeq(setGuid[4]);
        equipmentData.WriteString(itr->second.IconName.c_str());

        count++;
    }

    data.FlushBits();
    data.PutBits(writePos, count, 19);
    data.append(equipmentData);

    GetSession()->SendPacket(&data);
}

void Player::SetEquipmentSet(uint32 index, EquipmentSet eqset)
{
    if (eqset.Guid != 0)
    {
        bool found = false;

        for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
        {
            if ((itr->second.Guid == eqset.Guid) && (itr->first == index))
            {
                found = true;
                break;
            }
        }

        if (!found)                                          // something wrong...
        {
            TC_LOG_ERROR("entities.player", "Player %s tried to save equipment set " UI64FMTD " (index %u), but that equipment set not found!", GetName().c_str(), eqset.Guid, index);
            return;
        }
    }

    EquipmentSet& eqslot = m_EquipmentSets[index];

    EquipmentSetUpdateState old_state = eqslot.state;

    eqslot = eqset;

    if (eqset.Guid == 0)
    {
        eqslot.Guid = sObjectMgr->GenerateEquipmentSetGuid();
        ObjectGuid guid = eqslot.Guid;

        WorldPacket data(SMSG_EQUIPMENT_SET_ID, 8 + 4);
        
        data.WriteBit(guid[4]);
        data.WriteBit(guid[1]);
        data.WriteBit(guid[6]);
        data.WriteBit(guid[2]);
        data.WriteBit(guid[7]);
        data.WriteBit(guid[0]);
        data.WriteBit(guid[3]);
        data.WriteBit(guid[5]);

        data << uint32(index);

        data.WriteByteSeq(guid[1]);
        data.WriteByteSeq(guid[3]);
        data.WriteByteSeq(guid[7]);
        data.WriteByteSeq(guid[4]);
        data.WriteByteSeq(guid[5]);
        data.WriteByteSeq(guid[0]);
        data.WriteByteSeq(guid[2]);
        data.WriteByteSeq(guid[6]);

        GetSession()->SendPacket(&data);
    }

    eqslot.state = old_state == EQUIPMENT_SET_NEW ? EQUIPMENT_SET_NEW : EQUIPMENT_SET_CHANGED;
}

void Player::_SaveEquipmentSets(SQLTransaction& trans)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end();)
    {
        uint32 index = itr->first;
        EquipmentSet& eqset = itr->second;
        PreparedStatement* stmt = NULL;
        uint8 j = 0;
        switch (eqset.state)
        {
            case EQUIPMENT_SET_UNCHANGED:
                ++itr;
                break;                                      // nothing do
            case EQUIPMENT_SET_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_EQUIP_SET);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                stmt->setUInt32(j++, GetGUIDLow());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j, index);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_EQUIP_SET);
                stmt->setUInt32(j++, GetGUIDLow());
                stmt->setUInt64(j++, eqset.Guid);
                stmt->setUInt32(j++, index);
                stmt->setString(j++, eqset.Name.c_str());
                stmt->setString(j++, eqset.IconName.c_str());
                stmt->setUInt32(j++, eqset.IgnoreMask);
                for (uint8 i=0; i<EQUIPMENT_SLOT_END; ++i)
                    stmt->setUInt32(j++, eqset.Items[i]);
                trans->Append(stmt);
                eqset.state = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            case EQUIPMENT_SET_DELETED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EQUIP_SET);
                stmt->setUInt64(0, eqset.Guid);
                trans->Append(stmt);
                m_EquipmentSets.erase(itr++);
                break;
        }
    }
}

void Player::_SaveBGData(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);
    /* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell */
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_BGDATA);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt32(1, m_bgData.bgInstanceID);
    stmt->setUInt16(2, m_bgData.bgTeam);
    stmt->setFloat (3, m_bgData.joinPos.GetPositionX());
    stmt->setFloat (4, m_bgData.joinPos.GetPositionY());
    stmt->setFloat (5, m_bgData.joinPos.GetPositionZ());
    stmt->setFloat (6, m_bgData.joinPos.GetOrientation());
    stmt->setUInt16(7, m_bgData.joinPos.GetMapId());
    stmt->setUInt16(8, m_bgData.taxiPath[0]);
    stmt->setUInt16(9, m_bgData.taxiPath[1]);
    stmt->setUInt16(10, m_bgData.taxiLastNode);
    stmt->setUInt32(11, m_bgData.mountSpell);
    trans->Append(stmt);
}

void Player::DeleteEquipmentSet(uint64 setGuid)
{
    for (EquipmentSets::iterator itr = m_EquipmentSets.begin(); itr != m_EquipmentSets.end(); ++itr)
    {
        if (itr->second.Guid == setGuid)
        {
            if (itr->second.state == EQUIPMENT_SET_NEW)
                m_EquipmentSets.erase(itr);
            else
                itr->second.state = EQUIPMENT_SET_DELETED;
            break;
        }
    }
}

void Player::RemoveAtLoginFlag(AtLoginFlags flags, bool persist /*= false*/)
{
    m_atLoginFlags &= ~flags;

    if (persist)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_REM_AT_LOGIN_FLAG);

        stmt->setUInt16(0, uint16(flags));
        stmt->setUInt32(1, GetGUIDLow());

        CharacterDatabase.Execute(stmt);
    }
}

void Player::SendClearCooldown(uint32 spell_id, Unit* target)
{
    ObjectGuid guid = target->GetGUID();
    WorldPacket data(SMSG_CLEAR_COOLDOWN, 4+8+1);
    data.WriteGuidMask(guid, 3, 6, 2);
    data.WriteBit(true);
    data.WriteGuidMask(guid, 7, 0, 1, 5, 4);

    data.FlushBits();

    data.WriteGuidBytes(guid, 0, 1, 2, 7, 3, 6, 5);
    data << uint32(spell_id);
    data.WriteGuidBytes(guid, 4);

    SendDirectMessage(&data);
}

void Player::ResetMap()
{
    // this may be called during Map::Update
    // after decrement+unlink, ++m_mapRefIter will continue correctly
    // when the first element of the list is being removed
    // nocheck_prev will return the padding element of the RefManager
    // instead of NULL in the case of prev
    GetMap()->UpdateIteratorBack(this);
    Unit::ResetMap();
    GetMapRef().unlink();
}

void Player::SetMap(Map* map)
{
    Unit::SetMap(map);
    m_mapRef.link(map, this);
}

void Player::_LoadGlyphs(PreparedQueryResult result)
{
    // SELECT spec, glyph1, glyph2, glyph3, glyph4, glyph5, glyph6, glyph7, glyph8, glyph9 FROM character_glyphs WHERE guid = '%u'
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint8 spec = fields[0].GetUInt8();
        if (spec >= GetSpecsCount())
            continue;

        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
            _talentMgr->SpecInfo[spec].Glyphs[i] = fields[i + 1].GetUInt16();
    }
    while (result->NextRow());
}

void Player::_SaveGlyphs(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);


    for (uint8 spec = 0; spec < GetSpecsCount(); ++spec)
    {
        uint8 index = 0;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
        stmt->setUInt32(index++, GetGUIDLow());

        stmt->setUInt8(index++, spec);

        for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
            stmt->setUInt16(index++, uint16(GetGlyph(spec, i)));

        trans->Append(stmt);
    }
}

void Player::_LoadTalents(PreparedQueryResult result)
{
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADTALENTS, "SELECT spell, spec FROM character_talent WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
            AddTalent((*result)[0].GetUInt32(), (*result)[1].GetUInt8(), false);
        while (result->NextRow());
    }
}

void Player::_SaveTalents(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (uint8 i = 0; i < MAX_TALENT_SPECS; ++i)
    {
        for (PlayerTalentMap::iterator itr = GetTalentMap(i)->begin(); itr != GetTalentMap(i)->end();)
        {
            if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->state == PLAYERSPELL_CHANGED)
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT_BY_SPELL_SPEC);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt32(1, itr->first);
                stmt->setUInt8(2, itr->second->spec);
                trans->Append(stmt);
            }

            if (itr->second->state == PLAYERSPELL_NEW || itr->second->state == PLAYERSPELL_CHANGED)
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
                stmt->setUInt32(0, GetGUIDLow());
                stmt->setUInt32(1, itr->first);
                stmt->setUInt8(2, itr->second->spec);
                trans->Append(stmt);
            }

            if (itr->second->state == PLAYERSPELL_REMOVED)
            {
                delete itr->second;
                GetTalentMap(i)->erase(itr++);
            }
            else
            {
                itr->second->state = PLAYERSPELL_UNCHANGED;
                ++itr;
            }
        }
    }
}

void Player::UpdateSpecCount(uint8 count)
{
    uint32 curCount = GetSpecsCount();
    if (curCount == count)
        return;

    if (GetActiveSpec() >= count)
        ActivateSpec(0);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    PreparedStatement* stmt = NULL;

    // Copy spec data
    if (count > curCount)
    {
        _SaveActions(trans); // make sure the button list is cleaned up
        for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end(); ++itr)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt8(1, 1);
            stmt->setUInt8(2, itr->first);
            stmt->setUInt32(3, itr->second.GetAction());
            stmt->setUInt8(4, uint8(itr->second.GetType()));
            trans->Append(stmt);
        }
    }
    // Delete spec data for removed spec.
    else if (count < curCount)
    {
        _SaveActions(trans);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_EXCEPT_SPEC);
        stmt->setUInt8(0, GetActiveSpec());
        stmt->setUInt32(1, GetGUIDLow());
        trans->Append(stmt);

    }

    CharacterDatabase.CommitTransaction(trans);

    SetSpecsCount(count);

    SendTalentsInfoData();
}

void Player::ActivateSpec(uint8 spec)
{

    if (GetActiveSpec() == spec)
        return;

    if (spec > GetSpecsCount())
        return;

    LeaveFromSoloQueueIfNeed();

    if (IsNonMeleeSpellCasted(false))
        InterruptNonMeleeSpells(false);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveActions(trans);
    CharacterDatabase.CommitTransaction(trans);

    // TO-DO: We need more research to know what happens with warlock's reagent
    if (Pet* pet = GetPet())
        RemovePet(PET_REMOVE_DISMISS, PET_REMOVE_FLAG_RESET_CURRENT);

    ClearComboPointHolders();
    ClearAllReactives();
    UnsummonAllTotems();
    ExitVehicle();
    RemoveAllControlled();
    /*RemoveAllAurasOnDeath();
    if (GetPet())
        GetPet()->RemoveAllAurasOnDeath();*/

    //RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
    //ExitVehicle(); // should be impossible to switch specs from inside a vehicle..

    // Let client clear his current Actions
    SendActionButtons(2);
    // m_actionButtons.clear() is called in the next _LoadActionButtons

    for (auto&& it : *GetTalentMap(GetActiveSpec()))
    {
        auto* spellEntry = sSpellMgr->GetSpellInfo(it.first);
        if (!spellEntry)
            continue;

        RemoveSpell(spellEntry->Id, true);

        // search for spells that the talent teaches and unlearn them
        for (auto&& spellEffect : spellEntry->Effects)
            if (spellEffect.TriggerSpell > 0 && spellEffect.Effect == SPELL_EFFECT_LEARN_SPELL)
                RemoveSpell(spellEffect.TriggerSpell, true);
    }

    RemoveSpecializationSpells();

    // set glyphs
    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
        UnapplyGlyph(slot);

    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG2_SPECIALIZATION_CHANGE);

    SetActiveSpec(spec);

    uint32 spentTalents = 0;
    for (auto&& it : *GetTalentMap(GetActiveSpec()))
    {
        LearnSpell(it.first, false);
        ++spentTalents;
    }

    LearnSpecializationSpells();

    // set glyphs
    for (uint8 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
        if (uint32 glyph = GetGlyph(GetActiveSpec(), slot))
            ApplyGlyph(slot, glyph);

    SetUsedTalentCount(spentTalents);
    InitTalentForLevel();

    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt8(1, GetActiveSpec());
        if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
            _LoadActions(result);
    }

    SendActionButtons(1);

    Powers pw = GetPowerType();
    if (pw != POWER_MANA)
        SetPower(POWER_MANA, 0); // Mana must be 0 even if it isn't the active power type.

    SetPower(pw, 0);

    UpdatePvpPower();

    // Needs for some trinkets which depends on spec
    ReapplyItemsBonuses();

    if (Group* group = GetGroup())
        if (group->IsLogging())
            group->LogEvent("Member changed spec: %s is now %s", Group::Format(this).c_str(), Group::GetPlayerTalentString(this).c_str());
}

void Player::ResetTimeSync()
{
    m_timeSyncTimer = 0;
    m_timeSyncClient = 0;
    m_timeSyncServer = getMSTime();
}

void Player::SendTimeSync()
{
    m_timeSyncQueue.push(m_movementCounter++);

    WorldPacket data(SMSG_TIME_SYNC_REQ, 4);
    data << uint32(m_timeSyncQueue.back());
    GetSession()->SendPacket(&data);

    // Schedule next sync in 10 sec
    m_timeSyncTimer = 10000;
    m_timeSyncServer = getMSTime();

    if (m_timeSyncQueue.size() > 3)
        TC_LOG_ERROR("network", "Not received CMSG_TIME_SYNC_RESP for over 30 seconds from player %u (%s), possible cheater", GetGUIDLow(), GetName().c_str());
}

void Player::SetReputation(uint32 factionentry, uint32 value)
{
    GetReputationMgr().SetReputation(sFactionStore.LookupEntry(factionentry), value);
}
uint32 Player::GetReputation(uint32 factionentry) const
{
    return GetReputationMgr().GetReputation(sFactionStore.LookupEntry(factionentry));
}

std::string Player::GetGuildName()
{
    return GetGuildId() ? sGuildMgr->GetGuildById(GetGuildId())->GetName() : "";
}

void Player::SendInspectResult(Player const* player)
{
    if (!player)
        return;

    uint32 slotCount = 0;
    uint32 talentCount = 0;

    ObjectGuid guid = player->GetGUID();
    Guild* guild = sGuildMgr->GetGuildById(player->GetGuildId());
    ObjectGuid guildGuid = guild ? guild->GetGUID() : 0;
    ByteBuffer enchantData;

    WorldPacket data(SMSG_INSPECT_RESULTS);
    data.WriteBit(guild != 0);
    data.WriteBit(guid[2]);
    if (guild)
        data.WriteGuidMask(guildGuid, 7, 0, 5, 3, 2, 4, 6, 1);

    data.WriteGuidMask(guid, 4, 3, 5, 7);
    size_t slotCountBitPos = data.bitwpos();
    data.WriteBits(slotCount, 20); // slot count placeholder
    data.WriteBit(guid[0]);
    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);

        if (!item)
            continue;

        ++slotCount;

        ObjectGuid creatorGuid = item->GetUInt64Value(ITEM_FIELD_CREATOR);
        uint32 enchantCount = 0;

        int16 randomProperty = item->GetItemRandomPropertyId();
        int32 suffixFactor = item->GetItemSuffixFactor();

        data.WriteBit(creatorGuid[1]);
        data.WriteBit(suffixFactor != 0);
        data.WriteBit(true); // unk, always true
        data.WriteBit(creatorGuid[3]);

        size_t enchCountBitPos = data.bitwpos();
        data.WriteBits(enchantCount, 21);
        data.WriteGuidMask(creatorGuid, 2, 6, 4);
        data.WriteBit(randomProperty != 0);
        data.WriteGuidMask(creatorGuid, 0, 5, 7);

        if (randomProperty)
            enchantData << int16(randomProperty);

        enchantData.WriteByteSeq(creatorGuid[3]);

        item->BuildItemDynamicModifiersData(&enchantData);

        for (uint8 j = 0; j < MAX_ENCHANTMENT_SLOT; ++j)
        {
            uint32 enchId = item->GetEnchantmentId(EnchantmentSlot(j));

            if (!enchId)
                continue;

            enchantData << uint32(enchId); // enchantmentId
            enchantData << uint8(j);       // enchantment slot
            ++enchantCount;
        }
        data.PutBits(enchCountBitPos, enchantCount, 21);

        enchantData << uint32(item->GetEntry());
        enchantData.WriteGuidBytes(creatorGuid, 6, 4, 7, 2);

        if (suffixFactor)
            enchantData << int32(suffixFactor);

        enchantData.WriteByteSeq(creatorGuid[5]);
        enchantData << uint8(i); // slot
        enchantData.WriteGuidBytes(creatorGuid, 0, 1);
    }

    data.WriteBits(MAX_GLYPH_SLOT_INDEX, 23);

    size_t talentCountBitPos = data.bitwpos();
    data.WriteBits(talentCount, 23); // talent count placeholder
    data.WriteGuidMask(guid, 6, 1);

    data.FlushBits();
    data.PutBits(slotCountBitPos, slotCount, 20);

    data.WriteGuidBytes(guid, 1, 4, 2);
    data.append(enchantData);

    if (guild)
    {
        data.WriteGuidBytes(guildGuid, 6, 2, 5, 0);
        data << uint32(guild->GetMembersCount());
        data.WriteGuidBytes(guildGuid, 4, 7);
        data << uint64(guild->GetExperience());
        data.WriteByteSeq(guildGuid[1]);
        data << uint32(guild->GetLevel());
        data.WriteByteSeq(guildGuid[3]);
    }

    data.WriteByteSeq(guid[5]);

    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
    {
        uint16 glyphId = player->GetGlyph(player->GetActiveSpec(), i); // GlyphProperties.dbc
        data << uint16(glyphId ? glyphId : 0);
    }

    data.WriteByteSeq(guid[0]);
    data << uint32(player->GetTalentSpecialization(player->GetActiveSpec()));

    for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
    {
        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
        if (!talentInfo)
            continue;

        if (talentInfo->PlayerClass != player->getClass())
            continue;

        if (!player->HasTalent(talentInfo->SpellId, player->GetActiveSpec()))
            continue;

        data << uint16(talentInfo->TalentID);  // Talent.dbc
        ++talentCount;
    }
    data.PutBits(talentCountBitPos, talentCount, 23);

    data.WriteGuidBytes(guid, 7, 3, 6);

    SendDirectMessage(&data);
}

void Player::SendDuelCountdown(uint32 counter)
{
    WorldPacket data(SMSG_DUEL_COUNTDOWN, 4);
    data << uint32(counter);                                // seconds
    GetSession()->SendPacket(&data);
}

void Player::AddRefundReference(uint32 it)
{
    m_refundableItems.insert(it);
}

void Player::DeleteRefundReference(uint32 it)
{
    std::set<uint32>::iterator itr = m_refundableItems.find(it);
    if (itr != m_refundableItems.end())
    {
        m_refundableItems.erase(itr);
    }
}

void Player::SendRefundInfo(Item* item)
{
    // This function call unsets ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
    item->UpdatePlayedTime(this);

    if (!item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: item not refundable!");
        return;
    }

    if (GetGUIDLow() != item->GetRefundRecipient()) // Formerly refundable item got traded
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: item was traded!");
        item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
    if (!iece)
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: cannot find extendedcost data.");
        return;
    }

    ObjectGuid guid = item->GetGUID();
    WorldPacket data(SMSG_SET_ITEM_PURCHASE_DATA, 8 + 4 + 4 + 4 + 4 * 4 + 4 * 4 + 4 + 4);
    data.WriteGuidMask(guid, 1, 5, 6, 0, 7, 2, 3, 4);
    data.FlushBits();

    data << uint32(item->GetPaidMoney());               // money cost
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)                             // item cost data
    {
        data << uint32(iece->RequiredItemCount[i]);
        data << uint32(iece->RequiredItem[i]);
    }

    data.WriteGuidBytes(guid, 1, 6, 4);
    data << uint32(item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
    data.WriteGuidBytes(guid, 5);
    data << uint32(0);

    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)                       // currency cost data
    {
        if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
        {
            data << uint32(0);
            data << uint32(0);
            continue;
        }

        CurrencyTypesEntry const* currencyType = sCurrencyTypesStore.LookupEntry(iece->RequiredCurrency[i]);
        uint32 precision = (currencyType && currencyType->Flags & CURRENCY_FLAG_HIGH_PRECISION) ? CURRENCY_PRECISION : 1;

        data << uint32(iece->RequiredCurrencyCount[i] / precision);
        data << uint32(iece->RequiredCurrency[i]);
    }

    data.WriteGuidBytes(guid, 3, 7, 2, 0);

    GetSession()->SendPacket(&data);
}

bool Player::AddItem(uint32 itemId, uint32 count)
{
    uint32 noSpaceForCount = 0;
    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &noSpaceForCount);
    if (msg != EQUIP_ERR_OK)
        count -= noSpaceForCount;

    if (count == 0 || dest.empty())
    {
        /// @todo Send to mailbox if no space
        ChatHandler(GetSession()).PSendSysMessage("You don't have any space in your bags.");
        return false;
    }

    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
    if (item)
    {
        SendNewItem(item, count, true, false);
        sScriptMgr->OnItemPickup(this, item, ItemPickupSourceType::Unknown, 0);
    }
    else
        return false;
    return true;
}

void Player::SendItemRefundResult(Item* item, ItemExtendedCostEntry const* iece, uint8 error)
{
    ObjectGuid guid = item->GetGUID();
    WorldPacket data(SMSG_ITEM_PURCHASE_REFUND_RESULT, 1 + 1 + 8 + 4 * 8 + 4 + 4 * 8);
    data.WriteGuidMask(guid, 3, 1, 5, 6, 4, 0, 7);
    data.WriteBit(!error);
    data.WriteGuidMask(guid, 2);

    data.FlushBits();

    data << uint8(error);
    data.WriteGuidBytes(guid, 5, 3);
    if (!error)
    {
        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
            {
                data << uint32(0);
                data << uint32(0);
                continue;
            }

            data << uint32(iece->RequiredCurrencyCount[i]);
            data << uint32(iece->RequiredCurrency[i]);
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i) // item cost data
        {
            data << uint32(iece->RequiredItemCount[i]);
            data << uint32(iece->RequiredItem[i]);
        }

        data << uint32(item->GetPaidMoney());               // money cost
    }
    data.WriteGuidBytes(guid, 1, 7, 4, 6, 0, 2);

    GetSession()->SendPacket(&data);
}

void Player::RefundItem(Item* item)
{
    if (!item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: item not refundable!");
        return;
    }

    if (item->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME) + 2 * HOUR < GetTotalPlayedTime())    // item refund has expired
    {
        item->SetNotRefundable(this);
        SendItemRefundResult(item, NULL, 10);
        return;
    }

    if (GetGUIDLow() != item->GetRefundRecipient()) // Formerly refundable item got traded
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: item was traded!");
        item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
    if (!iece)
    {
        TC_LOG_DEBUG("entities.player.items", "Item refund: cannot find extendedcost data.");
        return;
    }

    bool store_error = false;
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
    {
        uint32 count = iece->RequiredItemCount[i];
        uint32 itemid = iece->RequiredItem[i];

        if (count && itemid)
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
            if (msg != EQUIP_ERR_OK)
            {
                store_error = true;
                break;
            }
        }
    }

    if (store_error)
    {
        SendItemRefundResult(item, iece, 10);
        return;
    }

    if (GetSession()->HasFlag(ACC_FLAG_ITEM_LOG))
        logs::ItemLog(this, item, item->GetCount(), "Refund");

    SendItemRefundResult(item, iece, 0);

    uint32 moneyRefund = item->GetPaidMoney();  // item-> will be invalidated in DestroyItem

    // Save all relevant data to DB to prevent desynchronisation exploits
    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    // Delete any references to the refund data
    item->SetNotRefundable(this, true, trans);

    // Destroy item
    DestroyItem(item->GetBagSlot(), item->GetSlot(), true);

    // Grant back extendedcost items
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
    {
        uint32 count = iece->RequiredItemCount[i];
        uint32 itemid = iece->RequiredItem[i];
        if (count && itemid)
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
            ASSERT(msg == EQUIP_ERR_OK); /// Already checked before
            Item* it = StoreNewItem(dest, itemid, true);
            SendNewItem(it, count, true, false, true);
            sScriptMgr->OnItemPickup(this, it, ItemPickupSourceType::ItemRefund, item->GetEntry());
        }
    }

    // Grant back currencies
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
    {
        if (iece->RequirementFlags & (ITEM_EXT_COST_CURRENCY_REQ_IS_SEASON_EARNED_1 << i))
            continue;

        uint32 count = iece->RequiredCurrencyCount[i];
        uint32 currencyid = iece->RequiredCurrency[i];
        if (count && currencyid)
            ModifyCurrency(currencyid, count, false, true, true);
    }

    // Grant back money
    if (moneyRefund)
        ModifyMoney(moneyRefund); // Saved in SaveInventoryAndGoldToDB

    SaveInventoryAndGoldToDB(trans);

    CharacterDatabase.CommitTransaction(trans);
}

void Player::SetRandomWinner(bool isWinner)
{
    m_IsBGRandomWinner = isWinner;
    if (m_IsBGRandomWinner)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_BATTLEGROUND_RANDOM);

        stmt->setUInt32(0, GetGUIDLow());

        CharacterDatabase.Execute(stmt);
    }
}

void Player::_LoadRandomBGStatus(PreparedQueryResult result)
{
    //QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());

    if (result)
        m_IsBGRandomWinner = true;
}

void Player::SetBgWeekendWinner(bool isWinner)
{
    m_IsBGWeekendWinner = isWinner;
    if (m_IsBGWeekendWinner)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_BATTLEGROUND_WEEKEND);

        stmt->setUInt32(0, GetGUIDLow());

        CharacterDatabase.Execute(stmt);
    }
}

void Player::_LoadWeekendBGStatus(PreparedQueryResult result)
{
    // QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM character_battleground_weekend WHERE guid = '%u'", GetGUIDLow());

    if (result)
        m_IsBGWeekendWinner = true;
}

static bool IsTwoHandWeapon(ItemTemplate const* proto)
{
    switch (proto->SubClass)
    {
        case ITEM_SUBCLASS_WEAPON_AXE2:
        case ITEM_SUBCLASS_WEAPON_BOW:
        case ITEM_SUBCLASS_WEAPON_GUN:
        case ITEM_SUBCLASS_WEAPON_MACE2:
        case ITEM_SUBCLASS_WEAPON_POLEARM:
        case ITEM_SUBCLASS_WEAPON_SWORD2:
        case ITEM_SUBCLASS_WEAPON_STAFF:
        case ITEM_SUBCLASS_WEAPON_SPEAR:
        case ITEM_SUBCLASS_WEAPON_CROSSBOW:
        case ITEM_SUBCLASS_WEAPON_FISHING_POLE:
            return true;
        default:
            break;
    }
    return false;
}

float Player::GetAverageItemLevel()
{
    float sum = 0;
    uint32 count = 0;

    for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // don't check tabard, ranged, offhand or shirt
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        if (i == EQUIPMENT_SLOT_OFFHAND && !m_items[i])
            if (m_items[EQUIPMENT_SLOT_MAINHAND] && IsTwoHandWeapon(m_items[EQUIPMENT_SLOT_MAINHAND]->GetTemplate()))
                continue;

        if (m_items[i] && m_items[i]->GetTemplate())
            sum += m_items[i]->GetItemLevel();

        ++count;
    }

    return ((float)sum) / count;
}

void Player::_LoadInstanceTimeRestrictions(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        _instanceResetTimes.insert(InstanceTimeMap::value_type(fields[0].GetUInt32(), fields[1].GetUInt64()));
    } while (result->NextRow());
}

void Player::_SaveInstanceTimeRestrictions(SQLTransaction& trans)
{
    if (_instanceResetTimes.empty())
        return;

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACCOUNT_INSTANCE_LOCK_TIMES);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    trans->Append(stmt);

    for (InstanceTimeMap::const_iterator itr = _instanceResetTimes.begin(); itr != _instanceResetTimes.end(); ++itr)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ACCOUNT_INSTANCE_LOCK_TIMES);
        stmt->setUInt32(0, GetSession()->GetAccountId());
        stmt->setUInt32(1, itr->first);
        stmt->setUInt64(2, itr->second);
        trans->Append(stmt);
    }
}

bool Player::IsInWhisperWhiteList(uint64 guid)
{
    for (WhisperListContainer::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
        if (*itr == guid)
            return true;

    return false;
}

uint8 Player::GetNextVoidStorageFreeSlot() const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i]) // unused item
            return i;

    return VOID_STORAGE_MAX_SLOT;
}

uint8 Player::GetNumOfVoidStorageFreeSlots() const
{
    uint8 count = 0;

    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i])
            count++;

    return count;
}

uint8 Player::AddVoidStorageItem(const VoidStorageItem& item)
{
    int8 slot = GetNextVoidStorageFreeSlot();

    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return 255;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemEntry,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.ItemUpgradeId);
    return slot;
}

void Player::AddVoidStorageItemAtSlot(uint8 slot, const VoidStorageItem& item)
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return;
    }

    if (_voidStorageItems[slot])
    {
        TC_LOG_ERROR("misc", "Player::AddVoidStorageItemAtSlot - Player (GUID: %u, name: %s) tried to add an item to an used slot (item id: " UI64FMTD ", entry: %u, slot: %u).", GetGUIDLow(), GetName().c_str(), _voidStorageItems[slot]->ItemId, _voidStorageItems[slot]->ItemEntry, slot);
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    _voidStorageItems[slot] = new VoidStorageItem(item.ItemId, item.ItemId,
        item.CreatorGuid, item.ItemRandomPropertyId, item.ItemSuffixFactor, item.ItemUpgradeId);
}

void Player::DeleteVoidStorageItem(uint8 slot)
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    delete _voidStorageItems[slot];
    _voidStorageItems[slot] = NULL;
}

bool Player::SwapVoidStorageItem(uint8 oldSlot, uint8 newSlot)
{
    if (oldSlot >= VOID_STORAGE_MAX_SLOT || newSlot >= VOID_STORAGE_MAX_SLOT || oldSlot == newSlot)
        return false;

    std::swap(_voidStorageItems[newSlot], _voidStorageItems[oldSlot]);
    return true;
}

VoidStorageItem* Player::GetVoidStorageItem(uint8 slot) const
{
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return NULL;
    }

    return _voidStorageItems[slot];
}

VoidStorageItem* Player::GetVoidStorageItem(uint64 id, uint8& slot) const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemId == id)
        {
            slot = i;
            return _voidStorageItems[i];
        }
    }

    return NULL;
}

void Player::SendMovementSetCanTransitionBetweenSwimAndFly(bool apply)
{
    Movement::PacketSender(this, NULL_OPCODE, apply ?
        SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY :
        SMSG_MOVE_UNSET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY).Send();
}

void Player::SendMovementSetCollisionHeight(float height)
{
    static MovementStatusElements const extraElements [] = { MSEExtraFloat, MSEExtraFloat2 };
    Movement::ExtraMovementStatusElement extra(extraElements);
    extra.Data.floatData = height;
    extra.Data.floatData2 = 1;
    Movement::PacketSender(this, NULL_OPCODE, SMSG_MOVE_SET_COLLISION_HEIGHT, NULL_OPCODE, &extra).Send();

    Movement::ExtraMovementStatusElement extra1(extraElements);
    extra1.Data.floatData = 1;
    extra1.Data.floatData2 = height;
    Movement::PacketSender(this, NULL_OPCODE, NULL_OPCODE, SMSG_MOVE_UPDATE_COLLISION_HEIGHT, &extra1).Send();
}

float Player::GetCollisionHeight(bool mounted) const
{
    if (mounted)
    {
        CreatureDisplayInfoEntry const* mountDisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID));
        if (!mountDisplayInfo)
            return GetCollisionHeight(false);

        CreatureModelDataEntry const* mountModelData = sCreatureModelDataStore.LookupEntry(mountDisplayInfo->ModelId);
        if (!mountModelData)
            return GetCollisionHeight(false);

        CreatureDisplayInfoEntry const* displayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT(displayInfo);
        CreatureModelDataEntry const* modelData = sCreatureModelDataStore.LookupEntry(displayInfo->ModelId);
        ASSERT(modelData);

        float scaleMod = GetObjectScale(); // 99% sure about this

        return displayInfo->scale * (mountDisplayInfo->scale * mountModelData->MountHeight + modelData->CollisionHeight * 0.5f);
    }
    else
    {
        //! Dismounting case - use basic default model data
        CreatureDisplayInfoEntry const* displayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT(displayInfo);
        CreatureModelDataEntry const* modelData = sCreatureModelDataStore.LookupEntry(displayInfo->ModelId);
        ASSERT(modelData);

        return modelData->CollisionHeight;
    }
}

void Player::SendApplyMovementForce(bool apply, Position const &source, float force /*= 0.0f*/)
{
    ObjectGuid playerGuid = GetGUID();

    if (apply)
    {
        // Forced movement can cumulate
        if (HasForcedMovement())
            return;

        WorldPacket data(SMSG_MOVE_APPLY_MOVEMENT_FORCE, 1 + 8 + 7 * 4);

        data.WriteBit(playerGuid[2]);
        data.WriteBit(playerGuid[3]);
        data.WriteBits(1, 2);
        data.WriteBit(playerGuid[7]);
        data.WriteBit(playerGuid[5]);
        data.WriteBit(playerGuid[0]);
        data.WriteBit(playerGuid[1]);
        data.WriteBit(playerGuid[6]);
        data.WriteBit(playerGuid[4]);

        data.FlushBits();

        data.WriteByteSeq(playerGuid[6]);
        data << float(source.GetPositionY());
        data.WriteByteSeq(playerGuid[4]);
        data << float(source.GetPositionZ());
        data << m_movementCounter++;                         // Counter
        data << uint32(268441055);                           // Unk
        data.WriteByteSeq(playerGuid[5]);
        data << float(force);
        data.WriteByteSeq(playerGuid[0]);
        data.WriteByteSeq(playerGuid[7]);
        data.WriteByteSeq(playerGuid[1]);
        data.WriteByteSeq(playerGuid[3]);
        data.WriteByteSeq(playerGuid[2]);
        data << uint32(0);                                   // Unk
        data << float(source.GetPositionX());

        SendDirectMessage(&data);

        hasForcedMovement_ = true;
    }
    else
    {
        if (!HasForcedMovement())
            return;

        WorldPacket data(SMSG_MOVE_REMOVE_MOVEMENT_FORCE, 2 * 4 + 1 + 8);

        uint8 bitValues[8] = { 1, 2, 4, 7, 6, 0, 5, 3 };
        data.WriteBitInOrder(playerGuid, bitValues);

        data.FlushBits();

        data.WriteByteSeq(playerGuid[4]);
        data.WriteByteSeq(playerGuid[7]);
        data.WriteByteSeq(playerGuid[0]);
        data << m_movementCounter++;                         // Counter
        data.WriteByteSeq(playerGuid[1]);
        data.WriteByteSeq(playerGuid[3]);
        data.WriteByteSeq(playerGuid[5]);
        data << uint32(268441055);                           // Unk
        data.WriteByteSeq(playerGuid[6]);
        data.WriteByteSeq(playerGuid[2]);

        SendDirectMessage(&data);

        hasForcedMovement_ = false;
    }
}

std::string Player::GetMapAreaAndZoneString()
{
    uint32 areaId = GetAreaId();
    std::string areaName = "Unknown";
    std::string zoneName = "Unknown";
    if (AreaTableEntry const* area = sAreaTableStore.LookupEntry(areaId))
    {
        int locale = GetSession()->GetSessionDbcLocale();
        areaName = area->area_name[locale];
        if (AreaTableEntry const* zone = sAreaTableStore.LookupEntry(area->zone))
            zoneName = zone->area_name[locale];
    }

    std::ostringstream str;
    str << "Map: " << GetMapId() << " (" << (FindMap() ? FindMap()->GetMapName() : "Unknown") << ") Area: " << areaId << " (" << areaName.c_str() << ") Zone: " << zoneName.c_str();
    return str.str();
}

std::string Player::GetCoordsMapAreaAndZoneString()
{
    std::ostringstream str;
    str << Position::ToString() << " " << GetMapAreaAndZoneString();
    return str.str();
}

Guild* Player::GetGuild()
{
    uint32 guildId = GetGuildId();
    return guildId ? sGuildMgr->GetGuildById(guildId) : NULL;
}

Pet* Player::SummonPet(uint32 entry, float x, float y, float z, float ang, uint32 duration)
{
    // petentry == 0 for hunter "call pet" (current pet summoned if any)
    ASSERT(entry);

    Pet* pet = new Pet(this, SUMMON_PET);
    if (pet->LoadPetFromDB(PET_LOAD_BY_ENTRY, entry))
    {
        // Remove Demonic Sacrifice auras (known pet)
        Unit::AuraEffectList const& auraClassScripts = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
        for (Unit::AuraEffectList::const_iterator itr = auraClassScripts.begin(); itr != auraClassScripts.end();)
        {
            if ((*itr)->GetMiscValue() == 2228)
            {
                RemoveAurasDueToSpell((*itr)->GetId());
                itr = auraClassScripts.begin();
            }
            else
                ++itr;
        }

        if (duration > 0)
            pet->SetDuration(duration);

        return nullptr;
    }

    pet->Relocate(x, y, z, ang);
    if (!pet->IsPositionValid())
    {
        TC_LOG_ERROR("misc", "Pet (guidlow %d, entry %d) not summoned. Suggested coordinates isn't valid (X: %f Y: %f)", pet->GetGUIDLow(), pet->GetEntry(), pet->GetPositionX(), pet->GetPositionY());
        delete pet;
        return NULL;
    }

    Map* map = GetMap();
    uint32 pet_number = sObjectMgr->GeneratePetNumber();
    if (!pet->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_PET), map, GetPhaseMask(), entry, pet_number))
    {
        TC_LOG_ERROR("misc", "no such creature entry %u", entry);
        delete pet;
        return NULL;
    }

    pet->AddToTransportIfNeeded(GetTransport());

    pet->SetCreatorGUID(GetGUID());
    pet->SetUInt32Value(UNIT_FIELD_FACTION_TEMPLATE, getFaction());

    pet->SetPowerType(POWER_MANA);
    pet->SetUInt32Value(UNIT_FIELD_NPC_FLAGS, 0);
    pet->SetUInt32Value(UNIT_FIELD_ANIM_TIER, 0);
    pet->InitStatsForLevel(getLevel());

    SetMinion(pet, true);

    // this enables pet details window (Shift+P)
    pet->GetCharmInfo()->SetPetNumber(pet_number, true);
    pet->SetClass(CLASS_MAGE);
    pet->SetUInt32Value(UNIT_FIELD_PET_EXPERIENCE, 0);
    pet->SetUInt32Value(UNIT_FIELD_PET_NEXT_LEVEL_EXPERIENCE, 1000);
    pet->SetFullHealth();
    pet->SetPower(POWER_MANA, pet->GetMaxPower(POWER_MANA));
    pet->SetUInt32Value(UNIT_FIELD_PET_NAME_TIMESTAMP, uint32(time(NULL))); // cast can't be helped in this case

    map->AddToMap(pet->ToCreature());

    pet->InitPetCreateSpells();
    pet->InitTalentForLevel();
    PetSpellInitialize();

    // Remove Demonic Sacrifice auras (known pet)
    Unit::AuraEffectList const& auraClassScripts = GetAuraEffectsByType(SPELL_AURA_OVERRIDE_CLASS_SCRIPTS);
    for (Unit::AuraEffectList::const_iterator itr = auraClassScripts.begin(); itr != auraClassScripts.end();)
    {
        if ((*itr)->GetMiscValue() == 2228)
        {
            RemoveAurasDueToSpell((*itr)->GetId());
            itr = auraClassScripts.begin();
        }
        else
            ++itr;
    }

    if (duration > 0)
        pet->SetDuration(duration);

    return pet;
}

bool Player::CanUseMastery() const
{
    return HasSpell(MasterySpells[getClass()]);
}

void Player::ReadyCheckComplete()
{
    Group* group = GetGroup();
    if (!group)
        return;

    if (group->ReadyCheckInitiator() != GetGUID())
        return;

    _readyCheckTimer = 0;

    group->ReadyCheck(0);
    group->ReadyCheckResetResponded();
    group->SendReadyCheckCompleted();
}

uint32 Player::GetQuestObjectiveCounter(uint32 objectiveId) const
{
    QuestObjectiveStatusMap::const_iterator citr = m_questObjectiveStatus.find(objectiveId);
    if (citr != m_questObjectiveStatus.end())
        return citr->second;

    return 0;
}

void Player::ReadMovementInfo(WorldPacket& data, MovementInfo* mi, Movement::ExtraMovementStatusElement* extras /*= NULL*/, bool beforeAnticheat)
{
    MovementStatusElements const* sequence = GetMovementStatusElementsSequence(data.GetOpcode());
    if (!sequence)
    {
        TC_LOG_ERROR("network", "Player::ReadMovementInfo: No movement sequence found for opcode %s", GetOpcodeNameForLogging(data.GetOpcode(), false).c_str());
        return;
    }

    bool hasMountDisplayId = false;
    bool hasMovementFlags = false;
    bool hasMovementFlags2 = false;
    bool hasTimestamp = false;
    bool hasOrientation = false;
    bool hasTransportData = false;
    bool hasTransportTime2 = false;
    bool hasTransportTime3 = false;
    bool hasPitch = false;
    bool hasFallData = false;
    bool hasFallDirection = false;
    bool hasSplineElevation = false;
    bool hasCounter = false;
    uint32 forcesCount = 0u;

    ObjectGuid guid;
    ObjectGuid tguid;

    for (; *sequence != MSEEnd; ++sequence)
    {
        MovementStatusElements const& element = *sequence;

        switch (element)
        {
            case MSEHasGuidByte0:
            case MSEHasGuidByte1:
            case MSEHasGuidByte2:
            case MSEHasGuidByte3:
            case MSEHasGuidByte4:
            case MSEHasGuidByte5:
            case MSEHasGuidByte6:
            case MSEHasGuidByte7:
                guid[element - MSEHasGuidByte0] = data.ReadBit();
                break;
            case MSEHasTransportGuidByte0:
            case MSEHasTransportGuidByte1:
            case MSEHasTransportGuidByte2:
            case MSEHasTransportGuidByte3:
            case MSEHasTransportGuidByte4:
            case MSEHasTransportGuidByte5:
            case MSEHasTransportGuidByte6:
            case MSEHasTransportGuidByte7:
                if (hasTransportData)
                    tguid[element - MSEHasTransportGuidByte0] = data.ReadBit();
                break;
            case MSEGuidByte0:
            case MSEGuidByte1:
            case MSEGuidByte2:
            case MSEGuidByte3:
            case MSEGuidByte4:
            case MSEGuidByte5:
            case MSEGuidByte6:
            case MSEGuidByte7:
                data.ReadByteSeq(guid[element - MSEGuidByte0]);
                break;
            case MSETransportGuidByte0:
            case MSETransportGuidByte1:
            case MSETransportGuidByte2:
            case MSETransportGuidByte3:
            case MSETransportGuidByte4:
            case MSETransportGuidByte5:
            case MSETransportGuidByte6:
            case MSETransportGuidByte7:
                if (hasTransportData)
                    data.ReadByteSeq(tguid[element - MSETransportGuidByte0]);
                break;
            case MSEHasMovementFlags:
                hasMovementFlags = !data.ReadBit();
                break;
            case MSEHasMovementFlags2:
                hasMovementFlags2 = !data.ReadBit();
                break;
            case MSEHasTimestamp:
                hasTimestamp = !data.ReadBit();
                break;
            case MSEHasOrientation:
                hasOrientation = !data.ReadBit();
                break;
            case MSEHasTransportData:
                hasTransportData = data.ReadBit();
                break;
            case MSEHasTransportTime2:
                if (hasTransportData)
                    hasTransportTime2 = data.ReadBit();
                break;
            case MSEHasTransportTime3:
                if (hasTransportData)
                    hasTransportTime3 = data.ReadBit();
                break;
            case MSEHasPitch:
                hasPitch = !data.ReadBit();
                break;
            case MSEHasFallData:
                hasFallData = data.ReadBit();
                break;
            case MSEHasFallDirection:
                if (hasFallData)
                    hasFallDirection = data.ReadBit();
                break;
            case MSEHasSplineElevation:
                hasSplineElevation = !data.ReadBit();
                break;
            case MSEHasSpline:
                data.ReadBit();
                break;
            case MSEHasMountDisplayId:
                hasMountDisplayId = !data.ReadBit();
                break;
            case MSEMountDisplayIdWithCheck: // Fallback here
                if (!hasMountDisplayId)
                    break;
            case MSEMountDisplayIdWithoutCheck:
            {
                uint32 mountDisplayId;
                data >> mountDisplayId;
                SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, mountDisplayId);
                break;
            }
            case MSEMovementFlags:
                if (hasMovementFlags)
                    mi->flags = data.ReadBits(30);
                break;
            case MSEMovementFlags2:
                if (hasMovementFlags2)
                    mi->flags2 = data.ReadBits(13);
                break;
            case MSETimestamp:
                if (hasTimestamp)
                    data >> mi->time;
                break;
            case MSEPositionX:
                data >> mi->pos.m_positionX;
                break;
            case MSEPositionY:
                data >> mi->pos.m_positionY;
                break;
            case MSEPositionZ:
                data >> mi->pos.m_positionZ;
                break;
            case MSEOrientation:
                if (hasOrientation)
                    mi->pos.SetOrientation(data.read<float>());
                break;
            case MSETransportPositionX:
                if (hasTransportData)
                    data >> mi->transport.pos.m_positionX;
                break;
            case MSETransportPositionY:
                if (hasTransportData)
                    data >> mi->transport.pos.m_positionY;
                break;
            case MSETransportPositionZ:
                if (hasTransportData)
                    data >> mi->transport.pos.m_positionZ;
                break;
            case MSETransportOrientation:
                if (hasTransportData)
                    mi->transport.pos.SetOrientation(data.read<float>());
                break;
            case MSETransportSeat:
                if (hasTransportData)
                    data >> mi->transport.seat;
                break;
            case MSETransportTime:
                if (hasTransportData)
                    data >> mi->transport.time;
                break;
            case MSETransportTime2:
                if (hasTransportData && hasTransportTime2)
                    data >> mi->transport.time2;
                break;
            case MSETransportTime3:
                if (hasTransportData && hasTransportTime3)
                    data >> mi->transport.time3;
                break;
            case MSEPitch:
                if (hasPitch)
                    mi->pitch = G3D::wrap(data.read<float>(), float(-M_PI), float(M_PI));
                break;
            case MSEFallTime:
                if (hasFallData)
                    data >> mi->jump.fallTime;
                break;
            case MSEFallVerticalSpeed:
                if (hasFallData)
                    data >> mi->jump.zspeed;
                break;
            case MSEFallCosAngle:
                if (hasFallData && hasFallDirection)
                    data >> mi->jump.cosAngle;
                break;
            case MSEFallSinAngle:
                if (hasFallData && hasFallDirection)
                    data >> mi->jump.sinAngle;
                break;
            case MSEFallHorizontalSpeed:
                if (hasFallData && hasFallDirection)
                    data >> mi->jump.xyspeed;
                break;
            case MSESplineElevation:
                if (hasSplineElevation)
                    data >> mi->splineElevation;
                break;
            case MSEForcesCount:
                forcesCount = data.ReadBits(22);
                break;
            case MSEForces:
                for (uint32 i = 0; i < forcesCount; i++)
                    data.read_skip<uint32>();
                break;
            case MSEHasCounter:
                hasCounter = !data.ReadBit();
                break;
            case MSECounter:
                if (hasCounter)
                    data.read_skip<uint32>();
                break;
            case MSECount:
                data.read_skip<uint32>();
                break;
            case MSEZeroBit:
            case MSEOneBit:
                data.ReadBit();
                break;
            case MSEExtraElement:
                extras->ReadNextElement(data);
                break;
            default:
                ASSERT(Movement::PrintInvalidSequenceElement(element, __FUNCTION__));
                break;
        }
    }

    mi->guid = guid;
    mi->transport.guid = tguid;

    SanitizeMovementInfo(mi, !beforeAnticheat);
}

void Player::SanitizeMovementInfo(MovementInfo* mi, bool afterAnticheat)
{
    //! Anti-cheat checks. Please keep them in seperate if () blocks to maintain a clear overview.
    //! Might be subject to latency, so just remove improper flags.
    #ifdef TRINITY_DEBUG
    #define REMOVE_VIOLATING_FLAGS(check, maskToRemove) \
    { \
        if (check) \
        { \
            TC_LOG_DEBUG("entities.unit", "Player::ReadMovementInfo: Violation of MovementFlags found (%s). " \
                "MovementFlags: %u, MovementFlags2: %u for player GUID: %u. Mask %u will be removed.", \
                STRINGIZE(check), mi->GetMovementFlags(), mi->GetExtraMovementFlags(), GetGUIDLow(), maskToRemove); \
            mi->RemoveMovementFlag((maskToRemove)); \
        } \
    }
    #else
    #define REMOVE_VIOLATING_FLAGS(check, maskToRemove) \
        if (check) \
            mi->RemoveMovementFlag((maskToRemove));
    #endif

    /*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
        in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
        It will freeze clients that receive this player's movement info.
    */

    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ROOT),
        MOVEMENTFLAG_ROOT);

    //! Cannot hover without SPELL_AURA_HOVER
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_HOVER) && !HasAuraType(SPELL_AURA_HOVER),
        MOVEMENTFLAG_HOVER);

    //! Cannot ascend and descend at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ASCENDING) && mi->HasMovementFlag(MOVEMENTFLAG_DESCENDING),
        MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING);

    //! Cannot move left and right at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_RIGHT),
        MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT);

    //! Cannot strafe left and right at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_RIGHT),
        MOVEMENTFLAG_STRAFE_LEFT | MOVEMENTFLAG_STRAFE_RIGHT);

    //! Cannot pitch up and down at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_PITCH_UP) && mi->HasMovementFlag(MOVEMENTFLAG_PITCH_DOWN),
        MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN);

    //! Cannot move forwards and backwards at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FORWARD) && mi->HasMovementFlag(MOVEMENTFLAG_BACKWARD),
        MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_BACKWARD);

    // Keep the following flags until later, we need them in order to trigger anticheat alerts
    if (!afterAnticheat)
        return;

    //! Cannot walk on water without SPELL_AURA_WATER_WALK
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_WATERWALKING) && !HasAuraType(SPELL_AURA_WATER_WALK),
        MOVEMENTFLAG_WATERWALKING);

    if (mi->HasMovementFlag(MOVEMENTFLAG_FALLING_SLOW) && !HasAuraType(SPELL_AURA_FEATHER_FALL))
        SetFeatherFall(false);

    //! Cannot feather fall without SPELL_AURA_FEATHER_FALL
    //REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FALLING_SLOW) && !HasAuraType(SPELL_AURA_FEATHER_FALL),
    //    MOVEMENTFLAG_FALLING_SLOW);

    /*! Cannot fly if no fly auras present. Exception is being a GM.
        Note that we check for account level instead of Player::IsGameMaster() because in some
        situations it may be feasable to use .gm fly on as a GM without having .gm on,
        e.g. aerial combat.
    */

    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FLYING | MOVEMENTFLAG_CAN_FLY) && ToPlayer()->GetSession()->GetSecurity() == SEC_PLAYER &&
        !ToPlayer()->m_mover->HasAuraType(SPELL_AURA_FLY) &&
        !ToPlayer()->m_mover->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED),
        MOVEMENTFLAG_FLYING | MOVEMENTFLAG_CAN_FLY);

    //! Cannot fly and fall at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_DISABLE_GRAVITY | MOVEMENTFLAG_CAN_FLY) && mi->HasMovementFlag(MOVEMENTFLAG_FALLING),
        MOVEMENTFLAG_FALLING);

    // fixme
    /*REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FALLING) && (!hasFallData || !hasFallDirection), MOVEMENTFLAG_FALLING);

    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION) &&
        (!hasSplineElevation || G3D::fuzzyEq(mi->splineElevation, 0.0f)), MOVEMENTFLAG_SPLINE_ELEVATION);

    // Client first checks if spline elevation != 0, then verifies flag presence
    if (hasSplineElevation)
        mi->AddMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION);*/

    #undef REMOVE_VIOLATING_FLAGS
}

void Player::SaveResearchDigsiteToDB(ResearchDigsite* digsite)
{
    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    // DELETE FROM character_research_digsites WHERE guid = ? AND digsiteId = ?
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt32(1, digsite->GetDigsiteId());
    trans->Append(stmt);

    // INSERT INTO character_research_digsites (guid, digsiteId, currentFindGUID, remainingFindCount) VALUES (?, ?, ?, ?)
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_RESEARCH_DIGSITE);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt32(1, digsite->GetDigsiteId());
    if (ArchaeologyFindInfo const* find = digsite->GetArchaeologyFind())
        stmt->setUInt32(2, find->guid);
    else
        stmt->setUInt32(2, 0);

    stmt->setUInt8(3, digsite->GetRemainingFindCount());
    trans->Append(stmt);
    CharacterDatabase.CommitTransaction(trans, DBConnection::Player);
}

void Player::DeleteResearchDigsite(ResearchDigsite* digsite)
{
    // DELETE FROM character_research_digsites WHERE guid = ? AND digsiteId = ?
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt32(1, digsite->GetDigsiteId());
    CharacterDatabase.Execute(stmt, DBConnection::Player);

    delete digsite;
}

static int32 GetDigsiteIndexForMap(uint32 map)
{
    for (int32 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        if (ResearchContinents[i] == map)
            return i;
    return -1;
};

void Player::_LoadResearchDigsites(PreparedQueryResult result)
{
    if (!result)
        return;

    std::vector<ResearchDigsite*> tempDigsite[RESEARCH_CONTINENT_COUNT];

    do
    {
        // SELECT digsiteId, currentFindGUID, remainingFindCount FROM character_research_digsites WHERE guid = ?
        Field* fields = result->Fetch();

        uint32 digsiteId = fields[0].GetUInt32();
        ResearchDigsiteInfo const* digsiteInfo = sObjectMgr->GetResearchDigsiteInfo(digsiteId);
        ResearchSiteEntry const* digsiteEntry = sResearchSiteStore.LookupEntry(digsiteId);
        if (!digsiteInfo || !digsiteEntry)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchDigsites - Player %s (GUID: %u) is trying to load non existing digsite %u. Deleting digsite.", GetName().c_str(), GetGUIDLow(), digsiteId);
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, digsiteId);
            CharacterDatabase.Execute(stmt);
            continue;
        }

        int32 index = GetDigsiteIndexForMap(digsiteEntry->MapId);
        if (index == -1)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchDigsites - Player %s (GUID: %u) is trying to load digsite %u with invalid map id %u.", GetName().c_str(), GetGUIDLow(), digsiteId, digsiteEntry->MapId);
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, digsiteId);
            CharacterDatabase.Execute(stmt);
            continue;
        }

        if (tempDigsite[index].size() >= MAX_DIGSITES_PER_CONTINENT)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchDigsites - Player %s (GUID: %u) is trying to load digsite %u with map id %u, but he has already %u active digsites in the map. Deleting digsite.", GetName().c_str(),
                         GetGUIDLow(), digsiteId, digsiteEntry->MapId, MAX_DIGSITES_PER_CONTINENT);
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_DIGSITE);
            stmt->setUInt32(0, GetGUIDLow());
            stmt->setUInt32(1, digsiteId);
            CharacterDatabase.Execute(stmt);
            continue;
        }

        uint32 currentFindGUID = fields[1].GetUInt32();
        uint32 remainingFindCount = fields[2].GetUInt8();
        ResearchDigsite* digsite = new ResearchDigsite(digsiteInfo, remainingFindCount);
        /* Temporary
        if (ArchaeologyFindInfo const* find = sObjectMgr->GetArchaeologyFindInfo(currentFindGUID, digsiteId))
            digsite->ChangeArchaeologyFind(find);
        else
        */
        {
            digsite->SelectNewArchaeologyFind(true);
            /*
            SaveResearchDigsiteToDB(digsite);
            */
        }

        tempDigsite[index].push_back(digsite);
    }
    while (result->NextRow());

    for (size_t i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        for (size_t j = 0; j < tempDigsite[i].size(); ++j)
            _researchDigsites[i][j] = tempDigsite[i][j];
}

void Player::_LoadGuildInfo(PreparedQueryResult result)
{
    if (result)
    {
        Field* fields = result->Fetch();
        if (Guild* guild = sGuildMgr->GetGuildById(fields[0].GetUInt32()))
        {
            SetInGuild(guild->GetId());
            SetRank(fields[1].GetUInt8());
            SetGuildLevel(guild->GetLevel());

            if (!sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED))
                return;

            for (uint32 i = 0; i < sGuildPerkSpellsStore.GetNumRows(); ++i)
                if (GuildPerkSpellsEntry const* entry = sGuildPerkSpellsStore.LookupEntry(i))
                    if (entry->Level <= guild->GetLevel())
                        LearnSpell(entry->SpellId, true);
        }
    }
}

void Player::SendSurveryCastInfo(ResearchDigsite* digsite, bool success)
{
    if (!digsite)
        return;

    ResearchDigsiteInfo const* digsiteInfo = sObjectMgr->GetResearchDigsiteInfo(digsite->GetDigsiteId());

    WorldPacket data(SMSG_ARCHAEOLOGY_SURVERY_CAST, 13);
    data << uint32(MAX_FINDS_PER_DIGSITE);
    data << uint32(MAX_FINDS_PER_DIGSITE - digsite->GetRemainingFindCount());
    data << uint32(digsiteInfo->branchId);
    data.WriteBit(success);
    data.FlushBits();

    GetSession()->SendPacket(&data);
}

void Player::UpdateResearchDigsites()
{
    for (uint8 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
    {
        for (uint8 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
        {
            if (_researchDigsites[i][j] && (_researchDigsites[i][j]->IsEmptyDigsite() || !IsResearchDigsiteAvailable(_researchDigsites[i][j]->GetDigsiteInfo())))
            {
                // we need to spawn a new digsite before the old digsite is deleted, so there won't be a chance that the old digsite will be spawned again
                ResearchDigsite* newDigsite = TryToSpawnResearchDigsiteOnContinent(ResearchContinents[i]);
                DeleteResearchDigsite(_researchDigsites[i][j]);
                _researchDigsites[i][j] = newDigsite;
            }
            else if (!_researchDigsites[i][j])
                _researchDigsites[i][j] = TryToSpawnResearchDigsiteOnContinent(ResearchContinents[i]);

            if (_researchDigsites[i][j])
            {
                SetDynamicUInt32Value(PLAYER_DYNAMIC_FIELD_RESERACH_SITE, i * MAX_DIGSITES_PER_CONTINENT + j, _researchDigsites[i][j]->GetDigsiteId());
                SetDynamicUInt32Value(PLAYER_DYNAMIC_FIELD_RESEARCH_SITE_PROGRESS, i * MAX_DIGSITES_PER_CONTINENT + j, MAX_FINDS_PER_DIGSITE - _researchDigsites[i][j]->GetRemainingFindCount());
            }
        }
    }
}

void Player::RandomizeDigsites(uint32 map)
{
    int32 index = GetDigsiteIndexForMap(map);
    if (index != -1)
    {
        for (int32 i = 0; i < MAX_DIGSITES_PER_CONTINENT; ++i)
        {
            auto digsite = TryToSpawnResearchDigsiteOnContinent(map);
            if (_researchDigsites[index][i])
                DeleteResearchDigsite(_researchDigsites[index][i]);
            _researchDigsites[index][i] = digsite;
        }
    }

    UpdateResearchDigsites();
}

bool Player::SpawnDigsite(uint32 digsiteId)
{
    auto const* digsiteInfo = sObjectMgr->GetResearchDigsiteInfo(digsiteId);
    if (!digsiteInfo)
        return false;

    for (int32 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        for (int32 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
            if (_researchDigsites[i][j] && _researchDigsites[i][j]->GetDigsiteId() == digsiteId)
                return false;

    if (auto const* digiteEntry = sResearchSiteStore.LookupEntry(digsiteId))
    {
        int32 index = GetDigsiteIndexForMap(digiteEntry->MapId);
        if (index != -1)
        {
            if (_researchDigsites[index][0])
                DeleteResearchDigsite(_researchDigsites[index][0]);
            ResearchDigsite* digsite = new ResearchDigsite(digsiteInfo, MAX_FINDS_PER_DIGSITE);
            digsite->SelectNewArchaeologyFind(true);
            SaveResearchDigsiteToDB(digsite);
            _researchDigsites[index][0] = digsite;
            UpdateResearchDigsites();
            return true;
        }
    }
    return false;
}

bool Player::IsWithinResearchDigsite(ResearchDigsite* digsite)
{
    if (!digsite)
        return false;

    DigsitePOIPolygon const* polygon = GetDigsitePOIPolygon(digsite->GetDigsiteId());
    if (!polygon)
        return false;

    float x = GetPositionX();
    float y = GetPositionY();
    bool result = false;
    int j = polygon->size() - 1;
    for (uint32 i = 0; i < polygon->size(); j = i++)
    {
        if ((polygon->at(i).second < y && polygon->at(j).second >= y || polygon->at(j).second < y && polygon->at(i).second >= y) && (polygon->at(i).first <= x || polygon->at(j).first <= x))
            result ^= (polygon->at(i).first + (y - polygon->at(i).second) / (polygon->at(j).second - polygon->at(i).second) * (polygon->at(j).first - polygon->at(i).first) < x);
    }

    return result;
}

ResearchDigsite* Player::GetCurrentResearchDigsite()
{
    for (uint8 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
    {
        if (ResearchContinents[i] != GetMapId())
            continue;

        for (uint8 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
            if (ResearchDigsite* digsite = _researchDigsites[i][j])
                if (IsWithinResearchDigsite(digsite))
                    return digsite;
    }

    return NULL;
}

ResearchDigsite* Player::TryToSpawnResearchDigsiteOnContinent(uint32 mapId)
{
    ResearchDigsiteInfo const* digsiteInfo = GetRandomResearchDigsiteForContinent(mapId);
    if (!digsiteInfo)
        return NULL;

    ResearchDigsite* digsite = new ResearchDigsite(digsiteInfo, MAX_FINDS_PER_DIGSITE);
    digsite->SelectNewArchaeologyFind(true);
    SaveResearchDigsiteToDB(digsite);
    return digsite;
}

ResearchDigsiteInfo const* Player::GetRandomResearchDigsiteForContinent(uint32 mapId)
{
    ResearchDigsiteList const* digsites = sObjectMgr->GetResearchDigsitesForContinent(mapId);
    if (!digsites)
        return NULL;

    std::set<uint32> activeDigsitesById;
    for (uint8 i = 0; i < RESEARCH_CONTINENT_COUNT; ++i)
        for (uint8 j = 0; j < MAX_DIGSITES_PER_CONTINENT; ++j)
            if (ResearchDigsite* activeDigsite = _researchDigsites[i][j])
                activeDigsitesById.insert(activeDigsite->GetDigsiteId());

    std::list<ResearchDigsiteInfo const*> availableDigsites;
    for (ResearchDigsiteList::const_iterator digsite = digsites->begin(); digsite != digsites->end(); ++digsite)
    {
        if (!IsResearchDigsiteAvailable(&(*digsite)))
            continue;

        // Patch 4.1.0: Players now have a much smaller chance of getting a dig site for a race for which they have completed all rare finds.
        if (HasCompletedAllRareProjectsForRace(digsite->branchId))
            if (!roll_chance_i(25))
                continue;

        // check if digsite is already active
        if (activeDigsitesById.find(digsite->digsiteId) != activeDigsitesById.end())
            continue;

        availableDigsites.push_back(&(*digsite));
    }

    if (availableDigsites.empty())
        return NULL;

    return Trinity::Containers::SelectRandomContainerElement(availableDigsites);
}

bool Player::IsResearchDigsiteAvailable(ResearchDigsiteInfo const* digsiteInfo)
{
    if (!HasSkill(SKILL_ARCHAEOLOGY))
        return false;

    if (GetSkillValue(SKILL_ARCHAEOLOGY) < digsiteInfo->requiredSkillValue)
        return false;

    if (getLevel() < digsiteInfo->requiredLevel)
        return false;

    return true;
}

void ResearchDigsite::SelectNewArchaeologyFind(bool onInit)
{
    if (!onInit && _remainingFindCount)
        _remainingFindCount--;

    if (!_remainingFindCount)
        return;

    _archaeologyFind = sObjectMgr->GetRandomArchaeologyFindForDigsite(GetDigsiteId());
}

void Player::_LoadResearchHistory(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT projectId, researchCount, firstResearchTimestamp FROM character_research_history WHERE guid = ?
        Field* fields = result->Fetch();

        uint32 projectId = fields[0].GetUInt32();
        if (!sResearchProjectStore.LookupEntry(projectId))
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchHistory - Player(GUID: %u, name : %s) is trying to load history for non existing reasearch project(id: %u).", GetGUIDLow(), GetName().c_str(), projectId);
            continue;
        }

        ResearchProjectHistory& researchProjectHistory = _researchHistory[projectId];
        researchProjectHistory.researchCount = fields[1].GetUInt32();
        researchProjectHistory.firstResearchTimestamp = fields[2].GetUInt32();
    }
    while (result->NextRow());
}

void Player::_LoadResearchProjects(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT projectId FROM character_research_projects WHERE guid = ?
        Field* fields = result->Fetch();

        uint32 projectId = fields[0].GetUInt32();
        ResearchProjectEntry const* projectEntry = sResearchProjectStore.LookupEntry(projectId);
        if (!projectEntry)
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchProjects - Player (GUID: %u, name: %s) is trying to load non existing reasearch project (id: %u).", GetGUIDLow(), GetName().c_str(), projectId);
            continue;
        }

        if (_researchProjects.find(projectEntry->ResearchBranchId) != _researchProjects.end())
        {
            TC_LOG_ERROR("entities.player", "Player::_LoadResearchProjects - Player (GUID: %u, name: %s) is trying to load reasearch project (id: %u) for branch id %u, but he is already researching another project for this branch.",
                         GetGUIDLow(), GetName().c_str(), projectId, projectEntry->ResearchBranchId);
            continue;
        }

        _researchProjects[projectEntry->ResearchBranchId] = projectId;
    }
    while (result->NextRow());
}

void Player::_SaveResearchHistory(SQLTransaction& trans)
{
    // DELETE FROM character_research_history WHERE guid = ?
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_HISTORY);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (ResearchHistoryMap::iterator itr = _researchHistory.begin(); itr != _researchHistory.end(); ++itr)
    {
        // INSERT INTO character_research_history (guid, projectId, researchCount, firstResearchTimestamp) VALUES (?, ?, ?, ?)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_RESEARCH_HISTORY);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, itr->first);
        stmt->setUInt32(2, itr->second.researchCount);
        stmt->setUInt32(3, itr->second.firstResearchTimestamp);
        trans->Append(stmt);
    }
}

void Player::_SaveResearchProjects(SQLTransaction& trans)
{
    // DELETE FROM character_research_projects WHERE guid = ?
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_RESEARCH_PROJECTS);
    stmt->setUInt32(0, GetGUIDLow());
    trans->Append(stmt);

    for (ResearchProjectMap::iterator itr = _researchProjects.begin(); itr != _researchProjects.end(); ++itr)
    {
        // INSERT INTO character_research_projects (guid, projectId) VALUES (?, ?)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_RESEARCH_PROJECT);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, itr->second);
        trans->Append(stmt);
    }
}

void Player::SendResearchHistory()
{
    WorldPacket data(SMSG_RESEARCH_SETUP_HISTORY, 3 + _researchHistory.size() * (4 + 4 + 4));
    data.WriteBits(_researchHistory.size(), 20);
    data.FlushBits();

    for (ResearchHistoryMap::iterator itr = _researchHistory.begin(); itr != _researchHistory.end(); ++itr)
    {
        data << uint32(itr->first); // project id
        data << uint32(itr->second.researchCount);
        data << uint32(itr->second.firstResearchTimestamp);
    }

    GetSession()->SendPacket(&data);
}

void Player::SolveResearchProject(Spell* spell)
{
    SpellResearchData const* researchData = spell->m_researchData;
    if (!researchData)
        return;

    uint32 projectId = spell->GetSpellInfo()->ResearchProject;
    ResearchProjectEntry const* currentProjectEntry = sResearchProjectStore.LookupEntry(projectId);
    if (!currentProjectEntry)
        return;

    if (researchData->FragmentCurrencyId && researchData->FragmentCount)
        ModifyCurrency(researchData->FragmentCurrencyId, -(int32)researchData->FragmentCount);

    if (researchData->KeystoneItemId && researchData->KeystoneCount)
        DestroyItemCount(researchData->KeystoneItemId, researchData->KeystoneCount, true);

    ResearchProjectHistory& researchProjectHistory = _researchHistory[projectId];
    researchProjectHistory.researchCount++;
    if (!researchProjectHistory.firstResearchTimestamp)
        researchProjectHistory.firstResearchTimestamp = uint32(time(NULL));

    WorldPacket data(SMSG_RESEARCH_COMPLETE, 4 + 4 + 4);
    data << uint32(researchProjectHistory.firstResearchTimestamp);
    data << uint32(projectId);
    data << uint32(researchProjectHistory.researchCount);
    GetSession()->SendPacket(&data);

    UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_ARCHAEOLOGY_PROJECTS, projectId);

    // new project will be selected in UpdateResearchProjects
    _researchProjects[currentProjectEntry->ResearchBranchId] = 0;

    UpdateResearchProjects();

    CreditprojectDailyQuest(180025); // project Daily Quest Credit - Artifacts
}

bool Player::HasCompletedAllRareProjectsForRace(uint32 researchBranchId)
{
    for (uint32 i = 0; i < sResearchProjectStore.GetNumRows(); ++i)
        if (ResearchProjectEntry const* projectEntry = sResearchProjectStore.LookupEntry(i))
            if (projectEntry->ResearchBranchId == researchBranchId && projectEntry->Rarity > 0 && !HasCompletedResearchProject(projectEntry->Id))
                return false;

    return true;
}

bool Player::HasCompletedAllCommonProjectsForRace(uint32 researchBranchId, bool onlyAvailable)
{
    for (uint32 i = 0; i < sResearchProjectStore.GetNumRows(); ++i)
        if (ResearchProjectEntry const* projectEntry = sResearchProjectStore.LookupEntry(i))
            if (projectEntry->ResearchBranchId == researchBranchId && projectEntry->Rarity == 0 && !HasCompletedResearchProject(projectEntry->Id))
            {
                if (onlyAvailable)
                    if (ResearchProjectRequirements const* requirements = sObjectMgr->GetResearchProjectRequirements(projectEntry->Id))
                        if (GetSkillValue(SKILL_ARCHAEOLOGY) >= requirements->requiredSkillValue)
                            continue;

                return false;
            }

    return true;
}

uint32 Player::GetRandomResearchProjectForRace(uint32 researchBranchId)
{
    std::map<uint32, float> explicitlyChancedProjects;
    std::list<uint32> equalChancedProjects;
    bool hasCompletedAllCommonProjects = HasCompletedAllCommonProjectsForRace(researchBranchId, true);

    for (uint32 i = 0; i < sResearchProjectStore.GetNumRows(); ++i)
    {
        if (ResearchProjectEntry const* projectEntry = sResearchProjectStore.LookupEntry(i))
        {
            if (projectEntry->ResearchBranchId != researchBranchId)
                continue;

            // rare artifact can be completed only once
            if (projectEntry->Rarity > 0 && HasCompletedResearchProject(projectEntry->Id))
                continue;

            // common artifact can be completed again only if player has completed all available common artifacts
            if (projectEntry->Rarity == 0 && HasCompletedResearchProject(projectEntry->Id) && !hasCompletedAllCommonProjects)
                continue;

            if (ResearchProjectRequirements const* requirements = sObjectMgr->GetResearchProjectRequirements(projectEntry->Id))
            {
                if (GetSkillValue(SKILL_ARCHAEOLOGY) < requirements->requiredSkillValue)
                    continue;

                if (requirements->chance > 0)
                    explicitlyChancedProjects[projectEntry->Id] = requirements->chance;
                else
                    equalChancedProjects.push_back(projectEntry->Id);
            }
            else
                equalChancedProjects.push_back(projectEntry->Id);
        }
    }

    if (!explicitlyChancedProjects.empty())
    {
        std::map<uint32, float>::iterator itr = explicitlyChancedProjects.begin();
        std::advance(itr, urand(0, explicitlyChancedProjects.size() - 1));
        if (roll_chance_f(itr->second))
            return itr->first;
    }

    if (!equalChancedProjects.empty())  // If nothing selected yet - project is taken from equal-chanced part
        return Trinity::Containers::SelectRandomContainerElement(equalChancedProjects);

    return 0;
}

void Player::UpdateResearchProjects()
{
    uint32 projectIds[RESEARCH_BRANCH_COUNT];
    memset(&projectIds, 0, RESEARCH_BRANCH_COUNT * sizeof(uint32));
    if (HasSkill(SKILL_ARCHAEOLOGY))
    {
        uint8 j = 0;
        for (uint32 i = 0; i < sResearchBranchStore.GetNumRows(); ++i)
        {
            if (i == 315) // this branch should not be available
                continue;

            if (ResearchBranchEntry const* branchEntry = sResearchBranchStore.LookupEntry(i))
            {
                ResearchProjectMap::iterator itr = _researchProjects.find(branchEntry->Id);
                if (itr == _researchProjects.end()) // branch not found
                {
                    if (uint32 projectId = GetRandomResearchProjectForRace(branchEntry->Id)) // try to select new project
                    {
                        _researchProjects[branchEntry->Id] = projectId;
                        projectIds[++j] = projectId;
                    }
                }
                else if (!itr->second) // branch found, but without project
                {
                    if (uint32 projectId = GetRandomResearchProjectForRace(branchEntry->Id)) // try to select new project
                    {
                        itr->second = projectId;
                        projectIds[++j] = projectId;
                    }
                    else // no project selected, remove branch
                        _researchProjects.erase(itr);
                }
                else
                    projectIds[++j] = itr->second;
            }
        }
    }
    else // archaeology has been unlearned, remove all active research projects and research history
    {
        _researchProjects.clear();
        _researchHistory.clear();
    }

    uint8 count = 0;
    uint32 newvalue;
    for (auto projectId : projectIds)
    {
        if (count % 2 == 1)
        {
            newvalue |= projectId;
            SetUInt32Value(PLAYER_FIELD_RESEARCHING + count / 2, newvalue);
        }
        else if (count == RESEARCH_BRANCH_COUNT - 1)
        {
            SetUInt32Value(PLAYER_FIELD_RESEARCHING + count / 2, projectId);
            break;
        }
        else
            newvalue = projectId << 16;

        ++count;
    }
}

uint32 Player::GetLastPetNumber(bool withDismissed) const
{
    uint32 dismissedMask = (1 << 31);
    if (m_lastpetnumber & dismissedMask)
        return withDismissed ? m_lastpetnumber & ~dismissedMask : 0;

    return m_lastpetnumber;
}

void Player::SetCurrentPetId(uint32 newPetId, SQLTransaction trans)
{
    if (m_currentPetId == newPetId)
        return;

    PreparedStatement* stmt;

    if (newPetId != 0)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CURRENT_PET_ID);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, newPetId);
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CURRENT_PET_ID);
        stmt->setUInt32(0, GetGUIDLow());
    }

    if (trans)
        trans->Append(stmt);
    else
        CharacterDatabase.Execute(stmt);

    m_currentPetId = newPetId;
}

void Player::AddNewPet(int8 slot, Pet* pet)
{
    ASSERT(slot != -1);
    ASSERT(m_petList.find(slot) == m_petList.end());

    auto& data = m_petList[slot];
    data.Entry = pet->GetEntry();
    data.PetNumber = pet->GetCharmInfo()->GetPetNumber();
    data.Name = pet->GetName();
}

void Player::SwapPets(int8 destSlot, int8 srcSlot)
{
    auto itr1 = m_petList.find(destSlot);
    auto itr2 = m_petList.find(srcSlot);

    ASSERT(itr2 != m_petList.end());

    if (itr1 == m_petList.end())
    {
        m_petList[destSlot] = itr2->second;
        m_petList.erase(itr2);
    }
    else
    {
        std::swap(itr1->second, itr2->second);
    }
}

uint32 Player::GetPetIdBySlot(uint8 slot) const
{
    auto itr = m_petList.find(slot);
    if (itr == m_petList.end()) // Normal situation. Function is used for moving pet in slots, and slot can be empty
        return 0;
    return itr->second.PetNumber;
}

int8 Player::GetSlotByPetId(uint32 petId) const
{
    for (auto&& itr : m_petList)
        if (itr.second.PetNumber == petId)
            return itr.first;

    return -1;
}

int8 Player::GetSlotForNewPet() const
{
    int8 activeSlots = 0;

    if (HasSpell(83245))
        activeSlots = 5;
    else if (HasSpell(83244))
        activeSlots = 4;
    else if (HasSpell(83243))
        activeSlots = 3;
    else if (HasSpell(83242))
        activeSlots = 2;
    else if (HasSpell(883))
        activeSlots = 1;

    for (int8 i = PET_SLOT_ACTIVE_FIRST; i < activeSlots; ++i)
    {
        auto itr = m_petList.find(i);
        if (itr == m_petList.end())
            return i;
    }

    return -1;
}

void Player::LoadPetList()
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PET_SLOT_LIST);
    stmt->setUInt32(0, GetGUIDLow());
    stmt->setUInt8(1, PET_SLOT_ACTIVE_FIRST);
    stmt->setUInt8(2, PET_SLOT_STABLE_LAST);

    PreparedQueryResult result = CharacterDatabase.Query(stmt);
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        uint8 slot = fields[0].GetUInt8();
        uint32 pet = fields[1].GetUInt32();
        if (slot > PET_SLOT_STABLE_LAST)
        {
            TC_LOG_ERROR("shitlog", "Player::LoadPetList Player %u has pet %u with invalid slot %u", GetGUIDLow(), pet, slot);
            continue;
        }
        if (m_petList.find(slot) != m_petList.end())
        {
            TC_LOG_ERROR("shitlog", "Player::LoadPetList Player %u has pet duplicated slot %u", GetGUIDLow(), slot);
            continue;
        }
        auto& data = m_petList[slot];
        data.PetNumber = pet;
        data.Entry = fields[2].GetUInt32();
        data.Name = fields[3].GetString();
    } while (result->NextRow());
}

void Player::SetLootSpecialization(uint32 specialization)
{
    if (GetLootSpecialization() == specialization)
        return;

    SetUInt32Value(PLAYER_FIELD_LOOT_SPEC_ID, specialization);
}

uint32 Player::GetLootSpecOrClassSpec() const
{
    uint32 specialization = GetLootSpecialization();
    if (!specialization)
        return GetTalentSpecialization();

    return specialization;
}

void Player::ClearInCombat()
{
    Unit::ClearInCombat();

    UpdatePotionCooldown();

    // Place for hacks.
    // On client regen starts after ~30 seconds from "Leave Combat" message.
    if (GetTalentSpecialization() == SPEC_WARLOCK_DEMONOLOGY && IsAlive())
        m_alternateRegenTimerCount = -30000;

    // See Unit::SetInCombatState
    if (GetTalentSpecialization() == SPEC_WARLOCK_DESTRUCTION && IsAlive())
        m_alternateRegenTimerCount = -23000;

    // Holy power or chi Starts fading only after 10 seconds
    if (IsAlive() && (getClass() == CLASS_PALADIN || getClass() == CLASS_MONK))
        m_alternateRegenTimerCount = 0;
}

std::vector<uint8> Player::MakeTradeSkillRecipesData(uint32 skillId) const
{
    std::vector<uint8> data;
    data.resize(300, 0);

    SkillLineEntry const* skill = sSkillLineStore.LookupEntry(skillId);
    if (!skill || !skill->canLink)
        return data;

    for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
    {
        if (SkillLineAbilityEntry const* ability = sSkillLineAbilityStore.LookupEntry(j))
        {
            if (ability->skillId == skillId)
            {
                if (ability->spellId && HasSpell(ability->spellId))
                {
                    uint32 byte = ability->bitOrder / 8;
                    if (byte < 300)
                    {
                        uint32 bit = ability->bitOrder & 0x80000007;
                        if (bit < 0)
                            bit = (bit & ~0xFF) | (((bit - 1) | 0xF8) + 1);
                        data[byte] |= 1 << bit;
                    }
                }
            }
        }
    }

    return data;
}

uint32 Player::GetResurrectHealthBonus() const
{
    if (InBattleground())
        return 0;

    if (InstanceMap* instance = GetMap()->ToInstanceMap())
        if (instance->GetInstanceScript() && instance->GetInstanceScript()->IsEncounterInProgress())
            return 0;

    return GetMaxPositiveAuraModifier(SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER);
}

bool Player::HasTwoHandWeaponInOneHand() const
{
    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    Item* mainItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
    return offItem && ((mainItem && mainItem->GetTemplate()->InventoryType == INVTYPE_2HWEAPON) || offItem->GetTemplate()->InventoryType == INVTYPE_2HWEAPON);
}

bool Player::HasGlyph(uint32 spellId) const
{
    for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
        if (uint32 glyph = GetGlyph(GetActiveSpec(), i))
            if (GlyphPropertiesEntry const* gp = sGlyphPropertiesStore.LookupEntry(glyph))
                if (gp->SpellId == spellId)
                    if (GlyphSlotEntry const* gs = sGlyphSlotStore.LookupEntry(GetGlyphSlot(i)))
                        if (gp->TypeFlags == gs->TypeFlags)
                            return true;
    return false;
}

bool Player::HasItemApplyingAura(uint32 spellId) const
{
    // Titan's Grip
    if (spellId == 49152 && CanTitanGrip() && HasTwoHandWeaponInOneHand())
        return true;

    return spellId && DoForEachItem([spellId](Item* item)
    {
        ItemTemplate const* proto = item->GetTemplate();

        // Check item-triggered spells
        for (auto&& spell : proto->Spells)
            if (spell.SpellId == spellId)
                if (spell.SpellTrigger == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE || spell.SpellTrigger == ITEM_SPELLTRIGGER_ON_EQUIP && item->IsEquipped())
                    return true;

        // Check item and gem enchantments
        for (uint32 slot = PERM_ENCHANTMENT_SLOT; slot < MAX_ENCHANTMENT_SLOT; ++slot)
            if (uint32 id = item->GetEnchantmentId(EnchantmentSlot(slot)))
                if (SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(id))
                    for (uint32 i = 0; i < MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
                        if (enchant->Type[i] == ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL && enchant->SpellID[i] == spellId && item->IsEquipped())
                            return true;

        return false;
    }, true, true, true, false, false);
}

bool Player::IsItemFitToSpecialization(ItemTemplate const* proto) const
{
    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
        return false;

    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
        return false;

    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
        return false;

    if (proto->Class == ITEM_CLASS_ARMOR && proto->InventoryType >= INVTYPE_HEAD && proto->InventoryType <= INVTYPE_HANDS && getLevel() >= 40)
    {
        switch (getClass())
        {
            case CLASS_WARRIOR:
            case CLASS_PALADIN:
            case CLASS_DEATH_KNIGHT:
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
                    return false;
                break;
            case CLASS_HUNTER:
            case CLASS_SHAMAN:
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
                    return false;
                break;
            case CLASS_ROGUE:
            case CLASS_MONK:
            case CLASS_DRUID:
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
                    return false;
                break;
            case CLASS_PRIEST:
            case CLASS_MAGE:
            case CLASS_WARLOCK:
                if (proto->SubClass != ITEM_SUBCLASS_ARMOR_CLOTH)
                    return false;
                break;
        }
    }

    uint32 skill = Item::GetSkill(proto->ItemId);
    if (skill && !HasSkill(skill))
        return false;

    // Also checks only in lua version of a function. I am not aware of the details.
    if (proto->Flags & ITEM_FLAG_UNK22)
        return true;

    uint32 spec = GetLootSpecialization();
    if (!spec)
        spec = GetTalentSpecialization();

    return sObjectMgr->GetItemSpecInfo(proto->ItemId, getLevel())->HasSpecializationId(spec);
}

void Player::SendDeclineGuildInvitation(std::string declinerName, bool autoDecline /*= false*/)
{
    WorldPacket data(SMSG_GUILD_INVITE_DECLINED);
    data.WriteBits(declinerName.length(), 6);
    data.WriteBit(autoDecline);
    data.FlushBits();
    data.WriteString(declinerName);
    data << uint32(realmID);
    GetSession()->SendPacket(&data);
}

bool Player::HasLootLockout(LootLockoutType type, uint32 lootedObjectEntry, Difficulty difficulty, bool checkPending) const
{
    return m_lootLockouts->HasLootLockout(type, lootedObjectEntry, difficulty, checkPending);
}

void Player::AddLootLockout(LootLockoutType type, uint32 lootedObjectEntry, Difficulty difficulty, bool pending)
{
    m_lootLockouts->AddLootLockout(type, lootedObjectEntry, difficulty, pending);
}

void Player::ClearLootLockouts()
{
    m_lootLockouts->Clear();
}

void Player::SendStartTimer(uint32 time, uint32 maxTime, uint8 type)
{
    WorldPacket data(SMSG_START_TIMER, 12);
    data << uint32(maxTime);
    data << uint32(time);
    data << uint32(type);
    SendDirectMessage(&data);
}

void Player::AddToAsisstList(uint64 guid)
{
    auto& info = m_lastTargets[guid];
    info.Priority += 2;
    info.Timer = 0;
}

void Player::_LoadCompletedChallenges(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        CompletedChallenge challenge;

        Field* field = result->Fetch();
        uint32 mapId = field[0].GetUInt32();
        challenge.BestTime = field[1].GetUInt32();
        challenge.LastTime = field[2].GetUInt32();
        challenge.BestMedal = field[3].GetUInt8();
        challenge.BestMedalDate = field[4].GetUInt32();

        m_CompletedChallenges.insert(std::make_pair(mapId, challenge));
    } while (result->NextRow());
}

void Player::AddCompletedChallenge(uint32 mapId, CompletedChallenge challenge)
{
    if (m_CompletedChallenges.find(mapId) != m_CompletedChallenges.end()) // Already completed
        return;

    m_CompletedChallenges.insert(std::make_pair(mapId, challenge));
}

void Player::SendTransferMail()
{
    if (!sWorld->getBoolConfig(CONFIG_TRANSFER_MAIL_ENABLED))
        return;

    // header and text
    std::string header = sConfigMgr->GetStringDefault("TransferMail.Header", "");
    if (header.empty())
        return;
    std::string text = sConfigMgr->GetStringDefault("TransferMail.Text", "");
    if (text.empty())
        return;
    MailSender sender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM);
    MailDraft draft(header, text);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    // items
    std::string itemsStr = sConfigMgr->GetStringDefault("TransferMail.Items", "");
    if (!itemsStr.empty())
    {
        Tokenizer itemTok{ itemsStr, ' ' };
        if (itemTok.size())
        {
            for (auto&& itr : itemTok)
            {
                Tokenizer itemData{ itr, ':' };
                uint32 itemId = 0;
                uint32 itemCount = 0;
                if (itemData.size() >= 1)
                {
                    itemId = atoi(itemData[0]);
                    itemCount = itemData.size() > 1 ? atoi(itemData[1]) : 1;
                }
                else
                    continue;

                ItemTemplate const* itemTemp = sObjectMgr->GetItemTemplate(itemId);
                if (!itemTemp)
                    continue;

                if (itemTemp->Stackable > 1 || itemCount == 1)
                {
                    if (Item* item = Item::CreateItem(itemTemp->ItemId, itemCount, nullptr))
                    {
                        item->SaveToDB(trans);
                        draft.AddItem(item);
                    }
                }
                else if (itemTemp->Stackable == 1 && itemCount > 1)
                {
                    for (uint32 i = 0; i < itemCount; i++)
                    {
                        if (Item* item = Item::CreateItem(itemTemp->ItemId, 1, nullptr))
                        {
                            item->SaveToDB(trans);
                            draft.AddItem(item);
                        }
                    }
                }
            };
        }
    }

    draft.SendMailTo(trans, MailReceiver(this, GetGUIDLow()), sender);
    CharacterDatabase.CommitTransaction(trans);
}

void Player::SetBonusRollExtraChance(float value)
{
    PreparedStatement* stmt;
    if (value == 0.0f)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_BONUS_ROLL);
        stmt->setUInt32(0, GetGUIDLow());
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_BONUS_ROLL);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setFloat (1, value);
    }

    CharacterDatabase.Execute(stmt);

    m_bonusRollBonusChance = value;
}

void Player::RestoreCombatWithInstance()
{
    if (!IsInWorld())
        return;

    InstanceScript* instance = GetInstanceScript();
    if (!instance || !instance->IsEncounterInProgress())
        return;

    for (auto&& ref : instance->instance->GetPlayers())
        RestoreCombatWithPlayer(ref.GetSource());
}

void Player::RestoreCombatWithPlayer(Player* player)
{
    if (!player || player == this || !player->IsInCombat())
        return;

    SetInCombatState(player->GetPvPCombatTimer() > 0);
    player->getHostileRefManager().threatAssist(this, 0.0f);
}

void Player::SetCanTurnWhileFalling(bool on)
{
    ObjectGuid guid = GetGUID();
    WorldPacket data{ on ? SMSG_MOVE_SET_CAN_TURN_WHILE_FALLING : SMSG_MOVE_UNSET_CAN_TURN_WHILE_FALLING };
    if (on)
    {
        data.WriteGuidMask(guid, 5, 6, 0, 4, 1, 2, 7, 3);
        data.WriteGuidBytes(guid, 6, 1, 5, 2, 3, 0, 4, 7);
        data << uint32(0);
    }
    else
    {
        data.WriteGuidMask(guid, 5, 4, 0, 2, 7, 1, 6, 3);
        data.WriteGuidBytes(guid, 2, 7, 0, 3, 4, 5);
        data << uint32(0);
        data.WriteGuidBytes(guid, 1, 6);
    }
    SendDirectMessage(&data);
}

bool Player::CreditprojectDailyQuest(uint32 entry, uint32 count)
{
    if (!sWorld->AreprojectDailyQuestsEnabled())
        return true;

    auto&& quests = sWorld->GetprojectDailyQuestRelation(entry);
    if (!quests)
        return false;

    for (auto&& quest : *quests)
        if (!IsActiveQuest(quest->GetQuestId()))
            if (projectMemberInfo* info = GetSession()->GetprojectMemberInfo())
                if (info->CanCompleteMoreDailyQuests() && info->GetSetting(projectMemberInfo::Setting::AutoAcceptprojectDailyQuests).Bool)
                    if (CanTakeQuest(quest, false))
                        if (!sPoolMgr->IsPartOfAPool<Quest>(quest->GetQuestId()) || sPoolMgr->IsSpawnedObject<Quest>(quest->GetQuestId()))
                        {
                            AddQuest(quest, nullptr);

                            if (CanCompleteQuest(quest->GetQuestId()))
                                CompleteQuest(quest->GetQuestId());
                        }

    if (std::any_of(quests->begin(), quests->end(), [this](Quest const* const& quest) { return IsActiveQuest(quest->GetQuestId()); }))
        KilledMonsterCredit(entry, 0, count);

    return true;
}

std::list<Item*> Player::GetAllItems()
{
    std::list<Item*> allItems;

    for (int32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)  // equip
        if (Item *item = m_items[slot])
            allItems.push_back(item);
    for (int32 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)    // main bag
        if (Item *item = m_items[slot])
            allItems.push_back(item);
    for (int32 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)  // bank
        if (Item *item = m_items[slot])
            allItems.push_back(item);

    for (int32 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; slot++)  // inventory bags
    {
        Item *item = m_items[slot];
        if (!item)
            continue;

        Bag *invBag = item->ToBag();
        uint32 bagSize = invBag->GetBagSize();
        for (uint32 bagSlot = 0; bagSlot < bagSize; bagSlot++)
            if (Item *item = invBag->GetItemByPos(bagSlot))
                allItems.push_back(item);
    }
    for (int32 slot = BANK_SLOT_BAG_START; slot < BANK_SLOT_BAG_END; slot++)    // bank bags
    {
        Item *item = m_items[slot];
        if (!item)
            continue;

        Bag *invBag = item->ToBag();
        uint32 bagSize = invBag->GetBagSize();
        for (uint32 bagSlot = 0; bagSlot < bagSize; bagSlot++)
            if (Item *item = invBag->GetItemByPos(bagSlot))
                allItems.push_back(item);
    }

    return allItems;
}

void Player::LeaveFromSoloQueueIfNeed()
{
    uint8 queueSlot = GetBattlegroundQueueIndex(BATTLEGROUND_QUEUE_SOLO);
    if (queueSlot != PLAYER_MAX_BATTLEGROUND_QUEUES)
    {
        WorldPacket data;
        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, nullptr, this, queueSlot, STATUS_NONE, GetBattlegroundQueueJoinTime(BATTLEGROUND_AA), 0, 0);
        SendDirectMessage(&data);

        sBattlegroundMgr->GetSoloQueue().RemovePlayer(GetGUID(), true);
        RemoveBattlegroundQueueId(BATTLEGROUND_QUEUE_SOLO);
    }
}

void Player::ModifyCurrencyMetaConquest(CurrencyTypesEntry const* currency, int32 count, bool printLog)
{
    auto itr = _currencyStorage.find(currency->ID);
    int32 actualWeekCount = 0;
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonCount = 0;
        cur.flags = 0;
        _currencyStorage[currency->ID] = cur;
        itr = _currencyStorage.find(currency->ID);
    }
    else
    {
        actualWeekCount = int32(itr->second.weekCount);
    }

    int32 actualWeekCap = GetCurrencyWeekCap(currency->ID, false);

    // Actual cap
    if (actualWeekCount + count > actualWeekCap)
        count = actualWeekCap - actualWeekCount;

    if (!count)
        return;

    // Okay, allowed to get more by default, check highest cap
    int32 weekCapArena = GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_ARENA, false);
    int32 weekCapRatedBg = GetCurrencyWeekCap(CURRENCY_TYPE_CONQUEST_META_RATED_BG, false);
    int32 maxCap = std::max(weekCapArena, weekCapRatedBg);
    int32 actualConquestCount = GetCurrencyOnWeek(CURRENCY_TYPE_CONQUEST_POINTS, false);

    if (actualConquestCount + count > maxCap)
        count = maxCap - actualConquestCount;

    if (!count)
        return;

    itr->second.totalCount += count;
    itr->second.weekCount += count;
    itr->second.seasonCount += count;
    if (itr->second.state != PLAYERCURRENCY_NEW)
        itr->second.state = PLAYERCURRENCY_CHANGED;

    ModifyCurrency(CURRENCY_TYPE_CONQUEST_POINTS, count, printLog);
}

void Player::ResetBothSpec(bool disable, bool allTalents)
{
    for (uint32 spec = 0; spec < GetSpecsCount(); ++spec)
    {
        for (uint32 talentId = 0; talentId < sTalentStore.GetNumRows(); ++talentId)
        {
            TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);

            if (!talentInfo)
                continue;

            if (talentInfo->PlayerClass != getClass())
                continue;

            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(talentInfo->SpellId);
            if (!spellEntry)
                continue;

            RemoveSpell(talentInfo->SpellId, disable);

            // search for spells that the talent teaches and unlearn them
            for (auto&& spellEffect : spellEntry->Effects)
                if (spellEffect.TriggerSpell > 0 && spellEffect.Effect == SPELL_EFFECT_LEARN_SPELL)
                    RemoveSpell(spellEffect.TriggerSpell, disable);
        }
        for (auto&& it : *GetTalentMap(spec))
            it.second->state = PLAYERSPELL_REMOVED;

        SetTalentSpecialization(spec, SPEC_NONE);
    }

    RemoveSpecializationSpells();
    SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, 0);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveTalents(trans);
    _SaveSpells(trans);
    CharacterDatabase.CommitTransaction(trans);

    AutoUnequipOffhandIfNeed();
    // send update packet to client
    SendTalentsInfoData();

    if (Group* group = GetGroup())
        if (group->IsLogging())
            group->LogEvent("Member changed talents: %s is now %s", Group::Format(this).c_str(), Group::GetPlayerTalentString(this).c_str());
}

void Player::CleanNotForMyClass(bool talents, bool common)
{
    if (talents)
        ResetBothSpec(false, true);

    uint8 myClass = getClass();
    uint8 faction = getRaceMask() & RACEMASK_ALLIANCE ? RECLASS_ALLIANCE : RECLASS_HORDE;
    uint32 spellFamily = sServiceMgr->GetSpellFamilyByClass(myClass);

    for (uint32 i = 0; i < sSkillLineAbilityStore.GetNumRows(); i++)
    {
        auto skillLine = sSkillLineAbilityStore.LookupEntry(i);
        if (!skillLine)
            continue;

        if (!HasSkill(skillLine->skillId))
            continue;

        if (skillLine->classmask && skillLine->classmask & getClassMask())
            continue;

        if (skillLine->racemask && skillLine->racemask & getRaceMask())
            continue;

        if (GetSkillRaceClassInfo(skillLine->skillId, getRace(), myClass))
            continue;

        SetSkill(skillLine->skillId, 0, 0, 0);
    }

    PlayerSpellMap tempSpellMap = PlayerSpellMap(m_spells); // safe local copy
    for (auto&& itr : tempSpellMap)
    {
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr.first))
        {
            if ((spellInfo->SpellFamilyName != spellFamily && spellInfo->SpellFamilyName != SPELLFAMILY_GENERIC && spellInfo->Id != 73313) || // 73313 - Crimson Deathcharger has DK spell family
                spellInfo->IsAbilityOfSkillType(SKILL_ALL_GLYPHS))
                RemoveSpell(itr.first);
        }
    }

    // some old spells haven't spellfamily
    for (uint32 i = 0; i < sTalentStore.GetNumRows(); i++)
    {
        auto talent = sTalentStore.LookupEntry(i);
        if (talent && HasSpell(talent->SpellId) && talent->PlayerClass != getClass())
            RemoveSpell(talent->SpellId);
    }

    int32 i = common ? 0 : CLASS_WARRIOR;
    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    std::set<uint32> const* spells = sServiceMgr->GetClassSpells(myClass, GetTeam());

    for (; i <= CLASS_DRUID; ++i)
    {
        ServiceMgr::ReclassData* data = sServiceMgr->GetReclassData(i);

        for (auto&& itr : *data)
        {
            if (!(itr.flag & faction))
                continue;
            if ((itr.learn & 1 && i != myClass) || (itr.learn == 0 && i == myClass))
            {
                if (itr.flag & RECLASS_SPELL)
                {
                    if (spells && spells->find(itr.entry) == spells->end())
                        RemoveSpell(itr.entry);
                }
                if (itr.flag & RECLASS_SKILL)
                    SetSkill(itr.data, 0, 0, 0);
                if (itr.flag & RECLASS_ACHIEVEMENT)
                    m_achievementMgr->RemoveAchievement(sAchievementStore.LookupEntry(itr.data));
                if (itr.flag & RECLASS_QUEST)
                {
                    RewardedQuestSet::iterator qIter = m_RewardedQuests.find(itr.data);
                    if (qIter == m_RewardedQuests.end())
                        continue;
                    trans->PAppend("DELETE FROM character_queststatus_rewarded WHERE guid = %u AND quest = %u", GetGUIDLow(), *qIter);
                    m_RewardedQuests.erase(qIter);
                }
            }
        }
    }

    _SaveSkills(trans);

    if (trans->GetSize() > 0)
        CharacterDatabase.CommitTransaction(trans);
}

void Player::ChangeClass(uint32 oldClass, uint32 newClass)
{
    // remove glyphs for both spec
    for (int spec = 0; spec < GetSpecsCount(); ++spec)
    {
        for (uint32 slot = 0; slot < MAX_GLYPH_SLOT_INDEX; ++slot)
        {
            UnapplyGlyph(slot);
            _talentMgr->SpecInfo[spec].Glyphs[slot] = 0;
            SendTalentsInfoData();
        }
    }

    uint8 level = getLevel();
    uint32 faction = getRaceMask() & RACEMASK_ALLIANCE ? RECLASS_ALLIANCE : RECLASS_HORDE;
    uint32 guid = GetGUIDLow();
    // find riding, it will be unlearn if old class is DK or paly
    static RidingSpells rSpells[] = { RIDING_APPRENTICE, RIDING_JOURNEYMAN, RIDING_EXPERT, RIDING_ARTISAN, RIDING_MASTER };
    uint32 ridingSpell = oldClass == CLASS_DEATH_KNIGHT ? RIDING_JOURNEYMAN : 0;
    for (int8 rank = 0; rank < 6; ++rank)
    {
        if (HasSpell(rSpells[rank]))
            ridingSpell = rSpells[rank];
        else
            break;
    }

    bool hasColdWeatherFlying = HasSpell(COLD_WEATHER_FLYING);
    bool hasFlightMasterLicense = HasSpell(FLIGHT_MASTER_LICENSE);
    bool hasWisdomOfFourWinds = HasSpell(WISDOM_OF_THE_FOUR_WINDS);
    // update namedata container
    sWorld->UpdateCharacterNameDataClass(guid, newClass);
    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    // remove rewarded quests of old class, do not unlearn Shadowmourne quest line if new class can take this quests
    for (auto qIter = m_RewardedQuests.begin(); qIter != m_RewardedQuests.end(); )
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(*qIter);
        if (quest && (quest->GetRequiredClasses() & (1 << (oldClass - 1))) && !(quest->GetRequiredClasses() & (1 << (newClass - 1))))
        {
            trans->PAppend("DELETE FROM character_queststatus_rewarded WHERE guid = %u AND quest = %u", guid, *qIter);
            m_RewardedQuests.erase(qIter++);
        }
        else
            ++qIter;
    }

    // remove active quest of old class, do not unlearn Shadowmourne quest line if new class can take this quests
    for (auto qsIter = m_QuestStatus.begin(); qsIter != m_QuestStatus.end(); )
    {
        Quest const* quest = sObjectMgr->GetQuestTemplate(qsIter->first);
        if (quest && (quest->GetRequiredClasses() & (1 << (oldClass - 1))) && !(quest->GetRequiredClasses() & (1 << (newClass - 1))))
        {
            for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
            {
                uint32 logQuest = GetQuestSlotQuestId(slot);
                if (logQuest == qsIter->first)
                {
                    SetQuestSlot(slot, 0);
                    TakeQuestSourceItem(logQuest, false);
                }
            }

            for (auto&& it : quest->m_questObjectives)
            {
                m_questObjectiveStatus.erase(it->Id);
                m_questObjectiveStatusSave[it->Id] = false;
            }

            m_QuestStatusSave[quest->GetQuestId()] = false;
            m_QuestStatus.erase(qsIter++);
        }
        else
            ++qsIter;
    }
    // get all pets and abadon it
    if (QueryResult result = CharacterDatabase.PQuery("SELECT id FROM character_pet WHERE owner = %u", guid))
    {
        do
        {
            Field* fields = result->Fetch();
            Pet* pet = new Pet(this);
            if (pet->LoadPetFromDB(PET_LOAD_BY_ID, fields[0].GetUInt32()))
                pet->Remove(PET_REMOVE_ABANDON);
            else
                delete pet;
        } while (result->NextRow());
    }

    RemoveAllAuras();

    // completely unlearn
    CleanNotForMyClass(true, true);

    for (auto&& spell : *sServiceMgr->GetClassSpells(getClass(), GetTeam()))
    {
        if (!spell)
            continue;

        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spell);
        if (!spellInfo || spellInfo->SpellLevel > getLevel())
            continue;

        bool check = true;
        SkillLineAbilityMapBounds skillBounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell);
        for (auto itr = skillBounds.first; itr != skillBounds.second; ++itr)
        {
            if (itr->second->racemask && !(itr->second->racemask & getRaceMask()))
            {
                check = false;
                break;
            }
        }
        if (!check)
            continue;

        LearnSpell(spell, false);
    }

    ServiceMgr::ReclassData* data = sServiceMgr->GetReclassData(newClass);

    for (auto&& iter : *data)
    {
        if (iter.learn != 1)
            continue;

        // learn missing spells, skills and set rewarded quests
        if (!(iter.flag & faction))
            continue;
        if (iter.flag & RECLASS_SKILL)
        {
            const SkillLineEntry* pSkill = sSkillLineStore.LookupEntry(iter.data);
            if (!pSkill)
                continue;
            if (GetSkillRangeType(pSkill, false) == SKILL_RANGE_MONO)
                SetSkill(iter.data, 1, 1, 1);
            else
                SetSkill(iter.data, 5, level * 5, level * 5);
        }
        if (iter.flag & RECLASS_QUEST)
        {
            m_RewardedQuests.insert(iter.data);
            m_RewardedQuestsSave[iter.data] = true;
        }
    }

    bool findSHM = ((1 << (newClass - 1)) & CLASSMASK_SHADOW_MOURNE) ? true : false; // crutch, but no idea
    bool findDWR = ((1 << (newClass - 1)) & CLASSMASK_DRAGONWRATH) ? true : false;
    bool findFOF = ((1 << (newClass - 1)) & CLASSMASK_FANGS_OF_THE_FATHER) ? true : false;
    bool findCloack = ((1 << (newClass - 1)) & CLASSMASK_ALL_PLAYABLE) ? true : false;
    std::function<void(Item*, bool)> weaponCheck = [this, &findSHM, &findDWR, &findFOF, &findCloack, &trans](Item* item, bool mail)
    {
        std::list<Item *> allItems = GetAllItems(); // Get all items for check
        std::list<Item *> itemsToSend;

        if (findSHM && item->GetEntry() == 49623) // Shadowmourne, to prevent new quest line
        {
            static uint32 shmQuests[] = { 24545, 24743, 24547, 24749, 24756, 24757, 24548, 24549 };
            for (uint32 i = 0; i < 8; ++i)
            {
                m_RewardedQuests.insert(shmQuests[i]);
                m_RewardedQuestsSave[shmQuests[i]] = true;
            }
            findSHM = false;
        }
        if (findDWR && item->GetEntry() == 71086) // Dragonwrath, to prevent new quest line
        {
            static uint32 dwrQuests[] = { 24545, 24743, 24547, 24749, 24756, 24757, 24548, 24549 };
            for (uint32 i = 0; i < 8; ++i)
            {
                m_RewardedQuests.insert(dwrQuests[i]);
                m_RewardedQuestsSave[dwrQuests[i]] = true;
            }
            findDWR = false;
        }
        if (findFOF && (item->GetEntry() == 77949 || item->GetEntry() == 77950)) // Fangs of the Father, to prevent new quest line
        {
            static uint32 fofQuests[] = { 29801, 29802, 29934, 29847, 30092, 30093, 30106, 30107, 30108, 30109, 30113, 30116, 30118 };
            for (uint32 i = 0; i < 13; ++i)
            {
                m_RewardedQuests.insert(fofQuests[i]);
                m_RewardedQuestsSave[fofQuests[i]] = true;
            }
            findFOF = false;
        }
        if (findCloack && (item->GetEntry() == 102245 || item->GetEntry() == 102246 || item->GetEntry() == 102247 ||
                           item->GetEntry() == 102248 || item->GetEntry() == 102249 || item->GetEntry() == 102250)) // Legendary Cloack, to prevent new quest line
        {
            std::vector<uint32> cloackQuests;
            if (GetTeam() == ALLIANCE)
                cloackQuests = { 31488, 31454, 31468, 31473, 31481, 31482, 32373, 32374, 32388, 32389, 32390, 32679, 32681, 32644, 32654, 32652, 32655, 32656, 32590, 32592, 32591, 32593, 32594, 32595, 32596, 32597, 32598, 32805, 32861, 33087, 33088, 33098, 33100, 33104 };
            else
                cloackQuests = { 31488, 31454, 31468, 31473, 31481, 31482, 32427, 32429, 32476, 32430, 32431, 32432, 32678, 32680, 32212, 32276, 32277, 32278, 32279, 32590, 32592, 32591, 32593, 32594, 32595, 32596, 32597, 32598, 32805, 32861, 33087, 33088, 33098, 33100, 33104 };
            for (auto&& itr : cloackQuests)
            {
                m_RewardedQuests.insert(itr);
                m_RewardedQuestsSave[itr] = true;
            }
            findCloack = false;
        }

        uint32 enchID = item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT);  // only perm ench
        SpellItemEnchantmentEntry const* ench = sSpellItemEnchantmentStore.LookupEntry(enchID);
        if (!ench)
            return;

        switch (ench->RequiredSkill)
        {
            case 770:   // some dk enchants requir blood skill
            case 771:   // some frost skill
            case 776:   // deault - runeforging
                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT + PERM_ENCHANTMENT_SLOT*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, 0);
                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT + PERM_ENCHANTMENT_SLOT*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, 0);
                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT + PERM_ENCHANTMENT_SLOT*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, 0);
                if (!mail)
                {
                    GetSession()->SendEnchantmentLog(item->GetOwnerGUID(), 0, item->GetGUID(), item->GetEntry(), enchID, PERM_ENCHANTMENT_SLOT);
                    item->SetState(ITEM_CHANGED, this);
                }
                else
                    item->SaveToDB(trans);
                break;
            default:
                break;
        }
    };

    std::list<Item*> problematicItems;
    for (auto&& item : GetAllItems())
    {
        if (!item)
            continue;

        ItemTemplate const* proto = item->GetTemplate();
        if (!proto)
            continue;

        // unequip all items
        if (item->IsEquipped())
        {
            ItemPosCountVec dest;
            if (CanStoreItem(NULL_BAG, NULL_SLOT, dest, item, false) == EQUIP_ERR_OK)
            {
                RemoveItem(item->GetBagSlot(), item->GetSlot(), true);
                StoreItem(dest, item, true);
            }
            else
            {
                MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
                problematicItems.push_back(item);
            }
        }

        if (proto->Class == ITEM_CLASS_WEAPON || (proto->Class == ITEM_CLASS_ARMOR && proto->InventoryType == INVTYPE_CLOAK)) // DK runeforging and Legendary Items
            weaponCheck(item, false);
    }

    while (!problematicItems.empty())
    {
        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

        MailDraft draft(subject, "There were problems with equipping item(s).");
        for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
        {
            draft.AddItem(problematicItems.front());
            problematicItems.pop_front();
        }
        draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
    }

    // Also in mail items.
    for (auto&& iter : mMitems)
    {
        Item* item = iter.second;
        if (!item)
            continue;

        ItemTemplate const* proto = item->GetTemplate();
        if (!proto || proto->Class != ITEM_CLASS_WEAPON)
            continue;

        weaponCheck(item, true);
    }

    if (ridingSpell) // learn riding and cold weather flying if it removed by unlearn DK, paly or warlock mount
        LearnSpell(ridingSpell, false); // no need to check for HasSpell, it will be checked in learnSpell
    if (hasColdWeatherFlying)
        LearnSpell(COLD_WEATHER_FLYING, false);
    if (hasFlightMasterLicense)
        LearnSpell(FLIGHT_MASTER_LICENSE, false);
    if (hasWisdomOfFourWinds)
        LearnSpell(WISDOM_OF_THE_FOUR_WINDS, false);

    if (oldClass == CLASS_DEATH_KNIGHT)
    {
        if (!HasSpell(27028))
            LearnSpell(10846, false); // for correct displaing First Aid if reclass from DK with not learned First Aid (Master)
    }

    CharacterDatabase.CommitTransaction(trans);

    for (uint32 i = 0; i < ACHIEVEMENT_CRITERIA_TYPE_TOTAL; ++i)// update all achievement criteria
        UpdateAchievementCriteria(AchievementCriteriaTypes(i));
}

void Player::UpdateValorOfTheAncients()
{
    PlayerCurrenciesMap::iterator itr = _currencyStorage.find(CURRENCY_TYPE_VALOR_POINTS);
    if (itr == _currencyStorage.end())
        return; // noting to do here

    uint32 weekCap = GetCurrencyWeekCap(sCurrencyTypesStore.LookupEntry(CURRENCY_TYPE_VALOR_POINTS));
    bool hasWeekCap = weekCap && itr->second.weekCount >= weekCap;
    if (!GetSession()->HasFlag(ACC_FLAG_VALOR_CAP_REACHED) && hasWeekCap)
        GetSession()->AddFlag(ACC_FLAG_VALOR_CAP_REACHED);

    bool capReached = GetSession()->HasFlag(ACC_FLAG_VALOR_CAP_REACHED);
    if (capReached)
        CastSpell(this, SPELL_VALOR_OF_THE_ANCIENTS, true);
    else if (!capReached && HasAura(SPELL_VALOR_OF_THE_ANCIENTS))
        RemoveAura(SPELL_VALOR_OF_THE_ANCIENTS);
}

void Player::UpdatePromotionAuras()
{
    for (auto&& promo : sObjectMgr->GetPromotionAurasData())
    {
        if (!promo.Active)
        {
            if (HasAura(promo.Entry))
                RemoveAura(promo.Entry);
            continue;
        }

        if (!HasAura(promo.Entry))
            CastSpell(this, promo.Entry, true);
    }
}

void Player::UpdateMount()
{
    if (!HasAuraType(SPELL_AURA_MOUNTED))
        return;

    AuraEffect* currentMountAura = GetAuraEffectsByType(SPELL_AURA_MOUNTED).front();

    MountCapabilityEntry const* mountCapability = GetMountCapability(currentMountAura->GetMiscValueB());

    if (mountCapability != m_mountCapability)
    {
        // Probably on wintergrasp we should to cast spells etc, but this is not implemented yet
        m_mountCapability = mountCapability;

        if (!m_mountCapability)
            RemoveAura(currentMountAura->GetBase());
    }
}

void Player::ApplyDeserter(bool reset /*= false*/)
{
    if (!sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
        return;

    if (!reset)
        CastSpell(this, 26013, true); // Deserter
    deserterMod = reset ? 0 : (GetDeserterMod() + 1);
    lastDeserterTime = reset ? 0 : time(nullptr);
}

void Player::_LoadDeserterInfo(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* field = result->Fetch();
        deserterMod = field[0].GetUInt8();
        lastDeserterTime = field[1].GetUInt32();
    } while (result->NextRow());
}

void Player::_SaveDeserterInfo(SQLTransaction& trans)
{
    PreparedStatement* stmt = nullptr;
    if (GetDeserterMod())
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_DESERTER_INFO);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt8(1, GetDeserterMod());
        stmt->setUInt32(2, GetLastDeserterTime());
    }
    else
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_DESERTER_INFO);
        stmt->setUInt32(0, GetGUIDLow());
    }
    trans->Append(stmt);
}

void Player::AddTotalBGCount(bool win)
{
    totalBGCount++;

    if (win)
        totalBGWins++;

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    std::string body = Format(GetSession()->GetTrinityString(LANG_BG_REWARD_BODY), GetTotalBGCount(), GetTotalBGWins());

    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_REWARDS_ENABLED))
    {
        if (GetTotalBGCount() % 15 == 0)
        {
            if (Item* item = Item::CreateItem(sWorld->getIntConfig(CONFIG_BATTLEGROUND_REWARD), 1))
            {
                MailDraft draft{ GetSession()->GetTrinityString(LANG_BG_REWARD_TITLE_POOR), body };
                item->SaveToDB(trans);
                draft.AddItem(item);
                draft.SendMailTo(trans, MailReceiver{ this, GetGUIDLow() }, MailSender{ MAIL_NORMAL, GetGUIDLow(), MAIL_STATIONERY_GM });
            }
        }
    }

    if (sWorld->getBoolConfig(CONFIG_ICORE_RICH_PVP_REWARD_ENABLED))
    {
        if (GetTotalBGCount() % sWorld->getIntConfig(CONFIG_ICORE_RICH_PVP_REWARD_GAMES) == 0 && roll_chance_i(sWorld->getIntConfig(CONFIG_ICORE_RICH_PVP_REWARD_CHANCE)))
        {
            if (Item* item = Item::CreateItem(sWorld->getIntConfig(CONFIG_ICORE_RICH_PVP_REWARD), 1))
            {
                MailDraft draft{ GetSession()->GetTrinityString(LANG_BG_REWARD_TITLE_RICH), body };
                item->SaveToDB(trans);
                draft.AddItem(item);
                draft.SendMailTo(trans, MailReceiver{ this, GetGUIDLow() }, MailSender{ MAIL_NORMAL, GetGUIDLow(), MAIL_STATIONERY_GM });
            }
        }
    }

    CharacterDatabase.CommitTransaction(trans);
}

void Player::_LoadBattlegroundStats(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* field = result->Fetch();
        totalBGCount = field[0].GetUInt32();
        totalBGWins = field[1].GetUInt32();
    } while (result->NextRow());
}

void Player::_SaveBattlegroundStats(SQLTransaction& trans)
{
    if (GetTotalBGCount())
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_BATTLEGROUND_STATS);
        stmt->setUInt32(0, GetGUIDLow());
        stmt->setUInt32(1, GetTotalBGCount());
        stmt->setUInt32(2, GetTotalBGWins());
        trans->Append(stmt);
    }
}

bool Player::CanRollForLootIn(WorldObject const* obj) const
{
    if (!IsAtGroupRewardDistance(obj))
        return false;

    if (Creature const* creature = obj->ToCreature())
        return creature->IsLootRecipientGroupMember(GetGUID());

    if (GameObject const* go = obj->ToGameObject())
        return go->IsLootRecipientGroupMember(GetGUID());

    return true;
}
